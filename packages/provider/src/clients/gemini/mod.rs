//! Google Gemini API client and Rig integration
//!
//! # Example
//! ```
//! use rig::providers::google;
//!
//! let client = google::Client::new("YOUR_API_KEY");
//!
//! let gemini_embedding_model = client.embedding_model(google::EMBEDDING_001);
//! ```

pub mod client;
pub mod completion;
pub mod embedding;
pub mod model_info;
pub mod streaming;
pub mod transcription;

// New modular implementation
pub mod gemini_client;
pub mod gemini_error;
pub mod gemini_streaming;
pub mod gemini_types;

pub use client::{Client, GeminiCompletionBuilder as OldGeminiCompletionBuilder};
pub use completion::{CompletionModel, GeminiCompletionBuilder, completion_builder};
pub use gemini_client::completion_builder as new_completion_builder;
// Re-export new modular components
pub use gemini_error::{GeminiError, GeminiResult};
pub use gemini_streaming::{GeminiStreamProcessor, StreamingMetrics, StreamingResponse};
pub use gemini_types::{
    Content, FunctionCall, FunctionResponse, GEMINI_1_0_PRO, GEMINI_1_5_FLASH, GEMINI_1_5_PRO,
    GEMINI_1_5_PRO_8B, GEMINI_2_0_FLASH, GEMINI_2_5_FLASH_PREVIEW_05_20,
    GEMINI_2_5_PRO_PREVIEW_06_05, GenerateContentRequest, GenerateContentResponse,
    GenerationConfig, Part, Role, Schema, available_models};

// API Response wrapper for compatibility
#[derive(Debug, serde::Deserialize)]
pub enum ApiResponse<T> {
    #[serde(rename = "data")]
    Ok(T),
    #[serde(rename = "error")]
    Err(ApiError)}

#[derive(Debug, serde::Deserialize)]
pub struct ApiError {
    pub message: String}

pub mod gemini_api_types {
    use serde::{Deserialize, Serialize};

    #[derive(Serialize, Deserialize, Debug, Clone, PartialEq)]
    #[serde(rename_all = "SCREAMING_SNAKE_CASE")]
    pub enum ExecutionLanguage {
        /// Unspecified language. This value should not be used.
        LanguageUnspecified,
        /// Python >= 3.10, with numpy and simply available.
        Python}

    /// Code generated by the model that is meant to be executed, and the result returned to the model.
    /// Only generated when using the CodeExecution tool, in which the code will be automatically executed,
    /// and a corresponding CodeExecutionResult will also be generated.
    #[derive(Debug, Deserialize, Serialize, Clone, PartialEq)]
    pub struct ExecutableCode {
        /// Programming language of the code.
        pub language: ExecutionLanguage,
        /// The code to be executed.
        pub code: String}
    #[derive(Serialize, Deserialize, Debug, Clone, PartialEq)]
    pub struct CodeExecutionResult {
        /// Outcome of the code execution.
        pub outcome: CodeExecutionOutcome,
        /// Contains stdout when code execution is successful, stderr or other description otherwise.
        #[serde(skip_serializing_if = "Option::is_none")]
        pub output: Option<String>}

    #[derive(Serialize, Deserialize, Debug, Clone, PartialEq)]
    pub enum CodeExecutionOutcome {
        /// Unspecified status. This value should not be used.
        #[serde(rename = "OUTCOME_UNSPECIFIED")]
        Unspecified,
        /// Code execution completed successfully.
        #[serde(rename = "OUTCOME_OK")]
        Ok,
        /// Code execution finished but with a failure. stderr should contain the reason.
        #[serde(rename = "OUTCOME_FAILED")]
        Failed,
        /// Code execution ran for too long, and was cancelled. There may or may not be a partial output present.
        #[serde(rename = "OUTCOME_DEADLINE_EXCEEDED")]
        DeadlineExceeded}
}
