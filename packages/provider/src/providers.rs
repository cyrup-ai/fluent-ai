use serde :: { Serialize , Deserialize } ; # [derive (Debug , Clone , PartialEq , Eq , Hash , Serialize , Deserialize)] pub enum Providers { Bedrock , Claude , Mistral , Openai , Vertexai , }
// AUTO-GENERATED START
use crate :: models :: Models ; use cyrup_sugars :: ZeroOneOrMany ; impl Providers { # [doc = r" Get provider name as static string - zero allocation"] pub fn name (& self) -> & 'static str { match self { Providers :: Openai => "openai" , Providers :: Claude => "claude" , Providers :: Mistral => "mistral" , Providers :: Vertexai => "vertexai" , Providers :: Bedrock => "bedrock" , } } # [doc = r" Get models for this provider - zero allocation"] pub fn models (& self) -> ZeroOneOrMany < Models > { match self { Providers :: Openai => ZeroOneOrMany :: Many (vec ! [Models :: Gpt41 , Models :: Gpt41Mini , Models :: Gpt41Nano , Models :: Gpt4O , Models :: Gpt4OSearchPreview , Models :: Gpt4OMini , Models :: Gpt4OMiniSearchPreview , Models :: Chatgpt4OLatest , Models :: O4Mini , Models :: O4MiniHigh , Models :: O3 , Models :: O3Mini , Models :: O3MiniHigh , Models :: Gpt4Turbo , Models :: Gpt35Turbo , Models :: TextEmbedding3Large , Models :: TextEmbedding3Small]) , Providers :: Claude => ZeroOneOrMany :: Many (vec ! [Models :: ClaudeOpus420250514 , Models :: ClaudeOpus420250514Thinking , Models :: ClaudeSonnet420250514 , Models :: ClaudeSonnet420250514Thinking , Models :: Claude37Sonnet20250219 , Models :: Claude37Sonnet20250219Thinking , Models :: Claude35Sonnet20241022 , Models :: Claude35Haiku20241022]) , Providers :: Mistral => ZeroOneOrMany :: Many (vec ! [Models :: MistralMediumLatest , Models :: MistralSmallLatest , Models :: MagistralMediumLatest , Models :: MagistralSmallLatest , Models :: DevstralMediumLatest , Models :: DevstralSmallLatest , Models :: CodestralLatest , Models :: MistralEmbed]) , Providers :: Vertexai => ZeroOneOrMany :: Many (vec ! [Models :: Gemini25Flash , Models :: Gemini25Pro , Models :: Gemini25FlashLitePreview0617 , Models :: Gemini20Flash001 , Models :: Gemini20FlashLite001 , Models :: ClaudeOpus420250514 , Models :: ClaudeOpus420250514Thinking , Models :: ClaudeSonnet420250514 , Models :: ClaudeSonnet420250514Thinking , Models :: Claude37Sonnet20250219 , Models :: Claude37Sonnet20250219Thinking , Models :: Claude35SonnetV220241022 , Models :: Claude35Haiku20241022 , Models :: MistralSmall2503 , Models :: Codestral2501 , Models :: TextEmbedding005 , Models :: TextMultilingualEmbedding002]) , Providers :: Bedrock => ZeroOneOrMany :: Many (vec ! [Models :: UsAnthropicClaudeOpus420250514V10 , Models :: UsAnthropicClaudeOpus420250514V10thinking , Models :: UsAnthropicClaudeSonnet420250514V10 , Models :: UsAnthropicClaudeSonnet420250514V10thinking , Models :: UsAnthropicClaude37Sonnet20250219V10 , Models :: UsAnthropicClaude37Sonnet20250219V10thinking , Models :: AnthropicClaude35Sonnet20241022V20 , Models :: AnthropicClaude35Haiku20241022V10 , Models :: UsMetaLlama4Maverick17BInstructV10 , Models :: UsMetaLlama4Scout17BInstructV10 , Models :: UsMetaLlama3370BInstructV10 , Models :: UsAmazonNovaPremierV10 , Models :: UsAmazonNovaProV10 , Models :: UsAmazonNovaLiteV10 , Models :: UsAmazonNovaMicroV10 , Models :: CohereEmbedEnglishV3 , Models :: CohereEmbedMultilingualV3 , Models :: UsDeepseekR1V10]) , } } # [doc = r" Create a Providers enum from a name string - only implemented providers"] pub fn from_name (name : & str) -> Option < Self > { match name { "openai" => Some (Providers :: Openai) , "gpt" => Some (Providers :: Openai) , "claude" => Some (Providers :: Claude) , "mistral" => Some (Providers :: Mistral) , "vertexai" => Some (Providers :: Vertexai) , "bedrock" => Some (Providers :: Bedrock) , _ => None , } } }
// AUTO-GENERATED END
