//! Production-quality incremental build script for fluent-ai provider generation
//!
//! Zero-allocation, HTTP3-powered dynamic model generation with incremental processing.
//! This build script orchestrates the complete provider and model registry generation
//! using the advanced build system developed for fluent-ai.

use std::env;
use std::fs;
use std::path::PathBuf;

// Import the build system modules (available in build-dependencies)
mod build_system {
    pub mod errors;
    pub mod yaml_processor;
    pub mod model_loader;
    pub mod change_detector;
    pub mod code_generator;
    pub mod incremental_generator;
    pub mod yaml_manager;
    pub mod performance;
}

use build_system::errors::{BuildError, BuildResult};
use build_system::yaml_manager::YamlManager;
use build_system::model_loader::ModelLoader;
use build_system::change_detector::ChangeDetector;
use build_system::code_generator::CodeGenerator;
use build_system::incremental_generator::{IncrementalGenerator, GenerationResult};
use build_system::performance::PerformanceMonitor;

/// Main build function with production error handling
#[tokio::main]
async fn main() -> BuildResult<()> {
    // Initialize performance monitoring
    let mut monitor = PerformanceMonitor::new();
    monitor.start_timing("build_script_total");

    println!("cargo:rerun-if-changed=build.rs");
    println!("cargo:rerun-if-changed=models.yaml");
    println!("cargo:rerun-if-changed=providers");
    println!("cargo:rerun-if-env-changed=FLUENT_AI_BUILD_MODE");
    println!("cargo:rerun-if-env-changed=FLUENT_AI_CACHE_DIR");

    let out_dir = env::var("OUT_DIR")
        .map_err(|e| BuildError::IoError(format!("Failed to get OUT_DIR: {}", e)))?;
    let dest_path = PathBuf::from(out_dir);

    println!("cargo:warning=Starting incremental provider generation...");

    // Execute the incremental build system
    match run_incremental_build(&dest_path).await {
        Ok(result) => {
            monitor.stop_timing("build_script_total");
            
            println!("cargo:warning=Build completed successfully:");
            println!("cargo:warning=  Generated: {} files", result.files_generated);
            println!("cargo:warning=  Updated: {} files", result.files_updated);
            println!("cargo:warning=  Preserved: {} files", result.files_preserved);
            println!("cargo:warning=  Total time: {}ms", result.generation_time_ms);
            
            if !result.warnings.is_empty() {
                for warning in &result.warnings {
                    println!("cargo:warning=  Warning: {}", warning);
                }
            }

            // Report performance metrics
            if let Some(metrics) = monitor.get_metrics() {
                println!("cargo:warning=Performance metrics:");
                for (operation, duration) in metrics.timings {
                    println!("cargo:warning=  {}: {}ms", operation, duration);
                }
            }

            Ok(())
        }
        Err(e) => {
            monitor.stop_timing("build_script_total");
            println!("cargo:warning=Build failed: {}", e);
            
            // Fallback to basic generation to prevent build failure
            println!("cargo:warning=Falling back to basic provider generation...");
            generate_basic_fallback(&dest_path)?;
            
            Ok(())
        }
    }
}

/// Run the full incremental build system
async fn run_incremental_build(dest_path: &PathBuf) -> BuildResult<GenerationResult> {
    // Initialize build system components
    let yaml_manager = YamlManager::new().await?;
    let model_loader = ModelLoader::new()?;
    let change_detector = ChangeDetector::new()?;
    let code_generator = CodeGenerator::new()?;

    // Create incremental generator
    let mut generator = IncrementalGenerator::new(
        yaml_manager,
        model_loader,
        change_detector,
        code_generator,
    );

    // Set output directory
    generator.set_output_directory(dest_path.clone());

    // Check for build mode environment variable
    let build_mode = env::var("FLUENT_AI_BUILD_MODE")
        .unwrap_or_else(|_| "incremental".to_string());

    match build_mode.as_str() {
        "full" => {
            println!("cargo:warning=Running full regeneration...");
            generator.generate_full().await
        }
        "incremental" | _ => {
            println!("cargo:warning=Running incremental generation...");
            generator.generate_incremental().await
        }
    }
}

/// Fallback generation for when the advanced build system fails
fn generate_basic_fallback(dest_path: &PathBuf) -> BuildResult<()> {
    // Generate basic providers.rs
    let providers_content = r#"//! Generated provider implementations (FALLBACK)
//! This file is automatically generated by the build script fallback.

use std::collections::HashMap;
use std::sync::Arc;

// Basic provider registry
pub fn get_all_providers() -> Vec<String> {
    vec![
        "openai".to_string(),
        "anthropic".to_string(),
        "google".to_string(),
        "mistral".to_string(),
    ]
}

// Provider enumeration
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum ProviderType {
    OpenAI,
    Anthropic,
    Google,
    Mistral,
}

impl std::fmt::Display for ProviderType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            ProviderType::OpenAI => write!(f, "openai"),
            ProviderType::Anthropic => write!(f, "anthropic"),
            ProviderType::Google => write!(f, "google"),
            ProviderType::Mistral => write!(f, "mistral"),
        }
    }
}

// Basic provider configuration
pub struct ProviderConfig {
    pub name: String,
    pub base_url: String,
    pub api_version: String,
}

impl ProviderConfig {
    pub fn openai() -> Self {
        Self {
            name: "openai".to_string(),
            base_url: "https://api.openai.com/v1".to_string(),
            api_version: "v1".to_string(),
        }
    }

    pub fn anthropic() -> Self {
        Self {
            name: "anthropic".to_string(),
            base_url: "https://api.anthropic.com/v1".to_string(),
            api_version: "2023-06-01".to_string(),
        }
    }
}
"#;
    
    let providers_path = dest_path.join("providers.rs");
    fs::write(&providers_path, providers_content)
        .map_err(|e| BuildError::IoError(format!("Failed to write providers.rs: {}", e)))?;

    // Generate basic models.rs
    let models_content = r#"//! Generated model registry (FALLBACK)
//! This file is automatically generated by the build script fallback.

use std::collections::HashMap;
use std::sync::Arc;

// Placeholder ModelInfo struct for fallback
#[derive(Debug, Clone)]
pub struct ModelInfo {
    pub name: String,
    pub provider_name: String,
    pub max_tokens: u32,
}

/// Basic model registry for fallback mode
pub struct ModelRegistry {
    models: HashMap<String, ModelInfo>,
    provider_models: HashMap<String, Vec<String>>,
}

impl ModelRegistry {
    /// Create a new model registry with basic models
    pub fn new() -> Self {
        let mut registry = Self {
            models: HashMap::new(),
            provider_models: HashMap::new(),
        };

        // Add basic OpenAI models
        registry.register_model(ModelInfo {
            name: "gpt-4".to_string(),
            provider_name: "openai".to_string(),
            max_tokens: 8192,
        });

        registry.register_model(ModelInfo {
            name: "gpt-3.5-turbo".to_string(),
            provider_name: "openai".to_string(),
            max_tokens: 4096,
        });

        // Add basic Anthropic models
        registry.register_model(ModelInfo {
            name: "claude-3-opus".to_string(),
            provider_name: "anthropic".to_string(),
            max_tokens: 4096,
        });

        registry
    }

    /// Get all registered models
    pub fn get_all_models(&self) -> &HashMap<String, ModelInfo> {
        &self.models
    }

    /// Get models for a specific provider
    pub fn get_provider_models(&self, provider: &str) -> Vec<&ModelInfo> {
        self.provider_models
            .get(provider)
            .map(|model_ids| {
                model_ids
                    .iter()
                    .filter_map(|id| self.models.get(id))
                    .collect()
            })
            .unwrap_or_default()
    }

    /// Register a model
    pub fn register_model(&mut self, model: ModelInfo) {
        let provider = model.provider_name.clone();
        let model_id = format!("{}:{}", model.provider_name, model.name);
        
        self.models.insert(model_id.clone(), model);
        self.provider_models
            .entry(provider)
            .or_insert_with(Vec::new)
            .push(model_id);
    }
}

impl Default for ModelRegistry {
    fn default() -> Self {
        Self::new()
    }
}

/// Get the global model registry
pub fn get_model_registry() -> ModelRegistry {
    ModelRegistry::new()
}

/// Initialize all models from providers
pub fn initialize_models() -> Result<ModelRegistry, Box<dyn std::error::Error + Send + Sync>> {
    Ok(get_model_registry())
}
"#;
    
    let models_path = dest_path.join("models.rs");
    fs::write(&models_path, models_content)
        .map_err(|e| BuildError::IoError(format!("Failed to write models.rs: {}", e)))?;

    println!("cargo:warning=Generated fallback providers.rs and models.rs");
    Ok(())
}