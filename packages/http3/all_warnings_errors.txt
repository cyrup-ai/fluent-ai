    Checking fluent_ai_http3 v0.1.0 (/Volumes/samsung_t9/fluent-ai/packages/http3)
error[E0432]: unresolved import `tls_connections::establish_native_tls_connection`
  --> packages/http3/src/connect/tcp/mod.rs:22:32
   |
22 |     establish_http_connection, establish_native_tls_connection, establish_rustls_connection,
   |                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |                                |
   |                                no `establish_native_tls_connection` in `connect::tcp::tls_connections`
   |                                help: a similar name exists in the module: `establish_rustls_connection`
   |
note: found an item that was configured out
  --> packages/http3/src/connect/tcp/tls_connections.rs:33:8
   |
32 | #[cfg(feature = "default-tls")]
   |       ----------------------- the item is gated behind the `default-tls` feature
33 | pub fn establish_native_tls_connection(
   |        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0432]: unresolved import `const_oid::db::rfc3279`
 --> packages/http3/src/tls/certificate/parser.rs:7:20
  |
7 | use const_oid::db::rfc3279::ID_DSA;
  |                    ^^^^^^^ could not find `rfc3279` in `db`

error[E0432]: unresolved imports `const_oid::db::rfc5280::ID_RSA_ENCRYPTION`, `const_oid::db::rfc5280::DH_PUBLIC_NUMBER`
 --> packages/http3/src/tls/certificate/parser.rs:8:30
  |
8 | use const_oid::db::rfc5280::{ID_RSA_ENCRYPTION, DH_PUBLIC_NUMBER};
  |                              ^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^^^^^^ no `DH_PUBLIC_NUMBER` in `db::generated::rfc5280`
  |                              |
  |                              no `ID_RSA_ENCRYPTION` in `db::generated::rfc5280`

error[E0432]: unresolved imports `const_oid::db::rfc5912::SECP192R1`, `const_oid::db::rfc5912::SECP192K1`, `const_oid::db::rfc5912::SECP224R1`, `const_oid::db::rfc5912::SECP224K1`, `const_oid::db::rfc5912::SECP256R1`, `const_oid::db::rfc5912::SECP384R1`, `const_oid::db::rfc5912::SECP521R1`, `const_oid::db::rfc5912::SECP256K1`
 --> packages/http3/src/tls/certificate/parser.rs:9:30
  |
9 | use const_oid::db::rfc5912::{SECP192R1, SECP192K1, SECP224R1, SECP224K1, SECP256R1, SECP384R1, SECP521R1, SECP256K1};
  |                              ^^^^^^^^^  ^^^^^^^^^  ^^^^^^^^^  ^^^^^^^^^  ^^^^^^^^^  ^^^^^^^^^  ^^^^^^^^^  ^^^^^^^^^ no `SECP256K1` in `db::generated::rfc5912`
  |                              |          |          |          |          |          |          |
  |                              |          |          |          |          |          |          no `SECP521R1` in `db::generated::rfc5912`
  |                              |          |          |          |          |          no `SECP384R1` in `db::generated::rfc5912`
  |                              |          |          |          |          no `SECP256R1` in `db::generated::rfc5912`
  |                              |          |          |          no `SECP224K1` in `db::generated::rfc5912`
  |                              |          |          no `SECP224R1` in `db::generated::rfc5912`
  |                              |          no `SECP192K1` in `db::generated::rfc5912`
  |                              no `SECP192R1` in `db::generated::rfc5912`
  |
help: a similar name exists in the module
  |
9 - use const_oid::db::rfc5912::{SECP192R1, SECP192K1, SECP224R1, SECP224K1, SECP256R1, SECP384R1, SECP521R1, SECP256K1};
9 + use const_oid::db::rfc5912::{SECP192R1, SECP192K1, SECP_224_R_1, SECP224K1, SECP256R1, SECP384R1, SECP521R1, SECP256K1};
  |
help: a similar name exists in the module
  |
9 - use const_oid::db::rfc5912::{SECP192R1, SECP192K1, SECP224R1, SECP224K1, SECP256R1, SECP384R1, SECP521R1, SECP256K1};
9 + use const_oid::db::rfc5912::{SECP192R1, SECP192K1, SECP224R1, SECP224K1, SECP_256_R_1, SECP384R1, SECP521R1, SECP256K1};
  |
help: a similar name exists in the module
  |
9 - use const_oid::db::rfc5912::{SECP192R1, SECP192K1, SECP224R1, SECP224K1, SECP256R1, SECP384R1, SECP521R1, SECP256K1};
9 + use const_oid::db::rfc5912::{SECP192R1, SECP192K1, SECP224R1, SECP224K1, SECP256R1, SECP_384_R_1, SECP521R1, SECP256K1};
  |
help: a similar name exists in the module
  |
9 - use const_oid::db::rfc5912::{SECP192R1, SECP192K1, SECP224R1, SECP224K1, SECP256R1, SECP384R1, SECP521R1, SECP256K1};
9 + use const_oid::db::rfc5912::{SECP192R1, SECP192K1, SECP224R1, SECP224K1, SECP256R1, SECP384R1, SECP_521_R_1, SECP256K1};
  |

error[E0432]: unresolved import `const_oid::db::rfc7027`
  --> packages/http3/src/tls/certificate/parser.rs:10:20
   |
10 | use const_oid::db::rfc7027::{BRAINPOOL_P160R1, BRAINPOOL_P160T1, BRAINPOOL_P192R1, BRAINPOOL_P192T1, BRAINPOOL_P224R1, BRAINPOOL_P224T1, ...
   |                    ^^^^^^^ could not find `rfc7027` in `db`

error[E0432]: unresolved imports `const_oid::db::rfc8410::ID_X25519`, `const_oid::db::rfc8410::ID_X448`, `const_oid::db::rfc8410::ID_ED25519`, `const_oid::db::rfc8410::ID_ED448`
  --> packages/http3/src/tls/certificate/parser.rs:11:30
   |
11 | use const_oid::db::rfc8410::{ID_X25519, ID_X448, ID_ED25519, ID_ED448};
   |                              ^^^^^^^^^  ^^^^^^^  ^^^^^^^^^^  ^^^^^^^^ no `ID_ED448` in `db::generated::rfc8410`
   |                              |          |        |
   |                              |          |        no `ID_ED25519` in `db::generated::rfc8410`
   |                              |          no `ID_X448` in `db::generated::rfc8410`
   |                              no `ID_X25519` in `db::generated::rfc8410`
   |
help: a similar name exists in the module
   |
11 | use const_oid::db::rfc8410::{ID_X_25519, ID_X448, ID_ED25519, ID_ED448};
   |                                  +
help: a similar name exists in the module
   |
11 | use const_oid::db::rfc8410::{ID_X25519, ID_X_448, ID_ED25519, ID_ED448};
   |                                             +
help: a similar name exists in the module
   |
11 | use const_oid::db::rfc8410::{ID_X25519, ID_X448, ID_ED_25519, ID_ED448};
   |                                                       +
help: a similar name exists in the module
   |
11 | use const_oid::db::rfc8410::{ID_X25519, ID_X448, ID_ED25519, ID_ED_448};
   |                                                                   +

error[E0432]: unresolved import `const_oid::db::rfc3279`
   --> packages/http3/src/tls/certificate/parser.rs:452:24
    |
452 |     use const_oid::db::rfc3279::ID_DSA;
    |                        ^^^^^^^ could not find `rfc3279` in `db`

error[E0432]: unresolved imports `const_oid::db::rfc5280::ID_RSA_ENCRYPTION`, `const_oid::db::rfc5280::DH_PUBLIC_NUMBER`
   --> packages/http3/src/tls/certificate/parser.rs:453:34
    |
453 |     use const_oid::db::rfc5280::{ID_RSA_ENCRYPTION, DH_PUBLIC_NUMBER};
    |                                  ^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^^^^^^ no `DH_PUBLIC_NUMBER` in `db::generated::rfc5280`
    |                                  |
    |                                  no `ID_RSA_ENCRYPTION` in `db::generated::rfc5280`
    |
    = help: consider importing this unresolved item through its public re-export instead:
            crate::tls::certificate::parser::ID_RSA_ENCRYPTION
    = help: consider importing this unresolved item through its public re-export instead:
            crate::tls::certificate::parser::DH_PUBLIC_NUMBER

error[E0432]: unresolved imports `const_oid::db::rfc8410::ID_X25519`, `const_oid::db::rfc8410::ID_X448`, `const_oid::db::rfc8410::ID_ED25519`, `const_oid::db::rfc8410::ID_ED448`
   --> packages/http3/src/tls/certificate/parser.rs:455:34
    |
455 |     use const_oid::db::rfc8410::{ID_X25519, ID_X448, ID_ED25519, ID_ED448};
    |                                  ^^^^^^^^^  ^^^^^^^  ^^^^^^^^^^  ^^^^^^^^ no `ID_ED448` in `db::generated::rfc8410`
    |                                  |          |        |
    |                                  |          |        no `ID_ED25519` in `db::generated::rfc8410`
    |                                  |          no `ID_X448` in `db::generated::rfc8410`
    |                                  no `ID_X25519` in `db::generated::rfc8410`
    |
    = help: consider importing this unresolved item through its public re-export instead:
            crate::tls::certificate::parser::ID_X25519
    = help: consider importing this unresolved item through its public re-export instead:
            crate::tls::certificate::parser::ID_X448
    = help: consider importing this unresolved item through its public re-export instead:
            crate::tls::certificate::parser::ID_ED25519
    = help: consider importing this unresolved item through its public re-export instead:
            crate::tls::certificate::parser::ID_ED448
help: a similar name exists in the module
    |
455 |     use const_oid::db::rfc8410::{ID_X_25519, ID_X448, ID_ED25519, ID_ED448};
    |                                      +
help: a similar name exists in the module
    |
455 |     use const_oid::db::rfc8410::{ID_X25519, ID_X_448, ID_ED25519, ID_ED448};
    |                                                 +
help: a similar name exists in the module
    |
455 |     use const_oid::db::rfc8410::{ID_X25519, ID_X448, ID_ED_25519, ID_ED448};
    |                                                           +
help: a similar name exists in the module
    |
455 |     use const_oid::db::rfc8410::{ID_X25519, ID_X448, ID_ED25519, ID_ED_448};
    |                                                                       +

error[E0408]: variable `SECP192K1` is not bound in all patterns
   --> packages/http3/src/tls/certificate/parser.rs:586:17
    |
586 |                 SECP192R1 | SECP192K1 => Some(192),
    |                 ^^^^^^^^^   --------- variable not in all patterns
    |                 |
    |                 pattern doesn't bind `SECP192K1`
    |
help: if you meant to match on a variant or a `const` item, consider making the path in the pattern qualified: `path::to::ModOrType::SECP192K1`
   --> packages/http3/src/tls/certificate/parser.rs:586:29
    |
586 |                 SECP192R1 | SECP192K1 => Some(192),
    |                             ^^^^^^^^^

error[E0408]: variable `SECP192R1` is not bound in all patterns
   --> packages/http3/src/tls/certificate/parser.rs:586:29
    |
586 |                 SECP192R1 | SECP192K1 => Some(192),
    |                 ---------   ^^^^^^^^^ pattern doesn't bind `SECP192R1`
    |                 |
    |                 variable not in all patterns
    |
help: if you meant to match on a variant or a `const` item, consider making the path in the pattern qualified: `path::to::ModOrType::SECP192R1`
   --> packages/http3/src/tls/certificate/parser.rs:586:17
    |
586 |                 SECP192R1 | SECP192K1 => Some(192),
    |                 ^^^^^^^^^

error[E0408]: variable `SECP224K1` is not bound in all patterns
   --> packages/http3/src/tls/certificate/parser.rs:587:17
    |
587 |                 SECP224R1 | SECP224K1 => Some(224),
    |                 ^^^^^^^^^   --------- variable not in all patterns
    |                 |
    |                 pattern doesn't bind `SECP224K1`
    |
help: if you meant to match on a variant or a `const` item, consider making the path in the pattern qualified: `path::to::ModOrType::SECP224K1`
   --> packages/http3/src/tls/certificate/parser.rs:587:29
    |
587 |                 SECP224R1 | SECP224K1 => Some(224),
    |                             ^^^^^^^^^

error[E0408]: variable `SECP224R1` is not bound in all patterns
   --> packages/http3/src/tls/certificate/parser.rs:587:29
    |
587 |                 SECP224R1 | SECP224K1 => Some(224),
    |                 ---------   ^^^^^^^^^ pattern doesn't bind `SECP224R1`
    |                 |
    |                 variable not in all patterns
    |
help: if you meant to match on a variant or a `const` item, consider making the path in the pattern qualified: `path::to::ModOrType::SECP224R1`
   --> packages/http3/src/tls/certificate/parser.rs:587:17
    |
587 |                 SECP224R1 | SECP224K1 => Some(224),
    |                 ^^^^^^^^^

error[E0408]: variable `SECP256K1` is not bound in all patterns
   --> packages/http3/src/tls/certificate/parser.rs:588:17
    |
588 |                 SECP256R1 | SECP256K1 => Some(256),
    |                 ^^^^^^^^^   --------- variable not in all patterns
    |                 |
    |                 pattern doesn't bind `SECP256K1`
    |
help: if you meant to match on a variant or a `const` item, consider making the path in the pattern qualified: `path::to::ModOrType::SECP256K1`
   --> packages/http3/src/tls/certificate/parser.rs:588:29
    |
588 |                 SECP256R1 | SECP256K1 => Some(256),
    |                             ^^^^^^^^^

error[E0408]: variable `SECP256R1` is not bound in all patterns
   --> packages/http3/src/tls/certificate/parser.rs:588:29
    |
588 |                 SECP256R1 | SECP256K1 => Some(256),
    |                 ---------   ^^^^^^^^^ pattern doesn't bind `SECP256R1`
    |                 |
    |                 variable not in all patterns
    |
help: if you meant to match on a variant or a `const` item, consider making the path in the pattern qualified: `path::to::ModOrType::SECP256R1`
   --> packages/http3/src/tls/certificate/parser.rs:588:17
    |
588 |                 SECP256R1 | SECP256K1 => Some(256),
    |                 ^^^^^^^^^

error[E0408]: variable `BRAINPOOL_P160T1` is not bound in all patterns
   --> packages/http3/src/tls/certificate/parser.rs:591:17
    |
591 |                 BRAINPOOL_P160R1 | BRAINPOOL_P160T1 => Some(160),
    |                 ^^^^^^^^^^^^^^^^   ---------------- variable not in all patterns
    |                 |
    |                 pattern doesn't bind `BRAINPOOL_P160T1`
    |
help: if you meant to match on a variant or a `const` item, consider making the path in the pattern qualified: `path::to::ModOrType::BRAINPOOL_P160T1`
   --> packages/http3/src/tls/certificate/parser.rs:591:36
    |
591 |                 BRAINPOOL_P160R1 | BRAINPOOL_P160T1 => Some(160),
    |                                    ^^^^^^^^^^^^^^^^

error[E0408]: variable `BRAINPOOL_P160R1` is not bound in all patterns
   --> packages/http3/src/tls/certificate/parser.rs:591:36
    |
591 |                 BRAINPOOL_P160R1 | BRAINPOOL_P160T1 => Some(160),
    |                 ----------------   ^^^^^^^^^^^^^^^^ pattern doesn't bind `BRAINPOOL_P160R1`
    |                 |
    |                 variable not in all patterns
    |
help: if you meant to match on a variant or a `const` item, consider making the path in the pattern qualified: `path::to::ModOrType::BRAINPOOL_P160R1`
   --> packages/http3/src/tls/certificate/parser.rs:591:17
    |
591 |                 BRAINPOOL_P160R1 | BRAINPOOL_P160T1 => Some(160),
    |                 ^^^^^^^^^^^^^^^^

error[E0408]: variable `BRAINPOOL_P192T1` is not bound in all patterns
   --> packages/http3/src/tls/certificate/parser.rs:592:17
    |
592 |                 BRAINPOOL_P192R1 | BRAINPOOL_P192T1 => Some(192),
    |                 ^^^^^^^^^^^^^^^^   ---------------- variable not in all patterns
    |                 |
    |                 pattern doesn't bind `BRAINPOOL_P192T1`
    |
help: if you meant to match on a variant or a `const` item, consider making the path in the pattern qualified: `path::to::ModOrType::BRAINPOOL_P192T1`
   --> packages/http3/src/tls/certificate/parser.rs:592:36
    |
592 |                 BRAINPOOL_P192R1 | BRAINPOOL_P192T1 => Some(192),
    |                                    ^^^^^^^^^^^^^^^^

error[E0408]: variable `BRAINPOOL_P192R1` is not bound in all patterns
   --> packages/http3/src/tls/certificate/parser.rs:592:36
    |
592 |                 BRAINPOOL_P192R1 | BRAINPOOL_P192T1 => Some(192),
    |                 ----------------   ^^^^^^^^^^^^^^^^ pattern doesn't bind `BRAINPOOL_P192R1`
    |                 |
    |                 variable not in all patterns
    |
help: if you meant to match on a variant or a `const` item, consider making the path in the pattern qualified: `path::to::ModOrType::BRAINPOOL_P192R1`
   --> packages/http3/src/tls/certificate/parser.rs:592:17
    |
592 |                 BRAINPOOL_P192R1 | BRAINPOOL_P192T1 => Some(192),
    |                 ^^^^^^^^^^^^^^^^

error[E0408]: variable `BRAINPOOL_P224T1` is not bound in all patterns
   --> packages/http3/src/tls/certificate/parser.rs:593:17
    |
593 |                 BRAINPOOL_P224R1 | BRAINPOOL_P224T1 => Some(224),
    |                 ^^^^^^^^^^^^^^^^   ---------------- variable not in all patterns
    |                 |
    |                 pattern doesn't bind `BRAINPOOL_P224T1`
    |
help: if you meant to match on a variant or a `const` item, consider making the path in the pattern qualified: `path::to::ModOrType::BRAINPOOL_P224T1`
   --> packages/http3/src/tls/certificate/parser.rs:593:36
    |
593 |                 BRAINPOOL_P224R1 | BRAINPOOL_P224T1 => Some(224),
    |                                    ^^^^^^^^^^^^^^^^

error[E0408]: variable `BRAINPOOL_P224R1` is not bound in all patterns
   --> packages/http3/src/tls/certificate/parser.rs:593:36
    |
593 |                 BRAINPOOL_P224R1 | BRAINPOOL_P224T1 => Some(224),
    |                 ----------------   ^^^^^^^^^^^^^^^^ pattern doesn't bind `BRAINPOOL_P224R1`
    |                 |
    |                 variable not in all patterns
    |
help: if you meant to match on a variant or a `const` item, consider making the path in the pattern qualified: `path::to::ModOrType::BRAINPOOL_P224R1`
   --> packages/http3/src/tls/certificate/parser.rs:593:17
    |
593 |                 BRAINPOOL_P224R1 | BRAINPOOL_P224T1 => Some(224),
    |                 ^^^^^^^^^^^^^^^^

error[E0408]: variable `BRAINPOOL_P256T1` is not bound in all patterns
   --> packages/http3/src/tls/certificate/parser.rs:594:17
    |
594 |                 BRAINPOOL_P256R1 | BRAINPOOL_P256T1 => Some(256),
    |                 ^^^^^^^^^^^^^^^^   ---------------- variable not in all patterns
    |                 |
    |                 pattern doesn't bind `BRAINPOOL_P256T1`
    |
help: if you meant to match on a variant or a `const` item, consider making the path in the pattern qualified: `path::to::ModOrType::BRAINPOOL_P256T1`
   --> packages/http3/src/tls/certificate/parser.rs:594:36
    |
594 |                 BRAINPOOL_P256R1 | BRAINPOOL_P256T1 => Some(256),
    |                                    ^^^^^^^^^^^^^^^^

error[E0408]: variable `BRAINPOOL_P256R1` is not bound in all patterns
   --> packages/http3/src/tls/certificate/parser.rs:594:36
    |
594 |                 BRAINPOOL_P256R1 | BRAINPOOL_P256T1 => Some(256),
    |                 ----------------   ^^^^^^^^^^^^^^^^ pattern doesn't bind `BRAINPOOL_P256R1`
    |                 |
    |                 variable not in all patterns
    |
help: if you meant to match on a variant or a `const` item, consider making the path in the pattern qualified: `path::to::ModOrType::BRAINPOOL_P256R1`
   --> packages/http3/src/tls/certificate/parser.rs:594:17
    |
594 |                 BRAINPOOL_P256R1 | BRAINPOOL_P256T1 => Some(256),
    |                 ^^^^^^^^^^^^^^^^

error[E0408]: variable `BRAINPOOL_P320T1` is not bound in all patterns
   --> packages/http3/src/tls/certificate/parser.rs:595:17
    |
595 |                 BRAINPOOL_P320R1 | BRAINPOOL_P320T1 => Some(320),
    |                 ^^^^^^^^^^^^^^^^   ---------------- variable not in all patterns
    |                 |
    |                 pattern doesn't bind `BRAINPOOL_P320T1`
    |
help: if you meant to match on a variant or a `const` item, consider making the path in the pattern qualified: `path::to::ModOrType::BRAINPOOL_P320T1`
   --> packages/http3/src/tls/certificate/parser.rs:595:36
    |
595 |                 BRAINPOOL_P320R1 | BRAINPOOL_P320T1 => Some(320),
    |                                    ^^^^^^^^^^^^^^^^

error[E0408]: variable `BRAINPOOL_P320R1` is not bound in all patterns
   --> packages/http3/src/tls/certificate/parser.rs:595:36
    |
595 |                 BRAINPOOL_P320R1 | BRAINPOOL_P320T1 => Some(320),
    |                 ----------------   ^^^^^^^^^^^^^^^^ pattern doesn't bind `BRAINPOOL_P320R1`
    |                 |
    |                 variable not in all patterns
    |
help: if you meant to match on a variant or a `const` item, consider making the path in the pattern qualified: `path::to::ModOrType::BRAINPOOL_P320R1`
   --> packages/http3/src/tls/certificate/parser.rs:595:17
    |
595 |                 BRAINPOOL_P320R1 | BRAINPOOL_P320T1 => Some(320),
    |                 ^^^^^^^^^^^^^^^^

error[E0408]: variable `BRAINPOOL_P384T1` is not bound in all patterns
   --> packages/http3/src/tls/certificate/parser.rs:596:17
    |
596 |                 BRAINPOOL_P384R1 | BRAINPOOL_P384T1 => Some(384),
    |                 ^^^^^^^^^^^^^^^^   ---------------- variable not in all patterns
    |                 |
    |                 pattern doesn't bind `BRAINPOOL_P384T1`
    |
help: if you meant to match on a variant or a `const` item, consider making the path in the pattern qualified: `path::to::ModOrType::BRAINPOOL_P384T1`
   --> packages/http3/src/tls/certificate/parser.rs:596:36
    |
596 |                 BRAINPOOL_P384R1 | BRAINPOOL_P384T1 => Some(384),
    |                                    ^^^^^^^^^^^^^^^^

error[E0408]: variable `BRAINPOOL_P384R1` is not bound in all patterns
   --> packages/http3/src/tls/certificate/parser.rs:596:36
    |
596 |                 BRAINPOOL_P384R1 | BRAINPOOL_P384T1 => Some(384),
    |                 ----------------   ^^^^^^^^^^^^^^^^ pattern doesn't bind `BRAINPOOL_P384R1`
    |                 |
    |                 variable not in all patterns
    |
help: if you meant to match on a variant or a `const` item, consider making the path in the pattern qualified: `path::to::ModOrType::BRAINPOOL_P384R1`
   --> packages/http3/src/tls/certificate/parser.rs:596:17
    |
596 |                 BRAINPOOL_P384R1 | BRAINPOOL_P384T1 => Some(384),
    |                 ^^^^^^^^^^^^^^^^

error[E0408]: variable `BRAINPOOL_P512T1` is not bound in all patterns
   --> packages/http3/src/tls/certificate/parser.rs:597:17
    |
597 |                 BRAINPOOL_P512R1 | BRAINPOOL_P512T1 => Some(512),
    |                 ^^^^^^^^^^^^^^^^   ---------------- variable not in all patterns
    |                 |
    |                 pattern doesn't bind `BRAINPOOL_P512T1`
    |
help: if you meant to match on a variant or a `const` item, consider making the path in the pattern qualified: `path::to::ModOrType::BRAINPOOL_P512T1`
   --> packages/http3/src/tls/certificate/parser.rs:597:36
    |
597 |                 BRAINPOOL_P512R1 | BRAINPOOL_P512T1 => Some(512),
    |                                    ^^^^^^^^^^^^^^^^

error[E0408]: variable `BRAINPOOL_P512R1` is not bound in all patterns
   --> packages/http3/src/tls/certificate/parser.rs:597:36
    |
597 |                 BRAINPOOL_P512R1 | BRAINPOOL_P512T1 => Some(512),
    |                 ----------------   ^^^^^^^^^^^^^^^^ pattern doesn't bind `BRAINPOOL_P512R1`
    |                 |
    |                 variable not in all patterns
    |
help: if you meant to match on a variant or a `const` item, consider making the path in the pattern qualified: `path::to::ModOrType::BRAINPOOL_P512R1`
   --> packages/http3/src/tls/certificate/parser.rs:597:17
    |
597 |                 BRAINPOOL_P512R1 | BRAINPOOL_P512T1 => Some(512),
    |                 ^^^^^^^^^^^^^^^^

error[E0412]: cannot find type `Sender` in module `fluent_ai_async::prelude`
  --> packages/http3/src/connect/service/direct.rs:19:40
   |
19 |     sender: &fluent_ai_async::prelude::Sender<TcpConnectionChunk>,
   |                                        ^^^^^^ not found in `fluent_ai_async::prelude`
   |
help: consider importing one of these structs
   |
 6 + use std::sync::mpmc::Sender;
   |
 6 + use std::sync::mpsc::Sender;
   |
 6 + use crossbeam_channel::Sender;
   |
 6 + use fluent_ai_async::prelude::mpsc::Sender;
   |
help: if you import `Sender`, refer to it directly
   |
19 -     sender: &fluent_ai_async::prelude::Sender<TcpConnectionChunk>,
19 +     sender: &Sender<TcpConnectionChunk>,
   |

error[E0412]: cannot find type `Issuer` in this scope
  --> packages/http3/src/tls/certificate/generation.rs:64:5
   |
64 |     Issuer<'static, KeyPair>,
   |     ^^^^^^ not found in this scope

error[E0412]: cannot find type `Issuer` in this scope
   --> packages/http3/src/tls/certificate/generation.rs:117:5
    |
117 |     Issuer<'static, KeyPair>,
    |     ^^^^^^ not found in this scope

error[E0412]: cannot find type `Issuer` in this scope
   --> packages/http3/src/tls/certificate/generation.rs:203:17
    |
203 |     ca_issuer: &Issuer<'static, KeyPair>,
    |                 ^^^^^^ not found in this scope

warning: ambiguous glob re-exports
 --> packages/http3/src/auth/mod.rs:6:9
  |
6 | pub use auth::*;
  |         ^^^^^^^ the name `BasicAuth` in the type namespace is first re-exported here
7 | pub use basic_auth::*;
  |         ------------- but the name `BasicAuth` in the type namespace is also re-exported here
  |
  = note: `#[warn(ambiguous_glob_reexports)]` on by default

warning: unused import: `std::time::Duration`
 --> packages/http3/src/builder/builder_core.rs:8:5
  |
8 | use std::time::Duration;
  |     ^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unused imports: `HeaderMap` and `Version`
  --> packages/http3/src/builder/builder_core.rs:11:12
   |
11 | use http::{HeaderMap, Method, Version};
   |            ^^^^^^^^^          ^^^^^^^

warning: unused import: `crate::protocols::quiche::QuichePacketChunk as DownloadChunk`
  --> packages/http3/src/builder/fluent.rs:11:5
   |
11 | use crate::protocols::quiche::QuichePacketChunk as DownloadChunk;
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `crate::builder::execution::HttpStream`
  --> packages/http3/src/builder/fluent.rs:13:5
   |
13 | use crate::builder::execution::HttpStream;
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `crate::builder::execution::HttpStream`
 --> packages/http3/src/builder/methods/body_methods.rs:9:5
  |
9 | use crate::builder::execution::HttpStream;
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `crate::protocols::quiche::QuicheConnectionChunk`
 --> packages/http3/src/builder/streaming.rs:8:5
  |
8 | use crate::protocols::quiche::QuicheConnectionChunk;
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `HttpStatus`
  --> packages/http3/src/cache/response_cache/operations.rs:50:64
   |
50 |         use crate::http::response::{HttpBodyChunk, HttpHeader, HttpStatus};
   |                                                                ^^^^^^^^^^

warning: unused import: `crate::error::HttpError`
  --> packages/http3/src/client/core.rs:11:5
   |
11 | use crate::error::HttpError;
   |     ^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `HttpResponse`
  --> packages/http3/src/client/core.rs:12:32
   |
12 | use crate::http::{HttpRequest, HttpResponse};
   |                                ^^^^^^^^^^^^

warning: unused import: `QuicheConnectionChunk`
 --> packages/http3/src/client/execution.rs:9:32
  |
9 | use crate::protocols::quiche::{QuicheConnectionChunk, QuichePacketChunk as DownloadChunk};
  |                                ^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `std::time::Duration`
 --> packages/http3/src/connect/builder/tls.rs:5:5
  |
5 | use std::time::Duration;
  |     ^^^^^^^^^^^^^^^^^^^

warning: unused import: `http::Uri`
 --> packages/http3/src/connect/builder/types.rs:7:5
  |
7 | use http::Uri;
  |     ^^^^^^^^^

warning: unused import: `crate::error::BoxError`
  --> packages/http3/src/connect/builder/types.rs:14:5
   |
14 | use crate::error::BoxError;
   |     ^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `fluent_ai_async::prelude::MessageChunk`
 --> packages/http3/src/connect/proxy/intercepted.rs:6:5
  |
6 | use fluent_ai_async::prelude::MessageChunk;
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused imports: `AsyncStream`, `emit`, `handle_error`, and `spawn_task`
 --> packages/http3/src/connect/proxy/intercepted.rs:7:23
  |
7 | use fluent_ai_async::{AsyncStream, emit, handle_error, spawn_task};
  |                       ^^^^^^^^^^^  ^^^^  ^^^^^^^^^^^^  ^^^^^^^^^^

warning: unused import: `http::Uri`
 --> packages/http3/src/connect/service/core.rs:8:5
  |
8 | use http::Uri;
  |     ^^^^^^^^^

warning: unused import: `SocketAddr`
 --> packages/http3/src/connect/service/direct.rs:6:27
  |
6 | use std::net::{TcpStream, SocketAddr};
  |                           ^^^^^^^^^^

warning: unused import: `crate::prelude::*`
 --> packages/http3/src/http/conversions.rs:7:5
  |
7 | use crate::prelude::*;
  |     ^^^^^^^^^^^^^^^^^

warning: unused import: `crate::prelude::*`
 --> packages/http3/src/http/into_url.rs:3:5
  |
3 | use crate::prelude::*;
  |     ^^^^^^^^^^^^^^^^^

warning: unused import: `crate::protocols::quiche::QuicheConnectionChunk`
  --> packages/http3/src/http/request.rs:16:5
   |
16 | use crate::protocols::quiche::QuicheConnectionChunk;
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `crate::jsonpath::parser::FilterExpression`
 --> packages/http3/src/jsonpath/functions/function_evaluator/integration_tests/complex_data.rs:5:5
  |
5 | use crate::jsonpath::parser::FilterExpression;
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `super::mock_evaluator::mock_evaluator`
 --> packages/http3/src/jsonpath/functions/function_evaluator/integration_tests/edge_cases.rs:5:5
  |
5 | use super::mock_evaluator::mock_evaluator;
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused imports: `FilterExpression` and `FilterValue`
 --> packages/http3/src/jsonpath/functions/function_evaluator/integration_tests/edge_cases.rs:6:31
  |
6 | use crate::jsonpath::parser::{FilterExpression, FilterValue};
  |                               ^^^^^^^^^^^^^^^^  ^^^^^^^^^^^

warning: unused import: `serde_json::json`
 --> packages/http3/src/jsonpath/functions/function_evaluator/integration_tests/error_handling.rs:5:5
  |
5 | use serde_json::json;
  |     ^^^^^^^^^^^^^^^^

warning: unused import: `super::super::FunctionEvaluator`
 --> packages/http3/src/jsonpath/functions/function_evaluator/integration_tests/error_handling.rs:7:5
  |
7 | use super::super::FunctionEvaluator;
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `super::mock_evaluator::mock_evaluator`
 --> packages/http3/src/jsonpath/functions/function_evaluator/integration_tests/error_handling.rs:8:5
  |
8 | use super::mock_evaluator::mock_evaluator;
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `serde_json::json`
 --> packages/http3/src/jsonpath/functions/function_evaluator/integration_tests/function_dispatch.rs:5:5
  |
5 | use serde_json::json;
  |     ^^^^^^^^^^^^^^^^

warning: unused import: `super::super::FunctionEvaluator`
 --> packages/http3/src/jsonpath/functions/function_evaluator/integration_tests/function_dispatch.rs:7:5
  |
7 | use super::super::FunctionEvaluator;
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `super::mock_evaluator::mock_evaluator`
 --> packages/http3/src/jsonpath/functions/function_evaluator/integration_tests/function_dispatch.rs:8:5
  |
8 | use super::mock_evaluator::mock_evaluator;
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused imports: `FilterExpression` and `FilterValue`
 --> packages/http3/src/jsonpath/functions/function_evaluator/integration_tests/function_dispatch.rs:9:31
  |
9 | use crate::jsonpath::parser::{FilterExpression, FilterValue};
  |                               ^^^^^^^^^^^^^^^^  ^^^^^^^^^^^

warning: unused import: `serde_json::json`
 --> packages/http3/src/jsonpath/functions/function_evaluator/integration_tests/performance.rs:5:5
  |
5 | use serde_json::json;
  |     ^^^^^^^^^^^^^^^^

warning: unused import: `super::super::FunctionEvaluator`
 --> packages/http3/src/jsonpath/functions/function_evaluator/integration_tests/performance.rs:7:5
  |
7 | use super::super::FunctionEvaluator;
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `super::mock_evaluator::mock_evaluator`
 --> packages/http3/src/jsonpath/functions/function_evaluator/integration_tests/performance.rs:8:5
  |
8 | use super::mock_evaluator::mock_evaluator;
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused imports: `FilterExpression` and `FilterValue`
 --> packages/http3/src/jsonpath/functions/function_evaluator/integration_tests/performance.rs:9:31
  |
9 | use crate::jsonpath::parser::{FilterExpression, FilterValue};
  |                               ^^^^^^^^^^^^^^^^  ^^^^^^^^^^^

warning: unused import: `serde_json::json`
 --> packages/http3/src/jsonpath/functions/function_evaluator/integration_tests/unicode_special.rs:5:5
  |
5 | use serde_json::json;
  |     ^^^^^^^^^^^^^^^^

warning: unused import: `super::super::FunctionEvaluator`
 --> packages/http3/src/jsonpath/functions/function_evaluator/integration_tests/unicode_special.rs:7:5
  |
7 | use super::super::FunctionEvaluator;
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `super::mock_evaluator::mock_evaluator`
 --> packages/http3/src/jsonpath/functions/function_evaluator/integration_tests/unicode_special.rs:8:5
  |
8 | use super::mock_evaluator::mock_evaluator;
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused imports: `FilterExpression` and `FilterValue`
 --> packages/http3/src/jsonpath/functions/function_evaluator/integration_tests/unicode_special.rs:9:31
  |
9 | use crate::jsonpath::parser::{FilterExpression, FilterValue};
  |                               ^^^^^^^^^^^^^^^^  ^^^^^^^^^^^

warning: unused import: `serde_json::json`
 --> packages/http3/src/jsonpath/functions/function_evaluator/integration_tests/value_conversion.rs:5:5
  |
5 | use serde_json::json;
  |     ^^^^^^^^^^^^^^^^

warning: unused import: `super::super::FunctionEvaluator`
 --> packages/http3/src/jsonpath/functions/function_evaluator/integration_tests/value_conversion.rs:7:5
  |
7 | use super::super::FunctionEvaluator;
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `crate::jsonpath::parser::FilterValue`
 --> packages/http3/src/jsonpath/functions/function_evaluator/integration_tests/value_conversion.rs:8:5
  |
8 | use crate::jsonpath::parser::FilterValue;
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `crate::protocols::quiche::QuicheConnectionChunk`
  --> packages/http3/src/jsonpath/stream_processor/core.rs:10:5
   |
10 | use crate::protocols::quiche::QuicheConnectionChunk;
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused imports: `emit` and `handle_error`
 --> packages/http3/src/jsonpath/stream_processor/processing.rs:3:42
  |
3 | use fluent_ai_async::{AsyncStreamSender, emit, handle_error};
  |                                          ^^^^  ^^^^^^^^^^^^

warning: unused import: `H2Stream`
  --> packages/http3/src/protocols/connection.rs:10:31
   |
10 | use super::h2::{H2Connection, H2Stream};
   |                               ^^^^^^^^

warning: unused import: `H3Stream`
  --> packages/http3/src/protocols/connection.rs:11:31
   |
11 | use super::h3::{H3Connection, H3Stream};
   |                               ^^^^^^^^

warning: unused imports: `H2Frame` and `H3Frame`
  --> packages/http3/src/protocols/connection.rs:12:44
   |
12 | use crate::protocols::frames::{FrameChunk, H2Frame, H3Frame};
   |                                            ^^^^^^^  ^^^^^^^

warning: unused import: `Instant`
 --> packages/http3/src/protocols/core.rs:6:27
  |
6 | use std::time::{Duration, Instant};
  |                           ^^^^^^^

warning: unused import: `bytes::Bytes`
 --> packages/http3/src/protocols/core.rs:8:5
  |
8 | use bytes::Bytes;
  |     ^^^^^^^^^^^^

warning: unused imports: `AsyncStream` and `prelude::MessageChunk`
 --> packages/http3/src/protocols/core.rs:9:23
  |
9 | use fluent_ai_async::{AsyncStream, prelude::MessageChunk};
  |                       ^^^^^^^^^^^  ^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `Ordering`
 --> packages/http3/src/protocols/frames.rs:3:36
  |
3 | use std::sync::atomic::{AtomicU64, Ordering};
  |                                    ^^^^^^^^

warning: unused import: `fluent_ai_async::prelude::*`
 --> packages/http3/src/protocols/h2/chunks.rs:4:5
  |
4 | use fluent_ai_async::prelude::*;
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `AtomicBool`
 --> packages/http3/src/protocols/h2/connection.rs:6:25
  |
6 | use std::sync::atomic::{AtomicBool, AtomicU64, Ordering};
  |                         ^^^^^^^^^^

warning: unused import: `Duration`
 --> packages/http3/src/protocols/h2/connection.rs:8:17
  |
8 | use std::time::{Duration, Instant};
  |                 ^^^^^^^^

warning: unused imports: `RecvStream` and `client`
  --> packages/http3/src/protocols/h2/connection.rs:13:10
   |
13 | use h2::{RecvStream, client};
   |          ^^^^^^^^^^  ^^^^^^

warning: unused import: `Response`
  --> packages/http3/src/protocols/h2/connection.rs:14:21
   |
14 | use http::{Request, Response};
   |                     ^^^^^^^^

warning: unused import: `crate::protocols::quiche::QuicheConnectionChunk`
  --> packages/http3/src/protocols/h2/connection.rs:22:5
   |
22 | use crate::protocols::quiche::QuicheConnectionChunk;
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused imports: `client` and `server`
  --> packages/http3/src/protocols/h2/streaming.rs:11:10
   |
11 | use h2::{client, server};
   |          ^^^^^^  ^^^^^^

warning: unused import: `H2RequestChunk`
  --> packages/http3/src/protocols/h2/streaming.rs:13:53
   |
13 | use super::chunks::{H2ConnectionChunk, H2DataChunk, H2RequestChunk, H2SendResult};
   |                                                     ^^^^^^^^^^^^^^

warning: unused imports: `HttpVersion` and `TimeoutConfig`
  --> packages/http3/src/protocols/h2/streaming.rs:14:30
   |
14 | use crate::protocols::core::{HttpVersion, TimeoutConfig};
   |                              ^^^^^^^^^^^  ^^^^^^^^^^^^^

warning: unused import: `bytes::Bytes`
  --> packages/http3/src/protocols/h3/connection.rs:10:5
   |
10 | use bytes::Bytes;
   |     ^^^^^^^^^^^^

warning: unused import: `crate::protocols::quiche::QuicheConnectionChunk`
  --> packages/http3/src/protocols/h3/connection.rs:13:5
   |
13 | use crate::protocols::quiche::QuicheConnectionChunk;
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `Instant`
  --> packages/http3/src/protocols/intelligence.rs:10:27
   |
10 | use std::time::{Duration, Instant, SystemTime, UNIX_EPOCH};
   |                           ^^^^^^^

warning: unused import: `std::collections::HashMap`
 --> packages/http3/src/protocols/quiche/h3_adapter.rs:1:5
  |
1 | use std::collections::HashMap;
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `HeaderName`
 --> packages/http3/src/protocols/quiche/h3_adapter.rs:6:23
  |
6 | use http::{HeaderMap, HeaderName, HeaderValue, Method, StatusCode};
  |                       ^^^^^^^^^^

warning: unused import: `std::sync::Arc`
 --> packages/http3/src/protocols/quiche/streaming.rs:7:5
  |
7 | use std::sync::Arc;
  |     ^^^^^^^^^^^^^^

warning: unused import: `Connection as QuicheConnection`
  --> packages/http3/src/protocols/transport.rs:10:22
   |
10 | use quiche::{Config, Connection as QuicheConnection};
   |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused imports: `H2Connection` and `H2Stream`
  --> packages/http3/src/protocols/transport.rs:13:17
   |
13 | use super::h2::{H2Connection, H2Stream};
   |                 ^^^^^^^^^^^^  ^^^^^^^^

warning: unused imports: `H3Connection` and `H3Stream`
  --> packages/http3/src/protocols/transport.rs:14:17
   |
14 | use super::h3::{H3Connection, H3Stream};
   |                 ^^^^^^^^^^^^  ^^^^^^^^

warning: unused imports: `H2Frame` and `H3Frame`
  --> packages/http3/src/protocols/transport.rs:15:44
   |
15 | use crate::protocols::frames::{FrameChunk, H2Frame, H3Frame};
   |                                            ^^^^^^^  ^^^^^^^

warning: unused imports: `HttpRequest` and `HttpResponse`
  --> packages/http3/src/proxy/core/constructors.rs:12:13
   |
12 | use crate::{HttpRequest, HttpResponse};
   |             ^^^^^^^^^^^  ^^^^^^^^^^^^

warning: unused import: `Intercept`
 --> packages/http3/src/proxy/core/matcher_integration.rs:8:20
  |
8 | use super::types::{Intercept, Proxy};
  |                    ^^^^^^^^^

warning: unused import: `std::sync::Arc`
 --> packages/http3/src/proxy/core/types.rs:6:5
  |
6 | use std::sync::Arc;
  |     ^^^^^^^^^^^^^^

warning: unused import: `fluent_ai_async::prelude::*`
 --> packages/http3/src/proxy/matcher/implementation.rs:6:5
  |
6 | use fluent_ai_async::prelude::*;
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused imports: `HeaderMap` and `header::HeaderValue`
 --> packages/http3/src/proxy/matcher/public_interface.rs:8:12
  |
8 | use http::{HeaderMap, Uri, header::HeaderValue};
  |            ^^^^^^^^^       ^^^^^^^^^^^^^^^^^^^

warning: unused import: `NoProxy`
  --> packages/http3/src/proxy/matcher/public_interface.rs:10:33
   |
10 | use super::super::core::{Extra, NoProxy};
   |                                 ^^^^^^^

warning: unused import: `super::super::url_handling::Custom`
  --> packages/http3/src/proxy/matcher/public_interface.rs:11:5
   |
11 | use super::super::url_handling::Custom;
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused imports: `Intercept` and `Via`
  --> packages/http3/src/proxy/matcher/public_interface.rs:13:24
   |
13 | use super::intercept::{Intercept, Via};
   |                        ^^^^^^^^^  ^^^

warning: unused imports: `Intercept` and `Via`
  --> packages/http3/src/proxy/matcher/system_integration.rs:11:24
   |
11 | use super::intercept::{Intercept, Via};
   |                        ^^^^^^^^^  ^^^

warning: unused import: `std::fmt`
 --> packages/http3/src/proxy/matcher/types.rs:6:5
  |
6 | use std::fmt;
  |     ^^^^^^^^

warning: unused imports: `HeaderMap`, `Uri`, and `header::HeaderValue`
 --> packages/http3/src/proxy/matcher/types.rs:8:12
  |
8 | use http::{HeaderMap, Uri, header::HeaderValue};
  |            ^^^^^^^^^  ^^^  ^^^^^^^^^^^^^^^^^^^

warning: unused import: `NoProxy`
  --> packages/http3/src/proxy/matcher/types.rs:10:33
   |
10 | use super::super::core::{Extra, NoProxy};
   |                                 ^^^^^^^

warning: unused import: `public_interface::*`
  --> packages/http3/src/proxy/matcher/mod.rs:18:9
   |
18 | pub use public_interface::*;
   |         ^^^^^^^^^^^^^^^^^^^

warning: unused import: `types::Intercepted`
  --> packages/http3/src/proxy/matcher/mod.rs:20:16
   |
20 | pub(crate) use types::Intercepted;
   |                ^^^^^^^^^^^^^^^^^^

warning: unused import: `std::fmt`
 --> packages/http3/src/proxy/url_handling.rs:5:5
  |
5 | use std::fmt;
  |     ^^^^^^^^

warning: unused import: `stream::*`
  --> packages/http3/src/telemetry/jsonpath/mod.rs:10:9
   |
10 | pub use stream::*;
   |         ^^^^^^^^^

warning: unused import: `Instant`
 --> packages/http3/src/telemetry/types.rs:3:27
  |
3 | use std::time::{Duration, Instant};
  |                           ^^^^^^^

warning: unused import: `ParsedCertificate`
  --> packages/http3/src/tls/certificate/generation.rs:17:43
   |
17 | use crate::tls::types::{CertificateUsage, ParsedCertificate};
   |                                           ^^^^^^^^^^^^^^^^^

warning: unused import: `std::collections::HashMap`
 --> packages/http3/src/tls/certificate/parsing.rs:3:5
  |
3 | use std::collections::HashMap;
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused imports: `Certificate as X509CertCert` and `der::Decode`
 --> packages/http3/src/tls/certificate/parsing.rs:6:17
  |
6 | use x509_cert::{der::Decode, Certificate as X509CertCert};
  |                 ^^^^^^^^^^^  ^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `parser::parse_certificate_from_pem_internal`
  --> packages/http3/src/tls/certificate/mod.rs:18:9
   |
18 | pub use parser::parse_certificate_from_pem_internal;
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `verify_peer_certificate_comprehensive`
  --> packages/http3/src/tls/certificate/mod.rs:23:50
   |
23 | pub use validation::{validate_certificate_chain, verify_peer_certificate_comprehensive};
   |                                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `wildcard::generate_wildcard_certificate`
  --> packages/http3/src/tls/certificate/mod.rs:24:9
   |
24 | pub use wildcard::generate_wildcard_certificate;
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `RngCore`
  --> packages/http3/src/tls/ocsp.rs:10:17
   |
10 | use rand::{Rng, RngCore};
   |                 ^^^^^^^

warning: unused import: `super::certificate::parse_certificate_from_pem`
  --> packages/http3/src/tls/tls_manager.rs:17:5
   |
17 | use super::certificate::parse_certificate_from_pem;
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `Tls`
  --> packages/http3/src/tls/tls_manager.rs:18:44
   |
18 | use super::builder::{CertificateAuthority, Tls};
   |                                            ^^^

warning: unused import: `Zeroize`
 --> packages/http3/src/tls/types.rs:6:15
  |
6 | use zeroize::{Zeroize, ZeroizeOnDrop};
  |               ^^^^^^^

warning: unused import: `std::collections::HashMap`
 --> packages/http3/src/tls/builder/authority.rs:3:5
  |
3 | use std::collections::HashMap;
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `std::io::Read`
 --> packages/http3/src/tls/builder/certificate.rs:3:5
  |
3 | use std::io::Read;
  |     ^^^^^^^^^^^^^

warning: unused import: `std::time::Duration`
 --> packages/http3/src/tls/builder/certificate.rs:5:5
  |
5 | use std::time::Duration;
  |     ^^^^^^^^^^^^^^^^^^^

warning: unused import: `verify_peer_certificate`
   --> packages/http3/src/tls/builder/certificate.rs:113:33
    |
113 |             validate_key_usage, verify_peer_certificate,
    |                                 ^^^^^^^^^^^^^^^^^^^^^^^

error[E0119]: conflicting implementations of trait `std::default::Default` for type `client::core::HttpClient`
   --> packages/http3/src/client/core.rs:51:1
    |
 51 | impl Default for HttpClient {
    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^ conflicting implementation for `client::core::HttpClient`
    |
   ::: packages/http3/src/client/configuration.rs:102:1
    |
102 | impl Default for HttpClient {
    | --------------------------- first implementation here

error[E0277]: `EnterpriseServerCertVerifier` doesn't implement `std::fmt::Debug`
   --> packages/http3/src/tls/tls_manager.rs:326:53
    |
326 | impl rustls::client::danger::ServerCertVerifier for EnterpriseServerCertVerifier {
    |                                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `std::fmt::Debug` is not implemented for `EnterpriseServerCertVerifier`
    |
    = note: add `#[derive(Debug)]` to `EnterpriseServerCertVerifier` or manually `impl std::fmt::Debug for EnterpriseServerCertVerifier`
note: required by a bound in `ServerCertVerifier`
   --> /Users/davidmaple/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/rustls-0.23.31/src/verify.rs:69:31
    |
 69 | pub trait ServerCertVerifier: Debug + Send + Sync {
    |                               ^^^^^ required by this bound in `ServerCertVerifier`

error[E0225]: only auto traits can be used as additional traits in a trait object
   --> packages/http3/src/tls/tls_manager.rs:150:37
    |
150 |     ) -> AsyncStream<Box<dyn Read + Write + Unpin + Send + 'static>, 1024> {
    |                              ----   ^^^^^ additional non-auto trait
    |                              |
    |                              first non-auto trait
    |
    = help: consider creating a new trait with all of these as supertraits and using that trait here instead: `trait NewTrait: std::io::Read + std::io::Write {}`
    = note: auto-traits like `Send` and `Sync` are traits that have special properties; for more information on them, visit <https://doc.rust-lang.org/reference/special-types-and-traits.html#auto-traits>

error[E0277]: `std::result::Result<(), std::io::Error>` is not a future
  --> packages/http3/src/tls/certificate/generation.rs:30:35
   |
30 |     fs::create_dir_all(&cert_dir).await?;
   |     ----------------------------- ^^^^^ `std::result::Result<(), std::io::Error>` is not a future
   |     |
   |     this call returns `std::result::Result<(), std::io::Error>`
   |
   = help: the trait `futures_util::Future` is not implemented for `std::result::Result<(), std::io::Error>`
   = note: std::result::Result<(), std::io::Error> must be a future or must implement `IntoFuture` to be awaited
   = note: required for `std::result::Result<(), std::io::Error>` to implement `std::future::IntoFuture`
help: remove the `.await`
   |
30 -     fs::create_dir_all(&cert_dir).await?;
30 +     fs::create_dir_all(&cert_dir)?;
   |

error[E0277]: `std::result::Result<(), std::io::Error>` is not a future
  --> packages/http3/src/tls/certificate/generation.rs:83:51
   |
83 |     fs::write(cert_dir.join("ca.crt"), &cert_pem).await?;
   |     --------------------------------------------- ^^^^^ `std::result::Result<(), std::io::Error>` is not a future
   |     |
   |     this call returns `std::result::Result<(), std::io::Error>`
   |
   = help: the trait `futures_util::Future` is not implemented for `std::result::Result<(), std::io::Error>`
   = note: std::result::Result<(), std::io::Error> must be a future or must implement `IntoFuture` to be awaited
   = note: required for `std::result::Result<(), std::io::Error>` to implement `std::future::IntoFuture`
help: remove the `.await`
   |
83 -     fs::write(cert_dir.join("ca.crt"), &cert_pem).await?;
83 +     fs::write(cert_dir.join("ca.crt"), &cert_pem)?;
   |

error[E0277]: `std::result::Result<(), std::io::Error>` is not a future
  --> packages/http3/src/tls/certificate/generation.rs:87:56
   |
87 |     fs::write(cert_dir.join("ca.key"), &encrypted_key).await?;
   |     -------------------------------------------------- ^^^^^ `std::result::Result<(), std::io::Error>` is not a future
   |     |
   |     this call returns `std::result::Result<(), std::io::Error>`
   |
   = help: the trait `futures_util::Future` is not implemented for `std::result::Result<(), std::io::Error>`
   = note: std::result::Result<(), std::io::Error> must be a future or must implement `IntoFuture` to be awaited
   = note: required for `std::result::Result<(), std::io::Error>` to implement `std::future::IntoFuture`
help: remove the `.await`
   |
87 -     fs::write(cert_dir.join("ca.key"), &encrypted_key).await?;
87 +     fs::write(cert_dir.join("ca.key"), &encrypted_key)?;
   |

error[E0277]: `std::result::Result<std::fs::Metadata, std::io::Error>` is not a future
  --> packages/http3/src/tls/certificate/generation.rs:93:63
   |
93 |         let mut perms = fs::metadata(cert_dir.join("ca.key")).await?.permissions();
   |                         ------------------------------------- ^^^^^ `std::result::Result<std::fs::Metadata, std::io::Error>` is not a future
   |                         |
   |                         this call returns `std::result::Result<std::fs::Metadata, std::io::Error>`
   |
   = help: the trait `futures_util::Future` is not implemented for `std::result::Result<std::fs::Metadata, std::io::Error>`
   = note: std::result::Result<std::fs::Metadata, std::io::Error> must be a future or must implement `IntoFuture` to be awaited
   = note: required for `std::result::Result<std::fs::Metadata, std::io::Error>` to implement `std::future::IntoFuture`
help: remove the `.await`
   |
93 -         let mut perms = fs::metadata(cert_dir.join("ca.key")).await?.permissions();
93 +         let mut perms = fs::metadata(cert_dir.join("ca.key"))?.permissions();
   |

error[E0277]: `std::result::Result<(), std::io::Error>` is not a future
  --> packages/http3/src/tls/certificate/generation.rs:95:61
   |
95 |         fs::set_permissions(cert_dir.join("ca.key"), perms).await?;
   |         --------------------------------------------------- ^^^^^ `std::result::Result<(), std::io::Error>` is not a future
   |         |
   |         this call returns `std::result::Result<(), std::io::Error>`
   |
   = help: the trait `futures_util::Future` is not implemented for `std::result::Result<(), std::io::Error>`
   = note: std::result::Result<(), std::io::Error> must be a future or must implement `IntoFuture` to be awaited
   = note: required for `std::result::Result<(), std::io::Error>` to implement `std::future::IntoFuture`
help: remove the `.await`
   |
95 -         fs::set_permissions(cert_dir.join("ca.key"), perms).await?;
95 +         fs::set_permissions(cert_dir.join("ca.key"), perms)?;
   |

error[E0433]: failed to resolve: use of undeclared type `Issuer`
   --> packages/http3/src/tls/certificate/generation.rs:102:18
    |
102 |     let issuer = Issuer::<'static>::new(params, key_pair);
    |                  ^^^^^^ use of undeclared type `Issuer`

error[E0277]: `std::result::Result<std::string::String, std::io::Error>` is not a future
   --> packages/http3/src/tls/certificate/generation.rs:119:64
    |
119 |     let cert_pem = fs::read_to_string(cert_dir.join("ca.crt")).await?;
    |                    ------------------------------------------- ^^^^^ `std::result::Result<std::string::String, std::io::Error>` is not a future
    |                    |
    |                    this call returns `std::result::Result<std::string::String, std::io::Error>`
    |
    = help: the trait `futures_util::Future` is not implemented for `std::result::Result<std::string::String, std::io::Error>`
    = note: std::result::Result<std::string::String, std::io::Error> must be a future or must implement `IntoFuture` to be awaited
    = note: required for `std::result::Result<std::string::String, std::io::Error>` to implement `std::future::IntoFuture`
help: remove the `.await`
    |
119 -     let cert_pem = fs::read_to_string(cert_dir.join("ca.crt")).await?;
119 +     let cert_pem = fs::read_to_string(cert_dir.join("ca.crt"))?;
    |

error[E0277]: `std::result::Result<Vec<u8>, std::io::Error>` is not a future
   --> packages/http3/src/tls/certificate/generation.rs:122:64
    |
122 |     let encrypted_key_data = fs::read(cert_dir.join("ca.key")).await?;
    |                              --------------------------------- ^^^^^ `std::result::Result<Vec<u8>, std::io::Error>` is not a future
    |                              |
    |                              this call returns `std::result::Result<Vec<u8>, std::io::Error>`
    |
    = help: the trait `futures_util::Future` is not implemented for `std::result::Result<Vec<u8>, std::io::Error>`
    = note: std::result::Result<Vec<u8>, std::io::Error> must be a future or must implement `IntoFuture` to be awaited
    = note: required for `std::result::Result<Vec<u8>, std::io::Error>` to implement `std::future::IntoFuture`
help: remove the `.await`
    |
122 -     let encrypted_key_data = fs::read(cert_dir.join("ca.key")).await?;
122 +     let encrypted_key_data = fs::read(cert_dir.join("ca.key"))?;
    |

error[E0277]: the size for values of type `[u8]` cannot be known at compilation time
   --> packages/http3/src/tls/certificate/generation.rs:122:9
    |
122 |     let encrypted_key_data = fs::read(cert_dir.join("ca.key")).await?;
    |         ^^^^^^^^^^^^^^^^^^ doesn't have a size known at compile-time
    |
    = help: the trait `Sized` is not implemented for `[u8]`
    = note: all local variables must have a statically known size

error[E0277]: the size for values of type `[u8]` cannot be known at compilation time
   --> packages/http3/src/tls/certificate/generation.rs:122:30
    |
122 |     let encrypted_key_data = fs::read(cert_dir.join("ca.key")).await?;
    |                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ doesn't have a size known at compile-time
    |
    = help: the trait `Sized` is not implemented for `[u8]`
    = note: all local variables must have a statically known size

error[E0277]: the size for values of type `[u8]` cannot be known at compilation time
   --> packages/http3/src/tls/certificate/generation.rs:122:69
    |
122 |     let encrypted_key_data = fs::read(cert_dir.join("ca.key")).await?;
    |                                                                     ^ doesn't have a size known at compile-time
    |
    = help: the trait `Sized` is not implemented for `[u8]`
note: required by a bound in `Break`
   --> /Users/davidmaple/.rustup/toolchains/nightly-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/ops/control_flow.rs:87:25
    |
 87 | pub enum ControlFlow<B, C = ()> {
    |                         ^^^^^^ required by this bound in `Break`
...
 95 |     Break(B),
    |     ----- required by a bound in this variant

error[E0277]: the size for values of type `[u8]` cannot be known at compilation time
   --> packages/http3/src/tls/certificate/generation.rs:122:30
    |
122 |     let encrypted_key_data = fs::read(cert_dir.join("ca.key")).await?;
    |                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ doesn't have a size known at compile-time
    |
    = help: the trait `Sized` is not implemented for `[u8]`
note: required by a bound in `Continue`
   --> /Users/davidmaple/.rustup/toolchains/nightly-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/ops/control_flow.rs:87:25
    |
 87 | pub enum ControlFlow<B, C = ()> {
    |                         ^^^^^^ required by this bound in `Continue`
...
 91 |     Continue(C),
    |     -------- required by a bound in this variant

error[E0433]: failed to resolve: use of undeclared type `Issuer`
   --> packages/http3/src/tls/certificate/generation.rs:192:18
    |
192 |     let issuer = Issuer::<'static>::new(params, ca_key_pair);
    |                  ^^^^^^ use of undeclared type `Issuer`

error[E0061]: this method takes 3 arguments but 2 arguments were supplied
   --> packages/http3/src/tls/certificate/generation.rs:230:23
    |
230 |     let cert = params.signed_by(&key_pair, ca_issuer)?;
    |                       ^^^^^^^^^---------------------- argument #3 of type `&rcgen::KeyPair` is missing
    |
note: method defined here
   --> /Users/davidmaple/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/rcgen-0.13.2/src/certificate.rs:150:9
    |
150 |     pub fn signed_by(
    |            ^^^^^^^^^
help: provide the argument
    |
230 |     let cert = params.signed_by(&key_pair, ca_issuer, /* &rcgen::KeyPair */)?;
    |                                                     +++++++++++++++++++++++

error[E0277]: `std::result::Result<(), std::io::Error>` is not a future
   --> packages/http3/src/tls/certificate/generation.rs:235:55
    |
235 |     fs::write(cert_dir.join("server.crt"), &cert_pem).await?;
    |     ------------------------------------------------- ^^^^^ `std::result::Result<(), std::io::Error>` is not a future
    |     |
    |     this call returns `std::result::Result<(), std::io::Error>`
    |
    = help: the trait `futures_util::Future` is not implemented for `std::result::Result<(), std::io::Error>`
    = note: std::result::Result<(), std::io::Error> must be a future or must implement `IntoFuture` to be awaited
    = note: required for `std::result::Result<(), std::io::Error>` to implement `std::future::IntoFuture`
help: remove the `.await`
    |
235 -     fs::write(cert_dir.join("server.crt"), &cert_pem).await?;
235 +     fs::write(cert_dir.join("server.crt"), &cert_pem)?;
    |

error[E0277]: `std::result::Result<(), std::io::Error>` is not a future
   --> packages/http3/src/tls/certificate/generation.rs:239:60
    |
239 |     fs::write(cert_dir.join("server.key"), &encrypted_key).await?;
    |     ------------------------------------------------------ ^^^^^ `std::result::Result<(), std::io::Error>` is not a future
    |     |
    |     this call returns `std::result::Result<(), std::io::Error>`
    |
    = help: the trait `futures_util::Future` is not implemented for `std::result::Result<(), std::io::Error>`
    = note: std::result::Result<(), std::io::Error> must be a future or must implement `IntoFuture` to be awaited
    = note: required for `std::result::Result<(), std::io::Error>` to implement `std::future::IntoFuture`
help: remove the `.await`
    |
239 -     fs::write(cert_dir.join("server.key"), &encrypted_key).await?;
239 +     fs::write(cert_dir.join("server.key"), &encrypted_key)?;
    |

error[E0277]: `std::result::Result<std::fs::Metadata, std::io::Error>` is not a future
   --> packages/http3/src/tls/certificate/generation.rs:246:14
    |
245 |         let mut perms = fs::metadata(cert_dir.join("server.key"))
    |                         ----------------------------------------- this call returns `std::result::Result<std::fs::Metadata, std::io::Error>`
246 |             .await?
    |              ^^^^^ `std::result::Result<std::fs::Metadata, std::io::Error>` is not a future
    |
    = help: the trait `futures_util::Future` is not implemented for `std::result::Result<std::fs::Metadata, std::io::Error>`
    = note: std::result::Result<std::fs::Metadata, std::io::Error> must be a future or must implement `IntoFuture` to be awaited
    = note: required for `std::result::Result<std::fs::Metadata, std::io::Error>` to implement `std::future::IntoFuture`
help: remove the `.await`
    |
246 -             .await?
246 +             ?
    |

error[E0277]: `std::result::Result<(), std::io::Error>` is not a future
   --> packages/http3/src/tls/certificate/generation.rs:249:65
    |
249 |         fs::set_permissions(cert_dir.join("server.key"), perms).await?;
    |         ------------------------------------------------------- ^^^^^ `std::result::Result<(), std::io::Error>` is not a future
    |         |
    |         this call returns `std::result::Result<(), std::io::Error>`
    |
    = help: the trait `futures_util::Future` is not implemented for `std::result::Result<(), std::io::Error>`
    = note: std::result::Result<(), std::io::Error> must be a future or must implement `IntoFuture` to be awaited
    = note: required for `std::result::Result<(), std::io::Error>` to implement `std::future::IntoFuture`
help: remove the `.await`
    |
249 -         fs::set_permissions(cert_dir.join("server.key"), perms).await?;
249 +         fs::set_permissions(cert_dir.join("server.key"), perms)?;
    |

error[E0277]: `std::result::Result<(), std::io::Error>` is not a future
  --> packages/http3/src/tls/certificate/wildcard.rs:19:35
   |
19 |     fs::create_dir_all(&cert_dir).await.map_err(|e| {
   |     ----------------------------- ^^^^^ `std::result::Result<(), std::io::Error>` is not a future
   |     |
   |     this call returns `std::result::Result<(), std::io::Error>`
   |
   = help: the trait `futures_util::Future` is not implemented for `std::result::Result<(), std::io::Error>`
   = note: std::result::Result<(), std::io::Error> must be a future or must implement `IntoFuture` to be awaited
   = note: required for `std::result::Result<(), std::io::Error>` to implement `std::future::IntoFuture`
help: remove the `.await`
   |
19 -     fs::create_dir_all(&cert_dir).await.map_err(|e| {
19 +     fs::create_dir_all(&cert_dir).map_err(|e| {
   |

error[E0277]: `std::result::Result<(), std::io::Error>` is not a future
  --> packages/http3/src/tls/certificate/wildcard.rs:96:10
   |
95 |     fs::write(&wildcard_cert_path, &combined_pem)
   |     --------------------------------------------- this call returns `std::result::Result<(), std::io::Error>`
96 |         .await
   |          ^^^^^ `std::result::Result<(), std::io::Error>` is not a future
   |
   = help: the trait `futures_util::Future` is not implemented for `std::result::Result<(), std::io::Error>`
   = note: std::result::Result<(), std::io::Error> must be a future or must implement `IntoFuture` to be awaited
   = note: required for `std::result::Result<(), std::io::Error>` to implement `std::future::IntoFuture`
help: remove the `.await`
   |
96 -         .await
   |

error[E0277]: `std::result::Result<std::fs::Metadata, std::io::Error>` is not a future
   --> packages/http3/src/tls/certificate/wildcard.rs:106:14
    |
105 |         let mut perms = fs::metadata(&wildcard_cert_path)
    |                         --------------------------------- this call returns `std::result::Result<std::fs::Metadata, std::io::Error>`
106 |             .await
    |              ^^^^^ `std::result::Result<std::fs::Metadata, std::io::Error>` is not a future
    |
    = help: the trait `futures_util::Future` is not implemented for `std::result::Result<std::fs::Metadata, std::io::Error>`
    = note: std::result::Result<std::fs::Metadata, std::io::Error> must be a future or must implement `IntoFuture` to be awaited
    = note: required for `std::result::Result<std::fs::Metadata, std::io::Error>` to implement `std::future::IntoFuture`
help: remove the `.await`
    |
106 -             .await
    |

error[E0277]: `std::result::Result<(), std::io::Error>` is not a future
   --> packages/http3/src/tls/certificate/wildcard.rs:111:14
    |
110 |         fs::set_permissions(&wildcard_cert_path, perms)
    |         ----------------------------------------------- this call returns `std::result::Result<(), std::io::Error>`
111 |             .await
    |              ^^^^^ `std::result::Result<(), std::io::Error>` is not a future
    |
    = help: the trait `futures_util::Future` is not implemented for `std::result::Result<(), std::io::Error>`
    = note: std::result::Result<(), std::io::Error> must be a future or must implement `IntoFuture` to be awaited
    = note: required for `std::result::Result<(), std::io::Error>` to implement `std::future::IntoFuture`
help: remove the `.await`
    |
111 -             .await
    |

error[E0277]: `std::result::Result<std::string::String, std::io::Error>` is not a future
   --> packages/http3/src/tls/certificate/wildcard.rs:127:10
    |
126 |     let cert_content = fs::read_to_string(cert_path)
    |                        ----------------------------- this call returns `std::result::Result<std::string::String, std::io::Error>`
127 |         .await
    |          ^^^^^ `std::result::Result<std::string::String, std::io::Error>` is not a future
    |
    = help: the trait `futures_util::Future` is not implemented for `std::result::Result<std::string::String, std::io::Error>`
    = note: std::result::Result<std::string::String, std::io::Error> must be a future or must implement `IntoFuture` to be awaited
    = note: required for `std::result::Result<std::string::String, std::io::Error>` to implement `std::future::IntoFuture`
help: remove the `.await`
    |
127 -         .await
    |

error[E0599]: the method `next` exists for struct `fluent_ai_async::AsyncStream<OcspStatus>`, but its trait bounds were not satisfied
   --> packages/http3/src/tls/ocsp.rs:68:38
    |
 23 | pub enum OcspStatus {
    | ------------------- doesn't satisfy `OcspStatus: fluent_ai_async::prelude::MessageChunk` or `OcspStatus: std::default::Default`
...
 68 |         if let Some(status) = stream.next() {
    |                                      ^^^^ method cannot be called on `fluent_ai_async::AsyncStream<OcspStatus>` due to unsatisfied trait bounds
    |
    = note: the following trait bounds were not satisfied:
            `OcspStatus: fluent_ai_async::prelude::MessageChunk`
            `OcspStatus: std::default::Default`
note: the traits `fluent_ai_async::prelude::MessageChunk` and `std::default::Default` must be implemented
   --> /Users/davidmaple/.rustup/toolchains/nightly-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/default.rs:108:1
    |
108 | pub trait Default: Sized {
    | ^^^^^^^^^^^^^^^^^^^^^^^^
    |
   ::: /Users/davidmaple/.cargo/git/checkouts/cyrup-sugars-291ac2b5c478a1ed/150c82d/packages/builders/src/chunk_handler.rs:8:1
    |
  8 | pub trait MessageChunk: Sized {
    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0609]: no field `is_ca` on type `std::result::Result<CertificateParams, rcgen::Error>`
   --> packages/http3/src/tls/builder/authority.rs:187:16
    |
187 |         params.is_ca = rcgen::IsCa::Ca(rcgen::BasicConstraints::Unconstrained);
    |                ^^^^^ unknown field
    |
help: one of the expressions' fields has a field of the same name
    |
187 |         params.unwrap().is_ca = rcgen::IsCa::Ca(rcgen::BasicConstraints::Unconstrained);
    |                +++++++++

error[E0609]: no field `distinguished_name` on type `std::result::Result<CertificateParams, rcgen::Error>`
   --> packages/http3/src/tls/builder/authority.rs:192:16
    |
192 |         params.distinguished_name = distinguished_name;
    |                ^^^^^^^^^^^^^^^^^^ unknown field
    |
help: one of the expressions' fields has a field of the same name
    |
192 |         params.unwrap().distinguished_name = distinguished_name;
    |                +++++++++

error[E0609]: no field `not_before` on type `std::result::Result<CertificateParams, rcgen::Error>`
   --> packages/http3/src/tls/builder/authority.rs:196:16
    |
196 |         params.not_before = now.into();
    |                ^^^^^^^^^^ unknown field
    |
help: one of the expressions' fields has a field of the same name
    |
196 |         params.unwrap().not_before = now.into();
    |                +++++++++

error[E0609]: no field `not_after` on type `std::result::Result<CertificateParams, rcgen::Error>`
   --> packages/http3/src/tls/builder/authority.rs:197:16
    |
197 |         params.not_after = (now
    |                ^^^^^^^^^ unknown field
    |
help: one of the expressions' fields has a field of the same name
    |
197 |         params.unwrap().not_after = (now
    |                +++++++++

error[E0061]: this function takes 0 arguments but 1 argument was supplied
   --> packages/http3/src/tls/builder/authority.rs:202:24
    |
202 |         let key_pair = KeyPair::generate(&rcgen::PKCS_RSA_SHA256)
    |                        ^^^^^^^^^^^^^^^^^ ----------------------- unexpected argument of type `&rcgen::SignatureAlgorithm`
    |
note: associated function defined here
   --> /Users/davidmaple/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/rcgen-0.13.2/src/key_pair.rs:77:9
    |
 77 |     pub fn generate() -> Result<Self, Error> {
    |            ^^^^^^^^
help: remove the extra argument
    |
202 -         let key_pair = KeyPair::generate(&rcgen::PKCS_RSA_SHA256)
202 +         let key_pair = KeyPair::generate()
    |

error[E0609]: no field `key_pair` on type `std::result::Result<CertificateParams, rcgen::Error>`
   --> packages/http3/src/tls/builder/authority.rs:218:16
    |
218 |         params.key_pair = Some(key_pair);
    |                ^^^^^^^^ unknown field
    |
    = note: available fields are: `not_before`, `not_after`, `serial_number`, `subject_alt_names`, `distinguished_name` ... and 8 others

error[E0599]: no function or associated item named `from_params` found for struct `rcgen::Certificate` in the current scope
   --> packages/http3/src/tls/builder/authority.rs:220:46
    |
220 |         let cert = match rcgen::Certificate::from_params(params) {
    |                                              ^^^^^^^^^^^ function or associated item not found in `rcgen::Certificate`
    |
help: there is a method `params` with a similar name, but with different arguments
   --> /Users/davidmaple/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/rcgen-0.13.2/src/certificate.rs:33:2
    |
 33 |     pub fn params(&self) -> &CertificateParams {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0308]: mismatched types
   --> packages/http3/src/tls/builder/authority.rs:372:26
    |
372 |                 subject: parsed_cert.subject.clone(),
    |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `String`, found `HashMap<String, String>`
    |
    = note: expected struct `std::string::String`
               found struct `HashMap<std::string::String, std::string::String>`

error[E0308]: mismatched types
   --> packages/http3/src/tls/builder/authority.rs:373:25
    |
373 |                 issuer: parsed_cert.issuer.clone(),
    |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `String`, found `HashMap<String, String>`
    |
    = note: expected struct `std::string::String`
               found struct `HashMap<std::string::String, std::string::String>`

error[E0308]: mismatched types
   --> packages/http3/src/tls/builder/authority.rs:374:32
    |
374 |                 serial_number: parsed_cert.serial_number.clone(),
    |                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `String`, found `Vec<u8>`
    |
    = note: expected struct `std::string::String`
               found struct `Vec<u8>`

error[E0277]: `Result<Result<String, Error>, RecvError>` is not a future
   --> packages/http3/src/tls/builder/certificate.rs:127:30
    |
127 |                 }).collect().await;
    |                              ^^^^^ `Result<Result<String, Error>, RecvError>` is not a future
    |
    = help: the trait `futures_util::Future` is not implemented for `Result<Result<String, Error>, RecvError>`
    = note: Result<Result<String, Error>, RecvError> must be a future or must implement `IntoFuture` to be awaited
    = note: required for `Result<Result<String, Error>, RecvError>` to implement `std::future::IntoFuture`
    = note: the full name for the type has been written to '/Volumes/samsung_t9/fluent-ai/target/debug/deps/fluent_ai_http3-5d1a04d8fa2a31a3.long-type-2179012302818572181.txt'
    = note: consider using `--verbose` to print the full type name to the console
help: remove the `.await`
    |
127 -                 }).collect().await;
127 +                 }).collect();
    |

error[E0609]: no field `san_entries` on type `tls::types::ParsedCertificate`
   --> packages/http3/src/tls/builder/certificate.rs:334:36
    |
334 |                     if parsed_cert.san_entries.contains(domain)
    |                                    ^^^^^^^^^^^ unknown field
    |
    = note: available fields are: `subject`, `issuer`, `san_dns_names`, `san_ip_addresses`, `is_ca` ... and 10 others

error[E0599]: no method named `contains` found for struct `HashMap<K, V, S>` in the current scope
   --> packages/http3/src/tls/builder/certificate.rs:335:48
    |
335 |                         || parsed_cert.subject.contains(&format!("CN={}", domain))
    |                                                ^^^^^^^^
    |
help: there is a method `contains_key` with a similar name
    |
335 |                         || parsed_cert.subject.contains_key(&format!("CN={}", domain))
    |                                                        ++++

error[E0308]: mismatched types
   --> packages/http3/src/tls/builder/certificate.rs:361:34
    |
361 |                         subject: parsed_cert.subject.clone(),
    |                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `String`, found `HashMap<String, String>`
    |
    = note: expected struct `std::string::String`
               found struct `HashMap<std::string::String, std::string::String>`

error[E0308]: mismatched types
   --> packages/http3/src/tls/builder/certificate.rs:362:33
    |
362 |                         issuer: parsed_cert.issuer.clone(),
    |                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `String`, found `HashMap<String, String>`
    |
    = note: expected struct `std::string::String`
               found struct `HashMap<std::string::String, std::string::String>`

error[E0308]: mismatched types
   --> packages/http3/src/tls/builder/certificate.rs:363:40
    |
363 |                         serial_number: parsed_cert.serial_number.clone(),
    |                                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `String`, found `Vec<u8>`
    |
    = note: expected struct `std::string::String`
               found struct `Vec<u8>`

error[E0609]: no field `san_entries` on type `tls::types::ParsedCertificate`
   --> packages/http3/src/tls/builder/certificate.rs:366:46
    |
366 |                         domains: parsed_cert.san_entries.clone(),
    |                                              ^^^^^^^^^^^ unknown field
    |
    = note: available fields are: `subject`, `issuer`, `san_dns_names`, `san_ip_addresses`, `is_ca` ... and 10 others

error[E0609]: no field `san_entries` on type `tls::types::ParsedCertificate`
   --> packages/http3/src/tls/builder/certificate.rs:467:28
    |
467 |             if parsed_cert.san_entries.contains(domain)
    |                            ^^^^^^^^^^^ unknown field
    |
    = note: available fields are: `subject`, `issuer`, `san_dns_names`, `san_ip_addresses`, `is_ca` ... and 10 others

error[E0599]: no method named `contains` found for struct `HashMap<K, V, S>` in the current scope
   --> packages/http3/src/tls/builder/certificate.rs:468:40
    |
468 |                 || parsed_cert.subject.contains(&format!("CN={}", domain))
    |                                        ^^^^^^^^
    |
help: there is a method `contains_key` with a similar name
    |
468 |                 || parsed_cert.subject.contains_key(&format!("CN={}", domain))
    |                                                ++++

error[E0308]: mismatched types
   --> packages/http3/src/tls/builder/certificate.rs:500:26
    |
500 |                 subject: parsed_cert.subject.clone(),
    |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `String`, found `HashMap<String, String>`
    |
    = note: expected struct `std::string::String`
               found struct `HashMap<std::string::String, std::string::String>`

error[E0308]: mismatched types
   --> packages/http3/src/tls/builder/certificate.rs:501:25
    |
501 |                 issuer: parsed_cert.issuer.clone(),
    |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `String`, found `HashMap<String, String>`
    |
    = note: expected struct `std::string::String`
               found struct `HashMap<std::string::String, std::string::String>`

error[E0308]: mismatched types
   --> packages/http3/src/tls/builder/certificate.rs:502:32
    |
502 |                 serial_number: parsed_cert.serial_number.clone(),
    |                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `String`, found `Vec<u8>`
    |
    = note: expected struct `std::string::String`
               found struct `Vec<u8>`

error[E0609]: no field `san_entries` on type `tls::types::ParsedCertificate`
   --> packages/http3/src/tls/builder/certificate.rs:505:38
    |
505 |                 domains: parsed_cert.san_entries.clone(),
    |                                      ^^^^^^^^^^^ unknown field
    |
    = note: available fields are: `subject`, `issuer`, `san_dns_names`, `san_ip_addresses`, `is_ca` ... and 10 others

error[E0609]: no field `distinguished_name` on type `std::result::Result<CertificateParams, rcgen::Error>`
   --> packages/http3/src/tls/builder/certificate.rs:638:16
    |
638 |         params.distinguished_name = distinguished_name;
    |                ^^^^^^^^^^^^^^^^^^ unknown field
    |
help: one of the expressions' fields has a field of the same name
    |
638 |         params.unwrap().distinguished_name = distinguished_name;
    |                +++++++++

error[E0609]: no field `not_before` on type `std::result::Result<CertificateParams, rcgen::Error>`
   --> packages/http3/src/tls/builder/certificate.rs:642:16
    |
642 |         params.not_before = now.into();
    |                ^^^^^^^^^^ unknown field
    |
help: one of the expressions' fields has a field of the same name
    |
642 |         params.unwrap().not_before = now.into();
    |                +++++++++

error[E0609]: no field `not_after` on type `std::result::Result<CertificateParams, rcgen::Error>`
   --> packages/http3/src/tls/builder/certificate.rs:643:16
    |
643 |         params.not_after =
    |                ^^^^^^^^^ unknown field
    |
help: one of the expressions' fields has a field of the same name
    |
643 |         params.unwrap().not_after =
    |                +++++++++

error[E0609]: no field `subject_alt_names` on type `std::result::Result<CertificateParams, rcgen::Error>`
   --> packages/http3/src/tls/builder/certificate.rs:647:16
    |
647 |         params.subject_alt_names = self
    |                ^^^^^^^^^^^^^^^^^ unknown field
    |
help: one of the expressions' fields has a field of the same name
    |
647 |         params.unwrap().subject_alt_names = self
    |                +++++++++

error[E0308]: mismatched types
   --> packages/http3/src/tls/builder/certificate.rs:652:38
    |
652 |                     SanType::DnsName(domain.clone())
    |                     ---------------- ^^^^^^^^^^^^^^ expected `Ia5String`, found `String`
    |                     |
    |                     arguments to this enum variant are incorrect
    |
note: tuple variant defined here
   --> /Users/davidmaple/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/rcgen-0.13.2/src/lib.rs:160:2
    |
160 |     DnsName(Ia5String),
    |     ^^^^^^^

error[E0308]: mismatched types
   --> packages/http3/src/tls/builder/certificate.rs:654:38
    |
654 |                     SanType::DnsName(domain.clone())
    |                     ---------------- ^^^^^^^^^^^^^^ expected `Ia5String`, found `String`
    |                     |
    |                     arguments to this enum variant are incorrect
    |
note: tuple variant defined here
   --> /Users/davidmaple/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/rcgen-0.13.2/src/lib.rs:160:2
    |
160 |     DnsName(Ia5String),
    |     ^^^^^^^

error[E0061]: this function takes 0 arguments but 1 argument was supplied
   --> packages/http3/src/tls/builder/certificate.rs:660:30
    |
660 |         let key_pair = match KeyPair::generate(&rcgen::PKCS_RSA_SHA256) {
    |                              ^^^^^^^^^^^^^^^^^ ----------------------- unexpected argument of type `&rcgen::SignatureAlgorithm`
    |
note: associated function defined here
   --> /Users/davidmaple/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/rcgen-0.13.2/src/key_pair.rs:77:9
    |
 77 |     pub fn generate() -> Result<Self, Error> {
    |            ^^^^^^^^
help: remove the extra argument
    |
660 -         let key_pair = match KeyPair::generate(&rcgen::PKCS_RSA_SHA256) {
660 +         let key_pair = match KeyPair::generate() {
    |

error[E0609]: no field `key_pair` on type `std::result::Result<CertificateParams, rcgen::Error>`
   --> packages/http3/src/tls/builder/certificate.rs:678:16
    |
678 |         params.key_pair = Some(key_pair);
    |                ^^^^^^^^ unknown field
    |
    = note: available fields are: `not_before`, `not_after`, `serial_number`, `subject_alt_names`, `distinguished_name` ... and 8 others

error[E0599]: no function or associated item named `from_params` found for struct `rcgen::Certificate` in the current scope
   --> packages/http3/src/tls/builder/certificate.rs:683:39
    |
683 |             match rcgen::Certificate::from_params(params) {
    |                                       ^^^^^^^^^^^ function or associated item not found in `rcgen::Certificate`
    |
help: there is a method `params` with a similar name, but with different arguments
   --> /Users/davidmaple/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/rcgen-0.13.2/src/certificate.rs:33:2
    |
 33 |     pub fn params(&self) -> &CertificateParams {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0599]: no function or associated item named `from_ca_cert_pem` found for struct `CertificateParams` in the current scope
   --> packages/http3/src/tls/builder/certificate.rs:703:49
    |
703 |                 match rcgen::CertificateParams::from_ca_cert_pem(&ca.certificate_pem) {
    |                                                 ^^^^^^^^^^^^^^^^ function or associated item not found in `CertificateParams`
    |
note: if you're trying to build a new `CertificateParams`, consider using `CertificateParams::new` which returns `std::result::Result<CertificateParams, rcgen::Error>`
   --> /Users/davidmaple/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/rcgen-0.13.2/src/certificate.rs:122:2
    |
122 |     pub fn new(subject_alt_names: impl Into<Vec<String>>) -> Result<Self, Error> {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0599]: no function or associated item named `from_params` found for struct `rcgen::Certificate` in the current scope
   --> packages/http3/src/tls/builder/certificate.rs:739:53
    |
739 |             let ca_cert = match rcgen::Certificate::from_params(ca_cert_params) {
    |                                                     ^^^^^^^^^^^ function or associated item not found in `rcgen::Certificate`
    |
help: there is a method `params` with a similar name, but with different arguments
   --> /Users/davidmaple/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/rcgen-0.13.2/src/certificate.rs:33:2
    |
 33 |     pub fn params(&self) -> &CertificateParams {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0599]: no function or associated item named `from_params` found for struct `rcgen::Certificate` in the current scope
   --> packages/http3/src/tls/builder/certificate.rs:758:50
    |
758 |             let cert = match rcgen::Certificate::from_params(params) {
    |                                                  ^^^^^^^^^^^ function or associated item not found in `rcgen::Certificate`
    |
help: there is a method `params` with a similar name, but with different arguments
   --> /Users/davidmaple/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/rcgen-0.13.2/src/certificate.rs:33:2
    |
 33 |     pub fn params(&self) -> &CertificateParams {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0599]: no function or associated item named `from_params` found for struct `rcgen::Certificate` in the current scope
   --> packages/http3/src/tls/builder/certificate.rs:777:56
    |
777 |                 Ok(signed_cert) => rcgen::Certificate::from_params(params).unwrap(), /* Use signed cert */
    |                                                        ^^^^^^^^^^^ function or associated item not found in `rcgen::Certificate`
    |
help: there is a method `params` with a similar name, but with different arguments
   --> /Users/davidmaple/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/rcgen-0.13.2/src/certificate.rs:33:2
    |
 33 |     pub fn params(&self) -> &CertificateParams {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0277]: `Result<Result<(), Error>, RecvError>` is not a future
   --> packages/http3/src/tls/builder/certificate.rs:837:26
    |
837 |             }).collect().await;
    |                          ^^^^^ `Result<Result<(), Error>, RecvError>` is not a future
    |
    = help: the trait `futures_util::Future` is not implemented for `Result<Result<(), Error>, RecvError>`
    = note: Result<Result<(), Error>, RecvError> must be a future or must implement `IntoFuture` to be awaited
    = note: required for `Result<Result<(), Error>, RecvError>` to implement `std::future::IntoFuture`
    = note: the full name for the type has been written to '/Volumes/samsung_t9/fluent-ai/target/debug/deps/fluent_ai_http3-5d1a04d8fa2a31a3.long-type-9318222342785109656.txt'
    = note: consider using `--verbose` to print the full type name to the console
help: remove the `.await`
    |
837 -             }).collect().await;
837 +             }).collect();
    |

error[E0277]: `Result<Result<(), Error>, RecvError>` is not a future
   --> packages/http3/src/tls/builder/certificate.rs:861:26
    |
861 |             }).collect().await;
    |                          ^^^^^ `Result<Result<(), Error>, RecvError>` is not a future
    |
    = help: the trait `futures_util::Future` is not implemented for `Result<Result<(), Error>, RecvError>`
    = note: Result<Result<(), Error>, RecvError> must be a future or must implement `IntoFuture` to be awaited
    = note: required for `Result<Result<(), Error>, RecvError>` to implement `std::future::IntoFuture`
    = note: the full name for the type has been written to '/Volumes/samsung_t9/fluent-ai/target/debug/deps/fluent_ai_http3-5d1a04d8fa2a31a3.long-type-9318222342785109656.txt'
    = note: consider using `--verbose` to print the full type name to the console
help: remove the `.await`
    |
861 -             }).collect().await;
861 +             }).collect();
    |

error[E0277]: `Result<Result<(), Error>, RecvError>` is not a future
   --> packages/http3/src/tls/builder/certificate.rs:887:26
    |
887 |             }).collect().await;
    |                          ^^^^^ `Result<Result<(), Error>, RecvError>` is not a future
    |
    = help: the trait `futures_util::Future` is not implemented for `Result<Result<(), Error>, RecvError>`
    = note: Result<Result<(), Error>, RecvError> must be a future or must implement `IntoFuture` to be awaited
    = note: required for `Result<Result<(), Error>, RecvError>` to implement `std::future::IntoFuture`
    = note: the full name for the type has been written to '/Volumes/samsung_t9/fluent-ai/target/debug/deps/fluent_ai_http3-5d1a04d8fa2a31a3.long-type-9318222342785109656.txt'
    = note: consider using `--verbose` to print the full type name to the console
help: remove the `.await`
    |
887 -             }).collect().await;
887 +             }).collect();
    |

error[E0308]: mismatched types
  --> packages/http3/src/builder/methods/body_methods.rs:41:9
   |
34 |     fn post(self, url: &str) -> AsyncStream<crate::prelude::HttpResponse, 1> {
   |                                 -------------------------------------------- expected `fluent_ai_async::AsyncStream<http::response::HttpResponse, 1>` because of return type
...
41 |         self.client.execute_streaming(request)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `AsyncStream<HttpResponse, 1>`, found `AsyncStream<HttpChunk>`
   |
   = note: expected struct `fluent_ai_async::AsyncStream<http::response::HttpResponse, 1>`
              found struct `fluent_ai_async::AsyncStream<http::response::HttpChunk, 1024>`

error[E0308]: mismatched types
  --> packages/http3/src/builder/methods/body_methods.rs:52:9
   |
45 |     fn put(self, url: &str) -> AsyncStream<crate::prelude::HttpResponse, 1> {
   |                                -------------------------------------------- expected `fluent_ai_async::AsyncStream<http::response::HttpResponse, 1>` because of return type
...
52 |         self.client.execute_streaming(request)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `AsyncStream<HttpResponse, 1>`, found `AsyncStream<HttpChunk>`
   |
   = note: expected struct `fluent_ai_async::AsyncStream<http::response::HttpResponse, 1>`
              found struct `fluent_ai_async::AsyncStream<http::response::HttpChunk, 1024>`

error[E0308]: mismatched types
  --> packages/http3/src/builder/methods/body_methods.rs:63:9
   |
56 |     fn patch(self, url: &str) -> AsyncStream<crate::prelude::HttpResponse, 1> {
   |                                  -------------------------------------------- expected `fluent_ai_async::AsyncStream<http::response::HttpResponse, 1>` because of return type
...
63 |         self.client.execute_streaming(request)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `AsyncStream<HttpResponse, 1>`, found `AsyncStream<HttpChunk>`
   |
   = note: expected struct `fluent_ai_async::AsyncStream<http::response::HttpResponse, 1>`
              found struct `fluent_ai_async::AsyncStream<http::response::HttpChunk, 1024>`

error[E0308]: mismatched types
   --> packages/http3/src/builder/methods/body_methods.rs:111:9
    |
 97 |     pub fn post(mut self, url: &str) -> AsyncStream<crate::prelude::HttpResponse, 1> {
    |                                         -------------------------------------------- expected `fluent_ai_async::AsyncStream<http::response::HttpResponse, 1>` because of return type
...
111 |         self.client.execute_streaming(self.request)
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `AsyncStream<HttpResponse, 1>`, found `AsyncStream<HttpChunk>`
    |
    = note: expected struct `fluent_ai_async::AsyncStream<http::response::HttpResponse, 1>`
               found struct `fluent_ai_async::AsyncStream<http::response::HttpChunk, 1024>`

error[E0308]: mismatched types
   --> packages/http3/src/builder/methods/body_methods.rs:136:9
    |
122 |     pub fn put(mut self, url: &str) -> AsyncStream<crate::prelude::HttpResponse, 1> {
    |                                        -------------------------------------------- expected `fluent_ai_async::AsyncStream<http::response::HttpResponse, 1>` because of return type
...
136 |         self.client.execute_streaming(self.request)
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `AsyncStream<HttpResponse, 1>`, found `AsyncStream<HttpChunk>`
    |
    = note: expected struct `fluent_ai_async::AsyncStream<http::response::HttpResponse, 1>`
               found struct `fluent_ai_async::AsyncStream<http::response::HttpChunk, 1024>`

error[E0308]: mismatched types
   --> packages/http3/src/builder/methods/body_methods.rs:161:9
    |
147 |     pub fn patch(mut self, url: &str) -> AsyncStream<crate::prelude::HttpResponse, 1> {
    |                                          -------------------------------------------- expected `fluent_ai_async::AsyncStream<http::response::HttpResponse, 1>` because of return type
...
161 |         self.client.execute_streaming(self.request)
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `AsyncStream<HttpResponse, 1>`, found `AsyncStream<HttpChunk>`
    |
    = note: expected struct `fluent_ai_async::AsyncStream<http::response::HttpResponse, 1>`
               found struct `fluent_ai_async::AsyncStream<http::response::HttpChunk, 1024>`

error[E0308]: mismatched types
  --> packages/http3/src/builder/methods/jsonpath_methods.rs:97:13
   |
96 |         JsonPathStream::new(
   |         ------------------- arguments to this function are incorrect
97 |             self.client.execute_streaming(self.request),
   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `AsyncStream<HttpResponse, 1>`, found `AsyncStream<HttpChunk>`
   |
   = note: expected struct `fluent_ai_async::AsyncStream<http::response::HttpResponse, 1>`
              found struct `fluent_ai_async::AsyncStream<http::response::HttpChunk, 1024>`
note: associated function defined here
  --> packages/http3/src/builder/streaming.rs:92:12
   |
92 |     pub fn new(http_response_stream: AsyncStream<crate::prelude::HttpResponse, 1>, jsonpath_expr: String) -> Self {
   |            ^^^ ------------------------------------------------------------------

error[E0308]: mismatched types
   --> packages/http3/src/builder/methods/jsonpath_methods.rs:134:13
    |
133 |         JsonPathStream::new(
    |         ------------------- arguments to this function are incorrect
134 |             self.client.execute_streaming(self.request),
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `AsyncStream<HttpResponse, 1>`, found `AsyncStream<HttpChunk>`
    |
    = note: expected struct `fluent_ai_async::AsyncStream<http::response::HttpResponse, 1>`
               found struct `fluent_ai_async::AsyncStream<http::response::HttpChunk, 1024>`
note: associated function defined here
   --> packages/http3/src/builder/streaming.rs:92:12
    |
 92 |     pub fn new(http_response_stream: AsyncStream<crate::prelude::HttpResponse, 1>, jsonpath_expr: String) -> Self {
    |            ^^^ ------------------------------------------------------------------

error[E0308]: mismatched types
   --> packages/http3/src/builder/methods/jsonpath_methods.rs:168:13
    |
167 |         JsonPathStream::new(
    |         ------------------- arguments to this function are incorrect
168 |             self.client.execute_streaming(self.request),
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `AsyncStream<HttpResponse, 1>`, found `AsyncStream<HttpChunk>`
    |
    = note: expected struct `fluent_ai_async::AsyncStream<http::response::HttpResponse, 1>`
               found struct `fluent_ai_async::AsyncStream<http::response::HttpChunk, 1024>`
note: associated function defined here
   --> packages/http3/src/builder/streaming.rs:92:12
    |
 92 |     pub fn new(http_response_stream: AsyncStream<crate::prelude::HttpResponse, 1>, jsonpath_expr: String) -> Self {
    |            ^^^ ------------------------------------------------------------------

error[E0308]: mismatched types
  --> packages/http3/src/builder/methods/no_body_methods.rs:42:9
   |
35 |     fn get(self, url: &str) -> AsyncStream<crate::prelude::HttpResponse, 1> {
   |                                -------------------------------------------- expected `fluent_ai_async::AsyncStream<http::response::HttpResponse, 1>` because of return type
...
42 |         self.client.execute_streaming(request)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `AsyncStream<HttpResponse, 1>`, found `AsyncStream<HttpChunk>`
   |
   = note: expected struct `fluent_ai_async::AsyncStream<http::response::HttpResponse, 1>`
              found struct `fluent_ai_async::AsyncStream<http::response::HttpChunk, 1024>`

error[E0308]: mismatched types
  --> packages/http3/src/builder/methods/no_body_methods.rs:53:9
   |
46 |     fn delete(self, url: &str) -> AsyncStream<crate::prelude::HttpResponse, 1> {
   |                                   -------------------------------------------- expected `fluent_ai_async::AsyncStream<http::response::HttpResponse, 1>` because of return type
...
53 |         self.client.execute_streaming(request)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `AsyncStream<HttpResponse, 1>`, found `AsyncStream<HttpChunk>`
   |
   = note: expected struct `fluent_ai_async::AsyncStream<http::response::HttpResponse, 1>`
              found struct `fluent_ai_async::AsyncStream<http::response::HttpChunk, 1024>`

error[E0308]: mismatched types
  --> packages/http3/src/builder/methods/no_body_methods.rs:61:30
   |
61 |         DownloadBuilder::new(http_stream)
   |         -------------------- ^^^^^^^^^^^ expected `AsyncStream<HttpResponse, 1>`, found `AsyncStream<HttpChunk>`
   |         |
   |         arguments to this function are incorrect
   |
   = note: expected struct `fluent_ai_async::AsyncStream<http::response::HttpResponse, 1>`
              found struct `fluent_ai_async::AsyncStream<http::response::HttpChunk, 1024>`
note: associated function defined here
  --> packages/http3/src/builder/fluent.rs:49:19
   |
49 |     pub(crate) fn new(stream: AsyncStream<crate::prelude::HttpResponse, 1>) -> Self {
   |                   ^^^ ----------------------------------------------------

error[E0308]: mismatched types
   --> packages/http3/src/builder/methods/no_body_methods.rs:117:30
    |
117 |         DownloadBuilder::new(http_stream)
    |         -------------------- ^^^^^^^^^^^ expected `AsyncStream<HttpResponse, 1>`, found `AsyncStream<HttpChunk>`
    |         |
    |         arguments to this function are incorrect
    |
    = note: expected struct `fluent_ai_async::AsyncStream<http::response::HttpResponse, 1>`
               found struct `fluent_ai_async::AsyncStream<http::response::HttpChunk, 1024>`
note: associated function defined here
   --> packages/http3/src/builder/fluent.rs:49:19
    |
 49 |     pub(crate) fn new(stream: AsyncStream<crate::prelude::HttpResponse, 1>) -> Self {
    |                   ^^^ ----------------------------------------------------

error[E0609]: no field `body_stream` on type `http::response::HttpChunk`
   --> packages/http3/src/builder/methods/no_body_methods.rs:153:49
    |
153 |                 for body_chunk in http_response.body_stream {
    |                                                 ^^^^^^^^^^^ unknown field

error[E0061]: this function takes 0 arguments but 1 argument was supplied
  --> packages/http3/src/client/configuration.rs:82:12
   |
82 |         Ok(HttpClient::new(self.config))
   |            ^^^^^^^^^^^^^^^ ----------- unexpected argument of type `config::core::types::HttpConfig`
   |
note: associated function defined here
  --> packages/http3/src/client/core.rs:65:12
   |
65 |     pub fn new() -> Self {
   |            ^^^
help: remove the extra argument
   |
82 -         Ok(HttpClient::new(self.config))
82 +         Ok(HttpClient::new())
   |

error[E0061]: this function takes 0 arguments but 1 argument was supplied
  --> packages/http3/src/client/configuration.rs:95:27
   |
95 |         let http_client = HttpClient::new(config);
   |                           ^^^^^^^^^^^^^^^ ------ unexpected argument of type `config::core::types::HttpConfig`
   |
note: associated function defined here
  --> packages/http3/src/client/core.rs:65:12
   |
65 |     pub fn new() -> Self {
   |            ^^^
help: remove the extra argument
   |
95 -         let http_client = HttpClient::new(config);
95 +         let http_client = HttpClient::new();
   |

error[E0061]: this function takes 0 arguments but 1 argument was supplied
   --> packages/http3/src/client/configuration.rs:112:9
    |
112 |         crate::client::core::HttpClient::new(config)
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ------ unexpected argument of type `config::core::types::HttpConfig`
    |
note: associated function defined here
   --> packages/http3/src/client/core.rs:65:12
    |
 65 |     pub fn new() -> Self {
    |            ^^^
help: remove the extra argument
    |
112 -         crate::client::core::HttpClient::new(config)
112 +         crate::client::core::HttpClient::new()
    |

error[E0277]: the trait bound `AtomicU64: Clone` is not satisfied
  --> packages/http3/src/client/core.rs:19:5
   |
17 | #[derive(Debug, Clone, Default)]
   |                 ----- in this derive macro expansion
18 | pub struct ClientStats {
19 |     pub total_requests: AtomicU64,
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `Clone` is not implemented for `AtomicU64`

error[E0277]: the trait bound `AtomicU64: Clone` is not satisfied
  --> packages/http3/src/client/core.rs:20:5
   |
17 | #[derive(Debug, Clone, Default)]
   |                 ----- in this derive macro expansion
...
20 |     pub successful_requests: AtomicU64,
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `Clone` is not implemented for `AtomicU64`

error[E0277]: the trait bound `AtomicU64: Clone` is not satisfied
  --> packages/http3/src/client/core.rs:21:5
   |
17 | #[derive(Debug, Clone, Default)]
   |                 ----- in this derive macro expansion
...
21 |     pub failed_requests: AtomicU64,
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `Clone` is not implemented for `AtomicU64`

error[E0277]: the trait bound `AtomicU64: Clone` is not satisfied
  --> packages/http3/src/client/core.rs:22:5
   |
17 | #[derive(Debug, Clone, Default)]
   |                 ----- in this derive macro expansion
...
22 |     pub cache_hits: AtomicU64,
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `Clone` is not implemented for `AtomicU64`

error[E0277]: the trait bound `AtomicU64: Clone` is not satisfied
  --> packages/http3/src/client/core.rs:23:5
   |
17 | #[derive(Debug, Clone, Default)]
   |                 ----- in this derive macro expansion
...
23 |     pub cache_misses: AtomicU64,
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `Clone` is not implemented for `AtomicU64`

error[E0277]: the trait bound `AtomicU64: Clone` is not satisfied
  --> packages/http3/src/client/core.rs:24:5
   |
17 | #[derive(Debug, Clone, Default)]
   |                 ----- in this derive macro expansion
...
24 |     pub bytes_sent: AtomicU64,
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `Clone` is not implemented for `AtomicU64`

error[E0277]: the trait bound `AtomicU64: Clone` is not satisfied
  --> packages/http3/src/client/core.rs:25:5
   |
17 | #[derive(Debug, Clone, Default)]
   |                 ----- in this derive macro expansion
...
25 |     pub bytes_received: AtomicU64,
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `Clone` is not implemented for `AtomicU64`

error[E0277]: the trait bound `AtomicU64: Clone` is not satisfied
  --> packages/http3/src/client/core.rs:26:5
   |
17 | #[derive(Debug, Clone, Default)]
   |                 ----- in this derive macro expansion
...
26 |     pub connection_pool_size: AtomicU64,
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `Clone` is not implemented for `AtomicU64`

error[E0277]: the trait bound `AtomicU64: Clone` is not satisfied
  --> packages/http3/src/client/core.rs:27:5
   |
17 | #[derive(Debug, Clone, Default)]
   |                 ----- in this derive macro expansion
...
27 |     pub active_connections: AtomicU64,
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `Clone` is not implemented for `AtomicU64`

error[E0277]: the trait bound `AtomicU64: Clone` is not satisfied
  --> packages/http3/src/client/core.rs:28:5
   |
17 | #[derive(Debug, Clone, Default)]
   |                 ----- in this derive macro expansion
...
28 |     pub avg_response_time_ms: AtomicU64,
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `Clone` is not implemented for `AtomicU64`

error[E0616]: field `strategy` of struct `client::core::HttpClient` is private
  --> packages/http3/src/client/execution.rs:30:20
   |
30 |         match self.strategy {
   |                    ^^^^^^^^ private field
   |
help: a method `strategy` also exists, call it with parentheses
   |
30 |         match self.strategy() {
   |                            ++

error[E0533]: expected unit struct, unit variant or constant, found struct variant `crate::protocols::HttpProtocolStrategy::Auto`
  --> packages/http3/src/client/execution.rs:31:13
   |
31 |             crate::protocols::HttpProtocolStrategy::Auto => {
   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ not a unit struct, unit variant or constant
   |
help: the struct variant's fields are being ignored
   |
31 |             crate::protocols::HttpProtocolStrategy::Auto { prefer: _, fallback_chain: _, configs: _ } => {
   |                                                          ++++++++++++++++++++++++++++++++++++++++++++

error[E0599]: no function or associated item named `execute_http3` found for struct `client::core::HttpClient` in the current scope
   --> packages/http3/src/client/execution.rs:77:15
    |
 77 |         Self::execute_http3(request, &self.stats)
    |               ^^^^^^^^^^^^^ function or associated item not found in `client::core::HttpClient`
    |
   ::: packages/http3/src/client/core.rs:44:1
    |
 44 | pub struct HttpClient {
    | --------------------- function or associated item `execute_http3` not found for this struct
    |
note: if you're trying to build a new `client::core::HttpClient` consider using one of the following associated functions:
      client::configuration::<impl client::core::HttpClient>::with_config
      client::core::HttpClient::new
      client::core::HttpClient::ai_optimized
      client::core::HttpClient::streaming_optimized
      and 2 others
   --> packages/http3/src/client/configuration.rs:91:5
    |
 91 |     pub fn with_config(config: HttpConfig) -> Result<Self, HttpError> {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    |
   ::: packages/http3/src/client/core.rs:65:5
    |
 65 |     pub fn new() -> Self {
    |     ^^^^^^^^^^^^^^^^^^^^
...
 79 |     pub fn ai_optimized() -> Self {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
...
 93 |     pub fn streaming_optimized() -> Self {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: there is a method `execute` with a similar name, but with different arguments
   --> packages/http3/src/client/core.rs:226:5
    |
226 |     pub fn execute(&self, request: HttpRequest) -> crate::http::response::HttpResponse {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0616]: field `stats` of struct `client::core::HttpClient` is private
  --> packages/http3/src/client/execution.rs:77:44
   |
77 |         Self::execute_http3(request, &self.stats)
   |                                            ^^^^^ private field
   |
help: a method `stats` also exists, call it with parentheses
   |
77 |         Self::execute_http3(request, &self.stats())
   |                                                 ++

error[E0599]: no function or associated item named `execute_http2` found for struct `client::core::HttpClient` in the current scope
   --> packages/http3/src/client/execution.rs:83:15
    |
 83 |         Self::execute_http2(request, &self.stats)
    |               ^^^^^^^^^^^^^ function or associated item not found in `client::core::HttpClient`
    |
   ::: packages/http3/src/client/core.rs:44:1
    |
 44 | pub struct HttpClient {
    | --------------------- function or associated item `execute_http2` not found for this struct
    |
note: if you're trying to build a new `client::core::HttpClient` consider using one of the following associated functions:
      client::configuration::<impl client::core::HttpClient>::with_config
      client::core::HttpClient::new
      client::core::HttpClient::ai_optimized
      client::core::HttpClient::streaming_optimized
      and 2 others
   --> packages/http3/src/client/configuration.rs:91:5
    |
 91 |     pub fn with_config(config: HttpConfig) -> Result<Self, HttpError> {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    |
   ::: packages/http3/src/client/core.rs:65:5
    |
 65 |     pub fn new() -> Self {
    |     ^^^^^^^^^^^^^^^^^^^^
...
 79 |     pub fn ai_optimized() -> Self {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
...
 93 |     pub fn streaming_optimized() -> Self {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: there is a method `execute` with a similar name, but with different arguments
   --> packages/http3/src/client/core.rs:226:5
    |
226 |     pub fn execute(&self, request: HttpRequest) -> crate::http::response::HttpResponse {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0616]: field `stats` of struct `client::core::HttpClient` is private
  --> packages/http3/src/client/execution.rs:83:44
   |
83 |         Self::execute_http2(request, &self.stats)
   |                                            ^^^^^ private field
   |
help: a method `stats` also exists, call it with parentheses
   |
83 |         Self::execute_http2(request, &self.stats())
   |                                                 ++

error[E0599]: no function or associated item named `execute_http1` found for struct `client::core::HttpClient` in the current scope
   --> packages/http3/src/client/execution.rs:89:15
    |
 89 |         Self::execute_http1(request, &self.stats)
    |               ^^^^^^^^^^^^^ function or associated item not found in `client::core::HttpClient`
    |
   ::: packages/http3/src/client/core.rs:44:1
    |
 44 | pub struct HttpClient {
    | --------------------- function or associated item `execute_http1` not found for this struct
    |
note: if you're trying to build a new `client::core::HttpClient` consider using one of the following associated functions:
      client::configuration::<impl client::core::HttpClient>::with_config
      client::core::HttpClient::new
      client::core::HttpClient::ai_optimized
      client::core::HttpClient::streaming_optimized
      and 2 others
   --> packages/http3/src/client/configuration.rs:91:5
    |
 91 |     pub fn with_config(config: HttpConfig) -> Result<Self, HttpError> {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    |
   ::: packages/http3/src/client/core.rs:65:5
    |
 65 |     pub fn new() -> Self {
    |     ^^^^^^^^^^^^^^^^^^^^
...
 79 |     pub fn ai_optimized() -> Self {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
...
 93 |     pub fn streaming_optimized() -> Self {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: there is a method `execute` with a similar name, but with different arguments
   --> packages/http3/src/client/core.rs:226:5
    |
226 |     pub fn execute(&self, request: HttpRequest) -> crate::http::response::HttpResponse {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0616]: field `stats` of struct `client::core::HttpClient` is private
  --> packages/http3/src/client/execution.rs:89:44
   |
89 |         Self::execute_http1(request, &self.stats)
   |                                            ^^^^^ private field
   |
help: a method `stats` also exists, call it with parentheses
   |
89 |         Self::execute_http1(request, &self.stats())
   |                                                 ++

error[E0616]: field `stats` of struct `client::core::HttpClient` is private
   --> packages/http3/src/client/execution.rs:126:14
    |
126 |         self.stats.request_count.fetch_add(1, Ordering::Relaxed);
    |              ^^^^^ private field
    |
help: a method `stats` also exists, call it with parentheses
    |
126 |         self.stats().request_count.fetch_add(1, Ordering::Relaxed);
    |                   ++

error[E0616]: field `stats` of struct `client::core::HttpClient` is private
   --> packages/http3/src/client/execution.rs:143:18
    |
143 |             self.stats
    |                  ^^^^^ private field
    |
help: a method `stats` also exists, call it with parentheses
    |
143 |             self.stats()
    |                       ++

error[E0616]: field `stats` of struct `client::core::HttpClient` is private
   --> packages/http3/src/client/execution.rs:183:14
    |
183 |         self.stats.request_count.fetch_add(1, Ordering::Relaxed);
    |              ^^^^^ private field
    |
help: a method `stats` also exists, call it with parentheses
    |
183 |         self.stats().request_count.fetch_add(1, Ordering::Relaxed);
    |                   ++

error[E0616]: field `stats` of struct `client::core::HttpClient` is private
   --> packages/http3/src/client/execution.rs:187:18
    |
187 |             self.stats
    |                  ^^^^^ private field
    |
help: a method `stats` also exists, call it with parentheses
    |
187 |             self.stats()
    |                       ++

error[E0533]: expected value, found struct variant `DownloadChunk::Error`
   --> packages/http3/src/client/execution.rs:199:43
    |
199 |                         let error_chunk = DownloadChunk::Error(error_msg.into());
    |                                           ^^^^^^^^^^^^^^^^^^^^ not a value
    |
help: you might have meant to create a new value of the struct
    |
199 -                         let error_chunk = DownloadChunk::Error(error_msg.into());
199 +                         let error_chunk = DownloadChunk::Error { packet_id: /* value */, message: /* value */ };
    |

error[E0599]: no variant named `Data` found for enum `quiche::chunks::QuichePacketChunk`
   --> packages/http3/src/client/execution.rs:214:57
    |
214 |                     let download_chunk = DownloadChunk::Data {
    |                                                         ^^^^ variant not found in `quiche::chunks::QuichePacketChunk`
    |
   ::: packages/http3/src/protocols/quiche/chunks.rs:119:1
    |
119 | pub enum QuichePacketChunk {
    | -------------------------- variant `Data` not found here

error[E0599]: no variant or associated item named `Complete` found for enum `quiche::chunks::QuichePacketChunk` in the current scope
   --> packages/http3/src/client/execution.rs:224:46
    |
224 |                 emit!(sender, DownloadChunk::Complete);
    |                                              ^^^^^^^^ variant or associated item not found in `quiche::chunks::QuichePacketChunk`
    |
   ::: packages/http3/src/protocols/quiche/chunks.rs:119:1
    |
119 | pub enum QuichePacketChunk {
    | -------------------------- variant or associated item `Complete` not found for this enum

error[E0599]: no variant or associated item named `BuiltHttp` found for enum `ConnectorKind` in the current scope
  --> packages/http3/src/connect/builder/build.rs:32:28
   |
32 |             ConnectorKind::BuiltHttp(service)
   |                            ^^^^^^^^^ variant or associated item not found in `ConnectorKind`
   |
  ::: packages/http3/src/connect/types/connector.rs:16:1
   |
16 | pub enum ConnectorKind {
   | ---------------------- variant or associated item `BuiltHttp` not found for this enum

error[E0277]: `(dyn ConnectionTrait + std::marker::Send + 'static)` doesn't implement `std::fmt::Debug`
  --> packages/http3/src/connect/chunks.rs:21:9
   |
15 | #[derive(Debug)]
   |          ----- in this derive macro expansion
...
21 |         stream: Option<Box<dyn crate::connect::types::ConnectionTrait + Send>>,
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `std::fmt::Debug` is not implemented for `(dyn ConnectionTrait + std::marker::Send + 'static)`
   |
   = help: the following other types implement trait `std::fmt::Debug`:
             dyn std::any::Any + std::marker::Send + Sync
             dyn std::any::Any + std::marker::Send
             dyn std::any::Any
             dyn tracing::Value

error[E0599]: no method named `intercept` found for struct `Proxy` in the current scope
  --> packages/http3/src/connect/proxy/intercepted.rs:42:18
   |
41 |               let uri = proxy
   |  _______________________-
42 | |                 .intercept(&Uri::from_static("http://example.com"))
   | |                 -^^^^^^^^^----------------------------------------- help: remove the arguments
   | |                 ||
   | |_________________|field, not a method
   |
   |
  ::: packages/http3/src/proxy/core/types.rs:46:1
   |
46 |   pub struct Proxy {
   |   ---------------- method `intercept` not found for this struct

error[E0069]: `return;` in a function whose return type is not `()`
  --> packages/http3/src/connect/service/direct.rs:30:5
   |
20 | ) -> Result<(), String> {
   |      ------------------ expected `Result<(), String>` because of this return type
...
30 |     emit!(sender, TcpConnectionChunk::connected(local_addr, remote_addr, Some(conn_trait)));
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ return type is not `()`
   |
   = note: this error originates in the macro `emit` (in Nightly builds, run with -Z macro-backtrace for more info)
help: give the `return` a value of the expected type
  --> /Volumes/samsung_t9/fluent-ai/packages/async-stream/src/macros.rs:14:19
   |
14 |             return Ok(());
   |                    ++++++

error[E0308]: mismatched types
   --> packages/http3/src/connect/service/proxy.rs:134:75
    |
134 |                 if let Err(error) = super::direct::emit_stream_connection(&final_stream, &sender) {
    |                                     ------------------------------------- ^^^^^^^^^^^^^ expected `TcpStream`, found `&TcpStream`
    |                                     |
    |                                     arguments to this function are incorrect
    |
note: function defined here
   --> packages/http3/src/connect/service/direct.rs:17:15
    |
 17 | pub(super) fn emit_stream_connection(
    |               ^^^^^^^^^^^^^^^^^^^^^^
 18 |     stream: TcpStream,
    |     -----------------
help: consider removing the borrow
    |
134 -                 if let Err(error) = super::direct::emit_stream_connection(&final_stream, &sender) {
134 +                 if let Err(error) = super::direct::emit_stream_connection(final_stream, &sender) {
    |

error[E0616]: field `inner` of struct `Connector` is private
  --> packages/http3/src/connect/mod.rs:43:25
   |
43 |         match &mut self.inner {
   |                         ^^^^^ private field

warning: use of deprecated method `cookie::CookieBuilder::<'c>::finish`: `CookieBuilder` can be passed in to methods expecting a `Cookie`; for other cases, use `CookieBuilder::build()`
  --> packages/http3/src/cookie/core.rs:27:74
   |
27 |         let error_cookie = cookie_crate::Cookie::build(("ERROR", error)).finish();
   |                                                                          ^^^^^^
   |
   = note: `#[warn(deprecated)]` on by default

warning: use of deprecated method `cookie::CookieBuilder::<'c>::finish`: `CookieBuilder` can be passed in to methods expecting a `Cookie`; for other cases, use `CookieBuilder::build()`
  --> packages/http3/src/cookie/core.rs:46:75
   |
46 |         let default_cookie = cookie_crate::Cookie::build(("default", "")).finish();
   |                                                                           ^^^^^^

error[E0061]: this function takes 0 arguments but 1 argument was supplied
   --> packages/http3/src/http/resolver/core.rs:103:35
    |
103 |             http_client: Arc::new(HttpClient::new(crate::HttpConfig::default())),
    |                                   ^^^^^^^^^^^^^^^ ---------------------------- unexpected argument of type `config::core::types::HttpConfig`
    |
note: associated function defined here
   --> packages/http3/src/client/core.rs:65:12
    |
 65 |     pub fn new() -> Self {
    |            ^^^
help: remove the extra argument
    |
103 -             http_client: Arc::new(HttpClient::new(crate::HttpConfig::default())),
103 +             http_client: Arc::new(HttpClient::new()),
    |

error[E0599]: no method named `etag` found for struct `http::response::HttpResponse` in the current scope
  --> packages/http3/src/middleware/cache.rs:70:54
   |
70 |                 if let Some(ref etag) = cached_entry.etag() {
   |                                                      ^^^^ method not found in `http::response::HttpResponse`
   |
  ::: packages/http3/src/http/response.rs:19:1
   |
19 | pub struct HttpResponse {
   | ----------------------- method `etag` not found for this struct

error[E0277]: the size for values of type `str` cannot be known at compilation time
   --> packages/http3/src/middleware/cache.rs:70:24
    |
 70 |                 if let Some(ref etag) = cached_entry.etag() {
    |                        ^^^^^^^^^^^^^^ doesn't have a size known at compile-time
    |
    = help: the trait `Sized` is not implemented for `str`
note: required by a bound in `std::prelude::v1::Some`
   --> /Users/davidmaple/.rustup/toolchains/nightly-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/option.rs:593:17
    |
593 | pub enum Option<T> {
    |                 ^ required by this bound in `std::prelude::v1::Some`
...
601 |     Some(#[stable(feature = "rust1", since = "1.0.0")] T),
    |     ---- required by a bound in this tuple variant

error[E0599]: no method named `last_modified` found for struct `http::response::HttpResponse` in the current scope
  --> packages/http3/src/middleware/cache.rs:77:59
   |
77 |                 if let Some(last_modified) = cached_entry.last_modified() {
   |                                                           ^^^^^^^^^^^^^ method not found in `http::response::HttpResponse`
   |
  ::: packages/http3/src/http/response.rs:19:1
   |
19 | pub struct HttpResponse {
   | ----------------------- method `last_modified` not found for this struct

error[E0308]: mismatched types
  --> packages/http3/src/operations/delete.rs:64:9
   |
56 |     fn execute(&self) -> Self::Output {
   |                          ------------ expected `fluent_ai_async::AsyncStream<http::response::HttpResponse, 1>` because of return type
...
64 |         self.client.execute_streaming(request)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `AsyncStream<HttpResponse, 1>`, found `AsyncStream<HttpChunk>`
   |
   = note: expected struct `fluent_ai_async::AsyncStream<http::response::HttpResponse, 1>`
              found struct `fluent_ai_async::AsyncStream<http::response::HttpChunk, 1024>`

error[E0308]: mismatched types
   --> packages/http3/src/operations/get.rs:120:9
    |
104 |     fn execute(&self) -> Self::Output {
    |                          ------------ expected `fluent_ai_async::AsyncStream<http::response::HttpResponse, 1>` because of return type
...
120 |         self.client.execute_streaming(request)
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `AsyncStream<HttpResponse, 1>`, found `AsyncStream<HttpChunk>`
    |
    = note: expected struct `fluent_ai_async::AsyncStream<http::response::HttpResponse, 1>`
               found struct `fluent_ai_async::AsyncStream<http::response::HttpChunk, 1024>`

error[E0308]: mismatched types
   --> packages/http3/src/operations/patch.rs:139:9
    |
122 |     fn execute(&self) -> Self::Output {
    |                          ------------ expected `fluent_ai_async::AsyncStream<http::response::HttpResponse, 1>` because of return type
...
139 |         self.client.execute_streaming(request)
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `AsyncStream<HttpResponse, 1>`, found `AsyncStream<HttpChunk>`
    |
    = note: expected struct `fluent_ai_async::AsyncStream<http::response::HttpResponse, 1>`
               found struct `fluent_ai_async::AsyncStream<http::response::HttpChunk, 1024>`

error[E0308]: mismatched types
   --> packages/http3/src/operations/post.rs:135:9
    |
113 |     fn execute(&self) -> Self::Output {
    |                          ------------ expected `fluent_ai_async::AsyncStream<http::response::HttpResponse, 1>` because of return type
...
135 |         self.client.execute_streaming(request)
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `AsyncStream<HttpResponse, 1>`, found `AsyncStream<HttpChunk>`
    |
    = note: expected struct `fluent_ai_async::AsyncStream<http::response::HttpResponse, 1>`
               found struct `fluent_ai_async::AsyncStream<http::response::HttpChunk, 1024>`

error[E0308]: mismatched types
   --> packages/http3/src/operations/put.rs:151:9
    |
132 |     fn execute(&self) -> Self::Output {
    |                          ------------ expected `fluent_ai_async::AsyncStream<http::response::HttpResponse, 1>` because of return type
...
151 |         self.client.execute_streaming(request)
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `AsyncStream<HttpResponse, 1>`, found `AsyncStream<HttpChunk>`
    |
    = note: expected struct `fluent_ai_async::AsyncStream<http::response::HttpResponse, 1>`
               found struct `fluent_ai_async::AsyncStream<http::response::HttpChunk, 1024>`

warning: use of deprecated associated function `protocols::connection::Connection::new_h2`: Use new_h2_with_addr for real network connections
  --> packages/http3/src/protocols/connection.rs:26:21
   |
26 |         Connection::new_h2(true)
   |                     ^^^^^^

warning: use of deprecated associated function `protocols::connection::Connection::new_h2`: Use new_h2_with_addr for real network connections
   --> packages/http3/src/protocols/connection.rs:216:38
    |
216 |         let connection = Connection::new_h2(is_client);
    |                                      ^^^^^^

warning: use of deprecated associated function `protocols::connection::Connection::new_h2`: Use new_h2_with_addr for real network connections
   --> packages/http3/src/protocols/connection.rs:217:50
    |
217 |         let connection_for_storage = Connection::new_h2(is_client);
    |                                                  ^^^^^^

warning: use of deprecated associated function `protocols::connection::Connection::new_h3`: Use new_h3_with_addr for real network connections
   --> packages/http3/src/protocols/connection.rs:228:38
    |
228 |         let connection = Connection::new_h3(is_client);
    |                                      ^^^^^^

warning: use of deprecated associated function `protocols::connection::Connection::new_h3`: Use new_h3_with_addr for real network connections
   --> packages/http3/src/protocols/connection.rs:229:50
    |
229 |         let connection_for_storage = Connection::new_h3(is_client);
    |                                                  ^^^^^^

error[E0599]: no method named `host` found for struct `std::string::String` in the current scope
  --> packages/http3/src/protocols/h2/adapter.rs:27:20
   |
27 |     let host = uri.host().ok_or_else(|| HttpError::new("Missing host in URI".to_string()))?;
   |                    ^^^^ method not found in `std::string::String`

error[E0308]: mismatched types
  --> packages/http3/src/protocols/h2/adapter.rs:27:56
   |
27 |     let host = uri.host().ok_or_else(|| HttpError::new("Missing host in URI".to_string()))?;
   |                                         -------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `Kind`, found `String`
   |                                         |
   |                                         arguments to this function are incorrect
   |
note: associated function defined here
  --> packages/http3/src/error/types.rs:42:12
   |
42 |     pub fn new(kind: Kind) -> Error {
   |            ^^^ ----------

error[E0599]: no method named `port_u16` found for struct `std::string::String` in the current scope
  --> packages/http3/src/protocols/h2/adapter.rs:28:20
   |
28 |     let port = uri.port_u16().unwrap_or(if uri.scheme_str() == Some("https") { 443 } else { 80 });
   |                    ^^^^^^^^ method not found in `std::string::String`

error[E0599]: no method named `scheme_str` found for struct `std::string::String` in the current scope
  --> packages/http3/src/protocols/h2/adapter.rs:28:48
   |
28 |     let port = uri.port_u16().unwrap_or(if uri.scheme_str() == Some("https") { 443 } else { 80 });
   |                                                ^^^^^^^^^^ method not found in `std::string::String`

error[E0308]: mismatched types
  --> packages/http3/src/protocols/h2/adapter.rs:32:37
   |
32 |         .map_err(|e| HttpError::new(format!("Failed to connect to {}:{}: {}", host, port, e)))?;
   |                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `Kind`, found `String`
   |
   = note: this error originates in the macro `format` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0277]: `fluent_ai_async::AsyncStream<H2ConnectionChunk>` is not an iterator
  --> packages/http3/src/protocols/h2/adapter.rs:45:29
   |
45 |             for h2_chunk in h2_data_stream {
   |                             ^^^^^^^^^^^^^^ `fluent_ai_async::AsyncStream<H2ConnectionChunk>` is not an iterator
   |
   = help: the trait `IntoIterator` is not implemented for `fluent_ai_async::AsyncStream<H2ConnectionChunk>`
   = help: the trait `IntoIterator` is implemented for `fluent_ai_async::AsyncStream<T, CAP>`

error[E0277]: the trait bound `T: tokio::io::async_read::AsyncRead` is not satisfied
    --> packages/http3/src/protocols/h2/connection.rs:130:56
     |
 130 |             match h2::client::Builder::new().handshake(io) {
     |                                              --------- ^^ the trait `tokio::io::async_read::AsyncRead` is not implemented for `T`
     |                                              |
     |                                              required by a bound introduced by this call
     |
note: required by a bound in `h2::client::Builder::handshake`
    --> /Users/davidmaple/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/h2-0.4.12/src/client.rs:1225:12
     |
1220 |     pub fn handshake<T, B>(
     |            --------- required by a bound in this associated function
...
1225 |         T: AsyncRead + AsyncWrite + Unpin,
     |            ^^^^^^^^^ required by this bound in `Builder::handshake`
help: consider further restricting type parameter `T` with trait `AsyncRead`
     |
 126 |         T: std::io::Read + std::io::Write + Unpin + Send + 'static + tokio::io::async_read::AsyncRead,
     |                                                                    ++++++++++++++++++++++++++++++++++

error[E0277]: the trait bound `T: tokio::io::async_write::AsyncWrite` is not satisfied
    --> packages/http3/src/protocols/h2/connection.rs:130:56
     |
 130 |             match h2::client::Builder::new().handshake(io) {
     |                                              --------- ^^ the trait `tokio::io::async_write::AsyncWrite` is not implemented for `T`
     |                                              |
     |                                              required by a bound introduced by this call
     |
note: required by a bound in `h2::client::Builder::handshake`
    --> /Users/davidmaple/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/h2-0.4.12/src/client.rs:1225:24
     |
1220 |     pub fn handshake<T, B>(
     |            --------- required by a bound in this associated function
...
1225 |         T: AsyncRead + AsyncWrite + Unpin,
     |                        ^^^^^^^^^^ required by this bound in `Builder::handshake`
help: consider further restricting type parameter `T` with trait `AsyncWrite`
     |
 126 |         T: std::io::Read + std::io::Write + Unpin + Send + 'static + tokio::io::async_write::AsyncWrite,
     |                                                                    ++++++++++++++++++++++++++++++++++++

error[E0308]: mismatched types
    --> packages/http3/src/protocols/h2/connection.rs:131:17
     |
 130 |             match h2::client::Builder::new().handshake(io) {
     |                   ---------------------------------------- this expression has type `impl Future<Output = Result<(SendRequest<_>, Connection<T, _>), ...>>`
 131 |                 Ok((mut send_request, mut connection)) => {
     |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected future, found `Result<_, _>`
     |
    ::: /Users/davidmaple/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/h2-0.4.12/src/client.rs:1223:10
     |
1223 |     ) -> impl Future<Output = Result<(SendRequest<B>, Connection<T, B>), crate::Error>>
     |          ------------------------------------------------------------------------------ the expected future
     |
     = note: expected opaque type `impl futures_util::Future<Output = std::result::Result<(h2::client::SendRequest<_>, h2::client::Connection<T, _>), h2::Error>>`
                       found enum `std::result::Result<_, _>`
     = note: the full name for the type has been written to '/Volumes/samsung_t9/fluent-ai/target/debug/deps/fluent_ai_http3-5d1a04d8fa2a31a3.long-type-5270158874445330368.txt'
     = note: consider using `--verbose` to print the full type name to the console

error[E0308]: mismatched types
    --> packages/http3/src/protocols/h2/connection.rs:267:17
     |
 130 |             match h2::client::Builder::new().handshake(io) {
     |                   ---------------------------------------- this expression has type `impl Future<Output = Result<(SendRequest<_>, Connection<T, _>), ...>>`
...
 267 |                 Err(e) => {
     |                 ^^^^^^ expected future, found `Result<_, _>`
     |
    ::: /Users/davidmaple/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/h2-0.4.12/src/client.rs:1223:10
     |
1223 |     ) -> impl Future<Output = Result<(SendRequest<B>, Connection<T, B>), crate::Error>>
     |          ------------------------------------------------------------------------------ the expected future
     |
     = note: expected opaque type `impl futures_util::Future<Output = std::result::Result<(h2::client::SendRequest<_>, h2::client::Connection<T, _>), h2::Error>>`
                       found enum `std::result::Result<_, _>`
     = note: the full name for the type has been written to '/Volumes/samsung_t9/fluent-ai/target/debug/deps/fluent_ai_http3-5d1a04d8fa2a31a3.long-type-5270158874445330368.txt'
     = note: consider using `--verbose` to print the full type name to the console

error[E0599]: no method named `clone` found for struct `AtomicBool` in the current scope
  --> packages/http3/src/protocols/h2/frame_processor.rs:42:53
   |
42 |             let is_closed = Arc::new(self.is_closed.clone());
   |                                                     ^^^^^ method not found in `AtomicBool`

error[E0277]: the trait bound `TcpStream: tokio::io::async_read::AsyncRead` is not satisfied
    --> packages/http3/src/protocols/h2/h2.rs:69:41
     |
  69 |             match h2::client::handshake(tcp) {
     |                   --------------------- ^^^ the trait `tokio::io::async_read::AsyncRead` is not implemented for `TcpStream`
     |                   |
     |                   required by a bound introduced by this call
     |
     = help: the following other types implement trait `tokio::io::async_read::AsyncRead`:
               &[u8]
               &mut T
               Box<T>
               Pin<P>
               TokioIo<T>
               WithHyperIo<I>
               WithTokioIo<I>
               h2::codec::framed_write::FramedWrite<T, B>
             and 29 others
note: required by a bound in `h2::client::handshake`
    --> /Users/davidmaple/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/h2-0.4.12/src/client.rs:1275:8
     |
1273 | pub async fn handshake<T>(io: T) -> Result<(SendRequest<Bytes>, Connection<T, Bytes>), crate::Error>
     |              --------- required by a bound in this function
1274 | where
1275 |     T: AsyncRead + AsyncWrite + Unpin,
     |        ^^^^^^^^^ required by this bound in `handshake`

error[E0277]: the trait bound `TcpStream: tokio::io::async_write::AsyncWrite` is not satisfied
    --> packages/http3/src/protocols/h2/h2.rs:69:41
     |
  69 |             match h2::client::handshake(tcp) {
     |                   --------------------- ^^^ the trait `tokio::io::async_write::AsyncWrite` is not implemented for `TcpStream`
     |                   |
     |                   required by a bound introduced by this call
     |
     = help: the following other types implement trait `tokio::io::async_write::AsyncWrite`:
               &mut T
               Box<T>
               Pin<P>
               TokioIo<T>
               Vec<u8>
               WithHyperIo<I>
               WithTokioIo<I>
               hickory_proto::runtime::iocompat::AsyncIoStdAsTokio<W>
             and 28 others
note: required by a bound in `h2::client::handshake`
    --> /Users/davidmaple/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/h2-0.4.12/src/client.rs:1275:20
     |
1273 | pub async fn handshake<T>(io: T) -> Result<(SendRequest<Bytes>, Connection<T, Bytes>), crate::Error>
     |              --------- required by a bound in this function
1274 | where
1275 |     T: AsyncRead + AsyncWrite + Unpin,
     |                    ^^^^^^^^^^ required by this bound in `handshake`

error[E0308]: mismatched types
  --> packages/http3/src/protocols/h2/h2.rs:70:17
   |
69 |             match h2::client::handshake(tcp) {
   |                   -------------------------- this expression has type `impl Future<Output = Result<(SendRequest<Bytes>, ...), ...>>`
70 |                 Ok((mut h2, connection)) => {
   |                 ^^^^^^^^^^^^^^^^^^^^^^^^ expected future, found `Result<_, _>`
   |
   = note: expected opaque type `impl futures_util::Future<Output = std::result::Result<(h2::client::SendRequest<bytes::Bytes>, h2::client::Connection<TcpStream>), h2::Error>>`
                     found enum `std::result::Result<_, _>`
   = note: the full name for the type has been written to '/Volumes/samsung_t9/fluent-ai/target/debug/deps/fluent_ai_http3-5d1a04d8fa2a31a3.long-type-124594188263120465.txt'
   = note: consider using `--verbose` to print the full type name to the console

error[E0277]: the trait bound `TcpStream: tokio::io::async_read::AsyncRead` is not satisfied
    --> packages/http3/src/protocols/h2/h2.rs:69:19
     |
  69 |             match h2::client::handshake(tcp) {
     |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `tokio::io::async_read::AsyncRead` is not implemented for `TcpStream`
     |
     = help: the following other types implement trait `tokio::io::async_read::AsyncRead`:
               &[u8]
               &mut T
               Box<T>
               Pin<P>
               TokioIo<T>
               WithHyperIo<I>
               WithTokioIo<I>
               h2::codec::framed_write::FramedWrite<T, B>
             and 29 others
note: required by a bound in `h2::client::handshake`
    --> /Users/davidmaple/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/h2-0.4.12/src/client.rs:1275:8
     |
1273 | pub async fn handshake<T>(io: T) -> Result<(SendRequest<Bytes>, Connection<T, Bytes>), crate::Error>
     |              --------- required by a bound in this function
1274 | where
1275 |     T: AsyncRead + AsyncWrite + Unpin,
     |        ^^^^^^^^^ required by this bound in `handshake`

error[E0277]: the trait bound `TcpStream: tokio::io::async_write::AsyncWrite` is not satisfied
    --> packages/http3/src/protocols/h2/h2.rs:69:19
     |
  69 |             match h2::client::handshake(tcp) {
     |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `tokio::io::async_write::AsyncWrite` is not implemented for `TcpStream`
     |
     = help: the following other types implement trait `tokio::io::async_write::AsyncWrite`:
               &mut T
               Box<T>
               Pin<P>
               TokioIo<T>
               Vec<u8>
               WithHyperIo<I>
               WithTokioIo<I>
               hickory_proto::runtime::iocompat::AsyncIoStdAsTokio<W>
             and 28 others
note: required by a bound in `h2::client::handshake`
    --> /Users/davidmaple/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/h2-0.4.12/src/client.rs:1275:20
     |
1273 | pub async fn handshake<T>(io: T) -> Result<(SendRequest<Bytes>, Connection<T, Bytes>), crate::Error>
     |              --------- required by a bound in this function
1274 | where
1275 |     T: AsyncRead + AsyncWrite + Unpin,
     |                    ^^^^^^^^^^ required by this bound in `handshake`

error[E0308]: mismatched types
   --> packages/http3/src/protocols/h2/h2.rs:135:17
    |
 69 |             match h2::client::handshake(tcp) {
    |                   -------------------------- this expression has type `impl Future<Output = Result<(SendRequest<Bytes>, ...), ...>>`
...
135 |                 Err(e) => {
    |                 ^^^^^^ expected future, found `Result<_, _>`
    |
    = note: expected opaque type `impl futures_util::Future<Output = std::result::Result<(h2::client::SendRequest<bytes::Bytes>, h2::client::Connection<TcpStream>), h2::Error>>`
                      found enum `std::result::Result<_, _>`
    = note: the full name for the type has been written to '/Volumes/samsung_t9/fluent-ai/target/debug/deps/fluent_ai_http3-5d1a04d8fa2a31a3.long-type-124594188263120465.txt'
    = note: consider using `--verbose` to print the full type name to the console

error[E0599]: the function or associated item `with_channel` exists for struct `fluent_ai_async::AsyncStream<H2ConnectionChunk>`, but its trait bounds were not satisfied
   --> packages/http3/src/protocols/h2/streaming.rs:56:49
    |
 56 |         AsyncStream::<H2ConnectionChunk, 1024>::with_channel(move |sender| {
    |                                                 ^^^^^^^^^^^^ function or associated item cannot be called on `fluent_ai_async::AsyncStream<H2ConnectionChunk>` due to unsatisfied trait bounds
    |
   ::: packages/http3/src/protocols/h2/chunks.rs:8:1
    |
  8 | pub enum H2ConnectionChunk {
    | -------------------------- doesn't satisfy `H2ConnectionChunk: std::default::Default`
    |
    = note: the following trait bounds were not satisfied:
            `H2ConnectionChunk: std::default::Default`
note: the trait `std::default::Default` must be implemented
   --> /Users/davidmaple/.rustup/toolchains/nightly-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/default.rs:108:1
    |
108 | pub trait Default: Sized {
    | ^^^^^^^^^^^^^^^^^^^^^^^^

error[E0277]: the trait bound `T: tokio::io::async_read::AsyncRead` is not satisfied
    --> packages/http3/src/protocols/h2/streaming.rs:60:56
     |
  60 |             match h2::client::Builder::new().handshake(io) {
     |                                              --------- ^^ the trait `tokio::io::async_read::AsyncRead` is not implemented for `T`
     |                                              |
     |                                              required by a bound introduced by this call
     |
note: required by a bound in `h2::client::Builder::handshake`
    --> /Users/davidmaple/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/h2-0.4.12/src/client.rs:1225:12
     |
1220 |     pub fn handshake<T, B>(
     |            --------- required by a bound in this associated function
...
1225 |         T: AsyncRead + AsyncWrite + Unpin,
     |            ^^^^^^^^^ required by this bound in `Builder::handshake`
help: consider further restricting type parameter `T` with trait `AsyncRead`
     |
  51 |         T: std::io::Read + std::io::Write + Unpin + Send + 'static + tokio::io::async_read::AsyncRead,
     |                                                                    ++++++++++++++++++++++++++++++++++

error[E0277]: the trait bound `T: tokio::io::async_write::AsyncWrite` is not satisfied
    --> packages/http3/src/protocols/h2/streaming.rs:60:56
     |
  60 |             match h2::client::Builder::new().handshake(io) {
     |                                              --------- ^^ the trait `tokio::io::async_write::AsyncWrite` is not implemented for `T`
     |                                              |
     |                                              required by a bound introduced by this call
     |
note: required by a bound in `h2::client::Builder::handshake`
    --> /Users/davidmaple/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/h2-0.4.12/src/client.rs:1225:24
     |
1220 |     pub fn handshake<T, B>(
     |            --------- required by a bound in this associated function
...
1225 |         T: AsyncRead + AsyncWrite + Unpin,
     |                        ^^^^^^^^^^ required by this bound in `Builder::handshake`
help: consider further restricting type parameter `T` with trait `AsyncWrite`
     |
  51 |         T: std::io::Read + std::io::Write + Unpin + Send + 'static + tokio::io::async_write::AsyncWrite,
     |                                                                    ++++++++++++++++++++++++++++++++++++

error[E0308]: mismatched types
    --> packages/http3/src/protocols/h2/streaming.rs:61:17
     |
  60 |             match h2::client::Builder::new().handshake(io) {
     |                   ---------------------------------------- this expression has type `impl Future<Output = Result<(SendRequest<_>, Connection<T, _>), ...>>`
  61 |                 Ok((send_request, connection)) => {
     |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected future, found `Result<_, _>`
     |
    ::: /Users/davidmaple/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/h2-0.4.12/src/client.rs:1223:10
     |
1223 |     ) -> impl Future<Output = Result<(SendRequest<B>, Connection<T, B>), crate::Error>>
     |          ------------------------------------------------------------------------------ the expected future
     |
     = note: expected opaque type `impl futures_util::Future<Output = std::result::Result<(h2::client::SendRequest<_>, h2::client::Connection<T, _>), h2::Error>>`
                       found enum `std::result::Result<_, _>`
     = note: the full name for the type has been written to '/Volumes/samsung_t9/fluent-ai/target/debug/deps/fluent_ai_http3-5d1a04d8fa2a31a3.long-type-3835986913835207508.txt'
     = note: consider using `--verbose` to print the full type name to the console

error[E0308]: mismatched types
    --> packages/http3/src/protocols/h2/streaming.rs:88:17
     |
  60 |             match h2::client::Builder::new().handshake(io) {
     |                   ---------------------------------------- this expression has type `impl Future<Output = Result<(SendRequest<_>, Connection<T, _>), ...>>`
...
  88 |                 Err(e) => {
     |                 ^^^^^^ expected future, found `Result<_, _>`
     |
    ::: /Users/davidmaple/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/h2-0.4.12/src/client.rs:1223:10
     |
1223 |     ) -> impl Future<Output = Result<(SendRequest<B>, Connection<T, B>), crate::Error>>
     |          ------------------------------------------------------------------------------ the expected future
     |
     = note: expected opaque type `impl futures_util::Future<Output = std::result::Result<(h2::client::SendRequest<_>, h2::client::Connection<T, _>), h2::Error>>`
                       found enum `std::result::Result<_, _>`
     = note: the full name for the type has been written to '/Volumes/samsung_t9/fluent-ai/target/debug/deps/fluent_ai_http3-5d1a04d8fa2a31a3.long-type-3835986913835207508.txt'
     = note: consider using `--verbose` to print the full type name to the console

error[E0599]: the function or associated item `with_channel` exists for struct `fluent_ai_async::AsyncStream<H2DataChunk>`, but its trait bounds were not satisfied
   --> packages/http3/src/protocols/h2/streaming.rs:107:43
    |
107 |         AsyncStream::<H2DataChunk, 1024>::with_channel(move |sender| {
    |                                           ^^^^^^^^^^^^ function or associated item cannot be called on `fluent_ai_async::AsyncStream<H2DataChunk>` due to unsatisfied trait bounds
    |
   ::: packages/http3/src/protocols/h2/chunks.rs:88:1
    |
 88 | pub enum H2DataChunk {
    | -------------------- doesn't satisfy `H2DataChunk: std::default::Default`
    |
    = note: the following trait bounds were not satisfied:
            `H2DataChunk: std::default::Default`
note: the trait `std::default::Default` must be implemented
   --> /Users/davidmaple/.rustup/toolchains/nightly-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/default.rs:108:1
    |
108 | pub trait Default: Sized {
    | ^^^^^^^^^^^^^^^^^^^^^^^^

error[E0599]: the function or associated item `with_channel` exists for struct `fluent_ai_async::AsyncStream<H2SendResult>`, but its trait bounds were not satisfied
   --> packages/http3/src/protocols/h2/streaming.rs:156:44
    |
156 |         AsyncStream::<H2SendResult, 1024>::with_channel(move |sender| {
    |                                            ^^^^^^^^^^^^ function or associated item cannot be called on `fluent_ai_async::AsyncStream<H2SendResult>` due to unsatisfied trait bounds
    |
   ::: packages/http3/src/protocols/h2/chunks.rs:130:1
    |
130 | pub enum H2SendResult {
    | --------------------- doesn't satisfy `H2SendResult: std::default::Default`
    |
    = note: the following trait bounds were not satisfied:
            `H2SendResult: std::default::Default`
note: the trait `std::default::Default` must be implemented
   --> /Users/davidmaple/.rustup/toolchains/nightly-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/default.rs:108:1
    |
108 | pub trait Default: Sized {
    | ^^^^^^^^^^^^^^^^^^^^^^^^

error[E0599]: no method named `poll_ready` found for struct `SendStream<B>` in the current scope
   --> packages/http3/src/protocols/h2/streaming.rs:163:30
    |
163 |                 match stream.poll_ready(&mut context) {
    |                              ^^^^^^^^^^
    |
help: there is a method `poll_reset` with a similar name
    |
163 -                 match stream.poll_ready(&mut context) {
163 +                 match stream.poll_reset(&mut context) {
    |

error[E0308]: mismatched types
  --> packages/http3/src/protocols/h3/adapter.rs:58:37
   |
58 |         .map_err(|e| HttpError::new(format!("Failed to create quiche config: {}", e)))?;
   |                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `Kind`, found `String`
   |
   = note: this error originates in the macro `format` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0308]: mismatched types
  --> packages/http3/src/protocols/h3/adapter.rs:61:37
   |
61 |         .map_err(|e| HttpError::new(format!("Failed to set H3 protocol: {}", e)))?;
   |                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `Kind`, found `String`
   |
   = note: this error originates in the macro `format` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0308]: mismatched types
    --> packages/http3/src/protocols/h3/adapter.rs:65:49
     |
  65 |     quiche_config.set_max_recv_udp_payload_size(config.max_udp_payload_size);
     |                   ----------------------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `usize`, found `u16`
     |                   |
     |                   arguments to this method are incorrect
     |
note: method defined here
    --> /Users/davidmaple/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/quiche-0.24.5/src/lib.rs:1144:12
     |
1144 |     pub fn set_max_recv_udp_payload_size(&mut self, v: usize) {
     |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: you can convert a `u16` to a `usize`
     |
  65 |     quiche_config.set_max_recv_udp_payload_size(config.max_udp_payload_size.into());
     |                                                                            +++++++

error[E0308]: mismatched types
    --> packages/http3/src/protocols/h3/adapter.rs:66:49
     |
  66 |     quiche_config.set_max_send_udp_payload_size(config.max_udp_payload_size);
     |                   ----------------------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `usize`, found `u16`
     |                   |
     |                   arguments to this method are incorrect
     |
note: method defined here
    --> /Users/davidmaple/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/quiche-0.24.5/src/lib.rs:1151:12
     |
1151 |     pub fn set_max_send_udp_payload_size(&mut self, v: usize) {
     |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: you can convert a `u16` to a `usize`
     |
  66 |     quiche_config.set_max_send_udp_payload_size(config.max_udp_payload_size.into());
     |                                                                            +++++++

error[E0308]: mismatched types
  --> packages/http3/src/protocols/h3/adapter.rs:82:37
   |
82 |         .map_err(|e| HttpError::new(format!("Invalid local address: {}", e)))?;
   |                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `Kind`, found `String`
   |
   = note: this error originates in the macro `format` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0308]: mismatched types
  --> packages/http3/src/protocols/h3/adapter.rs:86:37
   |
86 |         .map_err(|e| HttpError::new(format!("Invalid peer address: {}", e)))?;
   |                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `Kind`, found `String`
   |
   = note: this error originates in the macro `format` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0308]: mismatched types
  --> packages/http3/src/protocols/h3/adapter.rs:89:37
   |
89 |         .map_err(|e| HttpError::new(format!("Failed to create quiche connection: {}", e)))?;
   |                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `Kind`, found `String`
   |
   = note: this error originates in the macro `format` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0599]: no method named `timeout_config` found for reference `&H3Config` in the current scope
  --> packages/http3/src/protocols/h3/adapter.rs:91:33
   |
91 |     let timeout_config = config.timeout_config();
   |                                 ^^^^^^^^^^^^^^ method not found in `&H3Config`
   |
   = help: items from traits can only be used if the trait is in scope
help: trait `ProtocolConfig` which provides `timeout_config` is implemented but not in scope; perhaps you want to import it
   |
 6 + use crate::protocols::core::ProtocolConfig;
   |

error[E0308]: mismatched types
   --> packages/http3/src/protocols/h3/adapter.rs:117:41
    |
117 |             .map_err(|e| HttpError::new(format!("Invalid header value: {}", e)))?);
    |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `Kind`, found `String`
    |
    = note: this error originates in the macro `format` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0308]: mismatched types
    --> packages/http3/src/protocols/h3/adapter.rs:124:40
     |
 124 |         request_data.extend_from_slice(body);
     |                      ----------------- ^^^^ expected `&[u8]`, found `&RequestBody`
     |                      |
     |                      arguments to this method are incorrect
     |
     = note: expected reference `&[u8]`
                found reference `&http::request::RequestBody`
note: method defined here
    --> /Users/davidmaple/.rustup/toolchains/nightly-aarch64-apple-darwin/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:3261:12
     |
3261 |     pub fn extend_from_slice(&mut self, other: &[T]) {
     |            ^^^^^^^^^^^^^^^^^

error[E0277]: `quiche::Connection` doesn't implement `std::fmt::Debug`
  --> packages/http3/src/protocols/h3/connection.rs:19:5
   |
17 | #[derive(Debug)]
   |          ----- in this derive macro expansion
18 | pub struct H3Connection {
19 |     inner: Arc<std::sync::Mutex<quiche::Connection>>,
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `std::fmt::Debug` is not implemented for `quiche::Connection`
   |
   = help: the trait `std::fmt::Debug` is implemented for `Arc<T, A>`

error[E0599]: no variant named `ConnectionClose` found for enum `H3Frame`
  --> packages/http3/src/protocols/h3/connection.rs:76:60
   |
76 |             let frame = crate::protocols::frames::H3Frame::ConnectionClose {
   |                                                            ^^^^^^^^^^^^^^^ variant not found in `H3Frame`
   |
  ::: packages/http3/src/protocols/frames.rs:62:1
   |
62 | pub enum H3Frame {
   | ---------------- variant `ConnectionClose` not found here

error[E0277]: `quiche::Connection` doesn't implement `std::fmt::Debug`
   --> packages/http3/src/protocols/h3/connection.rs:226:5
    |
223 | #[derive(Debug)]
    |          ----- in this derive macro expansion
...
226 |     connection: Arc<std::sync::Mutex<quiche::Connection>>,
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `std::fmt::Debug` is not implemented for `quiche::Connection`
    |
    = help: the trait `std::fmt::Debug` is implemented for `Arc<T, A>`

error[E0599]: no variant or associated item named `new` found for enum `http::response::HttpChunk` in the current scope
   --> packages/http3/src/protocols/h3/connection.rs:253:57
    |
253 | ...                   let http_chunk = HttpChunk::new(buffer[..len].to_vec());
    |                                                   ^^^ variant or associated item not found in `http::response::HttpChunk`
    |
   ::: packages/http3/src/http/response.rs:70:1
    |
 70 | pub enum HttpChunk {
    | ------------------ variant or associated item `new` not found for this enum
    |
    = help: items from traits can only be used if the trait is implemented and in scope
    = note: the following traits define an item `new`, perhaps you need to implement one of them:
            candidate #1: `BoundKey`
            candidate #2: `UniformSampler`
            candidate #3: `aws_lc_rs::aead::BoundKey`
            candidate #4: `brotli::enc::hash_to_binary_tree::Allocable`
            candidate #5: `brotli::enc::threading::AnyBoxConstructor`
            candidate #6: `crypto_common::KeyInit`
            candidate #7: `crypto_common::KeyIvInit`
            candidate #8: `digest::VariableOutput`
            candidate #9: `digest::core_api::VariableOutputCore`
            candidate #10: `digest::digest::Digest`
            candidate #11: `hickory_proto::runtime::Executor`
            candidate #12: `parking_lot_core::thread_parker::ThreadParkerT`
            candidate #13: `rand::distr::uniform::UniformSampler`
            candidate #14: `typenum::marker_traits::Bit`

error[E0061]: this function takes 5 arguments but 4 arguments were supplied
    --> packages/http3/src/protocols/h3/connection.rs:313:57
     |
 313 | ...   .unwrap_or_else(|_| quiche::accept(&scid, None, addr, &mut c).unwrap_or_else(|_| panic!("Failed to create error connection")))
     |                           ^^^^^^^^^^^^^^                    ------ argument #4 of type `std::net::SocketAddr` is missing
     |
note: function defined here
    --> /Users/davidmaple/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/quiche-0.24.5/src/lib.rs:1705:8
     |
1705 | pub fn accept(
     |        ^^^^^^
help: provide the argument
     |
 313 |                                     .unwrap_or_else(|_| quiche::accept(&scid, None, addr, /* std::net::SocketAddr */, &mut c).unwrap_or_else(|_| panic!("Failed to create error connection")))
     |                                                                                           +++++++++++++++++++++++++++

error[E0061]: this function takes 5 arguments but 4 arguments were supplied
    --> packages/http3/src/protocols/h3/connection.rs:334:23
     |
 334 |                 match quiche::accept(&scid, None, addr, &mut config) {
     |                       ^^^^^^^^^^^^^^                    ----------- argument #4 of type `std::net::SocketAddr` is missing
     |
note: function defined here
    --> /Users/davidmaple/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/quiche-0.24.5/src/lib.rs:1705:8
     |
1705 | pub fn accept(
     |        ^^^^^^
help: provide the argument
     |
 334 |                 match quiche::accept(&scid, None, addr, /* std::net::SocketAddr */, &mut config) {
     |                                                         +++++++++++++++++++++++++++

error[E0599]: no function or associated item named `from_str` found for struct `HeaderName` in the current scope
    --> packages/http3/src/protocols/h3/connection.rs:457:35
     |
 457 |                 http::HeaderName::from_str(&name_str),
     |                                   ^^^^^^^^ function or associated item not found in `HeaderName`
     |
note: if you're trying to build a new `HeaderName` consider using one of the following associated functions:
      HeaderName::from_bytes
      HeaderName::from_lowercase
      HeaderName::from_static
    --> /Users/davidmaple/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/http-1.3.1/src/header/name.rs:1115:5
     |
1115 |     pub fn from_bytes(src: &[u8]) -> Result<HeaderName, InvalidHeaderName> {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
...
1169 |     pub fn from_lowercase(src: &[u8]) -> Result<HeaderName, InvalidHeaderName> {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
...
1256 |     pub const fn from_static(src: &'static str) -> HeaderName {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
     = help: items from traits can only be used if the trait is in scope
help: trait `FromStr` which provides `from_str` is implemented but not in scope; perhaps you want to import it
     |
   6 + use std::str::FromStr;
     |
help: there is an associated function `from` with a similar name
     |
 457 -                 http::HeaderName::from_str(&name_str),
 457 +                 http::HeaderName::from(&name_str),
     |

error[E0308]: mismatched types
  --> packages/http3/src/protocols/http1/adapter.rs:63:37
   |
63 |         .map_err(|e| HttpError::new(format!("Invalid URI: {}", e)))?;
   |                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `Kind`, found `String`
   |
   = note: this error originates in the macro `format` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0308]: mismatched types
  --> packages/http3/src/protocols/http1/adapter.rs:66:39
   |
66 |         .ok_or_else(|| HttpError::new("No host in URI".to_string()))?
   |                        -------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `Kind`, found `String`
   |                        |
   |                        arguments to this function are incorrect
   |
note: associated function defined here
  --> packages/http3/src/error/types.rs:42:12
   |
42 |     pub fn new(kind: Kind) -> Error {
   |            ^^^ ----------

error[E0308]: mismatched types
  --> packages/http3/src/protocols/http1/adapter.rs:91:37
   |
91 |         .map_err(|e| HttpError::new(format!("Failed to connect to {}: {}", address, e)))?;
   |                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `Kind`, found `String`
   |
   = note: this error originates in the macro `format` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0308]: mismatched types
  --> packages/http3/src/protocols/http1/adapter.rs:95:37
   |
95 |         .map_err(|e| HttpError::new(format!("Failed to set read timeout: {}", e)))?;
   |                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `Kind`, found `String`
   |
   = note: this error originates in the macro `format` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0308]: mismatched types
  --> packages/http3/src/protocols/http1/adapter.rs:98:37
   |
98 |         .map_err(|e| HttpError::new(format!("Failed to set write timeout: {}", e)))?;
   |                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `Kind`, found `String`
   |
   = note: this error originates in the macro `format` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0308]: mismatched types
   --> packages/http3/src/protocols/http1/adapter.rs:137:41
    |
137 |             .map_err(|e| HttpError::new(format!("Invalid header value: {}", e)))?);
    |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `Kind`, found `String`
    |
    = note: this error originates in the macro `format` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0308]: mismatched types
    --> packages/http3/src/protocols/http1/adapter.rs:152:40
     |
 152 |         request_data.extend_from_slice(body);
     |                      ----------------- ^^^^ expected `&[u8]`, found `&RequestBody`
     |                      |
     |                      arguments to this method are incorrect
     |
     = note: expected reference `&[u8]`
                found reference `&http::request::RequestBody`
note: method defined here
    --> /Users/davidmaple/.rustup/toolchains/nightly-aarch64-apple-darwin/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:3261:12
     |
3261 |     pub fn extend_from_slice(&mut self, other: &[T]) {
     |            ^^^^^^^^^^^^^^^^^

error[E0308]: mismatched types
   --> packages/http3/src/protocols/http1/adapter.rs:157:37
    |
157 |         .map_err(|e| HttpError::new(format!("Failed to send request: {}", e)))?;
    |                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `Kind`, found `String`
    |
    = note: this error originates in the macro `format` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0308]: mismatched types
   --> packages/http3/src/protocols/http1/adapter.rs:160:37
    |
160 |         .map_err(|e| HttpError::new(format!("Failed to flush request: {}", e)))?;
    |                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `Kind`, found `String`
    |
    = note: this error originates in the macro `format` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0308]: mismatched types
   --> packages/http3/src/protocols/http1/adapter.rs:176:37
    |
176 |         .map_err(|e| HttpError::new(format!("Failed to read status line: {}", e)))?;
    |                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `Kind`, found `String`
    |
    = note: this error originates in the macro `format` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0308]: mismatched types
   --> packages/http3/src/protocols/http1/adapter.rs:187:41
    |
187 |             .map_err(|e| HttpError::new(format!("Failed to read header: {}", e)))?;
    |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `Kind`, found `String`
    |
    = note: this error originates in the macro `format` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0308]: mismatched types
   --> packages/http3/src/protocols/http1/adapter.rs:227:35
    |
227 |         return Err(HttpError::new("Invalid status line format".to_string()));
    |                    -------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `Kind`, found `String`
    |                    |
    |                    arguments to this function are incorrect
    |
note: associated function defined here
   --> packages/http3/src/error/types.rs:42:12
    |
 42 |     pub fn new(kind: Kind) -> Error {
    |            ^^^ ----------

error[E0308]: mismatched types
   --> packages/http3/src/protocols/http1/adapter.rs:232:37
    |
232 |         .map_err(|e| HttpError::new(format!("Invalid status code: {}", e)))?;
    |                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `Kind`, found `String`
    |
    = note: this error originates in the macro `format` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0308]: mismatched types
   --> packages/http3/src/protocols/http1/adapter.rs:235:37
    |
235 |         .map_err(|e| HttpError::new(format!("Invalid status code value: {}", e)))
    |                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `Kind`, found `String`
    |
    = note: this error originates in the macro `format` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0308]: mismatched types
   --> packages/http3/src/protocols/http1/adapter.rs:255:35
    |
255 | ...                   data: vec![],
    |                             ^^^^^^ expected `Bytes`, found `Vec<_>`
    |
    = note: expected struct `bytes::Bytes`
               found struct `Vec<_>`
    = note: this error originates in the macro `vec` (in Nightly builds, run with -Z macro-backtrace for more info)
help: call `Into::into` on this expression to convert `Vec<_>` into `bytes::Bytes`
    |
255 |                             data: vec![].into(),
    |                                         +++++++

error[E0308]: mismatched types
   --> packages/http3/src/protocols/http1/adapter.rs:264:39
    |
264 |                         total_read += bytes_read;
    |                                       ^^^^^^^^^^ expected `u64`, found `usize`

error[E0277]: cannot add-assign `usize` to `u64`
   --> packages/http3/src/protocols/http1/adapter.rs:264:36
    |
264 |                         total_read += bytes_read;
    |                                    ^^ no implementation for `u64 += usize`
    |
    = help: the trait `AddAssign<usize>` is not implemented for `u64`
    = help: the following other types implement trait `AddAssign<Rhs>`:
              `u64` implements `AddAssign<&u64>`
              `u64` implements `AddAssign<zerocopy::byteorder::U64<O>>`
              `u64` implements `AddAssign`

error[E0308]: mismatched types
   --> packages/http3/src/protocols/http1/adapter.rs:267:43
    |
267 | ...                   total_read >= expected_length
    |                       ----------    ^^^^^^^^^^^^^^^ expected `u64`, found `usize`
    |                       |
    |                       expected because this is `u64`
    |
help: you can convert a `usize` to a `u64` and panic if the converted value doesn't fit
    |
267 |                             total_read >= expected_length.try_into().unwrap()
    |                                                          ++++++++++++++++++++

error[E0308]: mismatched types
   --> packages/http3/src/protocols/http1/adapter.rs:273:35
    |
273 | ...                   data: buffer[..bytes_read].to_vec(),
    |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `Bytes`, found `Vec<u8>`
    |
    = note: expected struct `bytes::Bytes`
               found struct `Vec<u8>`
help: call `Into::into` on this expression to convert `Vec<u8>` into `bytes::Bytes`
    |
273 |                             data: buffer[..bytes_read].to_vec().into(),
    |                                                                +++++++

error[E0308]: mismatched types
   --> packages/http3/src/protocols/http1/adapter.rs:274:50
    |
274 | ...                   offset: total_read - bytes_read,
    |                                            ^^^^^^^^^^ expected `u64`, found `usize`

error[E0277]: cannot subtract `usize` from `u64`
   --> packages/http3/src/protocols/http1/adapter.rs:274:48
    |
274 | ...                   offset: total_read - bytes_read,
    |                                          ^ no implementation for `u64 - usize`
    |
    = help: the trait `Sub<usize>` is not implemented for `u64`
    = help: the following other types implement trait `Sub<Rhs>`:
              `&u64` implements `Sub<&BigInt>`
              `&u64` implements `Sub<&BigUint>`
              `&u64` implements `Sub<BigInt>`
              `&u64` implements `Sub<BigUint>`
              `&u64` implements `Sub<u64>`
              `&u64` implements `Sub`
              `u64` implements `Sub<&BigInt>`
              `u64` implements `Sub<&BigUint>`
            and 5 others

error[E0308]: mismatched types
   --> packages/http3/src/protocols/http1/adapter.rs:288:35
    |
288 | ...                   data: vec![],
    |                             ^^^^^^ expected `Bytes`, found `Vec<_>`
    |
    = note: expected struct `bytes::Bytes`
               found struct `Vec<_>`
    = note: this error originates in the macro `vec` (in Nightly builds, run with -Z macro-backtrace for more info)
help: call `Into::into` on this expression to convert `Vec<_>` into `bytes::Bytes`
    |
288 |                             data: vec![].into(),
    |                                         +++++++

error[E0308]: mismatched types
    --> packages/http3/src/protocols/quiche/streaming.rs:217:51
     |
 217 |         match quiche::connect(Some(&server_name), &scid_owned, local, peer, &mut config) {
     |               ---------------                     ^^^^^^^^^^^ expected `&ConnectionId<'_>`, found `&Vec<u8>`
     |               |
     |               arguments to this function are incorrect
     |
     = note: expected reference `&ConnectionId<'_>`
                found reference `&Vec<u8>`
note: function defined here
    --> /Users/davidmaple/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/quiche-0.24.5/src/lib.rs:1748:8
     |
1748 | pub fn connect(
     |        ^^^^^^^

error[E0308]: arguments to this function are incorrect
    --> packages/http3/src/protocols/quiche/streaming.rs:250:15
     |
 250 |         match quiche::accept(
     |               ^^^^^^^^^^^^^^
     |
note: expected `&ConnectionId<'_>`, found `&Vec<u8>`
    --> packages/http3/src/protocols/quiche/streaming.rs:251:13
     |
 251 |             &scid_owned,
     |             ^^^^^^^^^^^
     = note: expected reference `&ConnectionId<'_>`
                found reference `&Vec<u8>`
note: expected `Option<&ConnectionId<'_>>`, found `Option<&[u8]>`
    --> packages/http3/src/protocols/quiche/streaming.rs:252:13
     |
 252 |             odcid_owned.as_deref(),
     |             ^^^^^^^^^^^^^^^^^^^^^^
     = note: expected enum `std::option::Option<&ConnectionId<'_>>`
                found enum `std::option::Option<&[u8]>`
note: function defined here
    --> /Users/davidmaple/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/quiche-0.24.5/src/lib.rs:1705:8
     |
1705 | pub fn accept(
     |        ^^^^^^

error[E0308]: mismatched types
   --> packages/http3/src/protocols/quiche/streaming.rs:275:5
    |
274 |   pub fn read_readable_streams(mut connection: Connection) -> AsyncStream<QuicheReadableChunk, 1024> {
    |                                                               -------------------------------------- expected `fluent_ai_async::AsyncStream<QuicheConnectionEvent>` because of return type
275 | /     AsyncStream::with_channel(move |sender| {
276 | |         let mut readable_streams = Vec::new();
277 | |         let mut writable_streams = Vec::new();
...   |
302 | |     })
    | |______^ expected `AsyncStream<QuicheConnectionEvent>`, found `AsyncStream<QuicheConnectionChunk, _>`
    |
    = note: expected struct `fluent_ai_async::AsyncStream<QuicheConnectionEvent, 1024>`
               found struct `fluent_ai_async::AsyncStream<QuicheConnectionChunk, _>`

error[E0308]: mismatched types
    --> packages/http3/src/protocols/quiche/streaming.rs:443:17
     |
 442 |             match connection.recv(
     |                              ---- arguments to this method are incorrect
 443 |                 &packet,
     |                 ^^^^^^^ types differ in mutability
     |
     = note: expected mutable reference `&mut [u8]`
                        found reference `&bytes::Bytes`
note: method defined here
    --> /Users/davidmaple/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/quiche-0.24.5/src/lib.rs:2704:12
     |
2704 |     pub fn recv(&mut self, buf: &mut [u8], info: RecvInfo) -> Result<usize> {
     |            ^^^^

error[E0277]: `quiche::Connection` doesn't implement `std::fmt::Debug`
   --> packages/http3/src/protocols/quiche/streaming.rs:556:5
    |
554 | #[derive(Debug)]
    |          ----- in this derive macro expansion
555 | pub struct QuicheConnectionWrapper {
556 |     inner: Connection,
    |     ^^^^^^^^^^^^^^^^^ the trait `std::fmt::Debug` is not implemented for `quiche::Connection`

error[E0599]: no method named `clone` found for struct `QuicheConnectionWrapper` in the current scope
   --> packages/http3/src/protocols/quiche/streaming.rs:672:41
    |
555 | pub struct QuicheConnectionWrapper {
    | ---------------------------------- method `clone` not found for this struct
...
672 |             connection: self.connection.clone(),
    |                                         ^^^^^ method not found in `QuicheConnectionWrapper`
    |
    = help: items from traits can only be used if the trait is implemented and in scope
    = note: the following trait defines an item `clone`, perhaps you need to implement it:
            candidate #1: `Clone`

error[E0308]: mismatched types
  --> packages/http3/src/protocols/response_converter.rs:76:47
   |
76 | ...                   data: body_data,
   |                             ^^^^^^^^^ expected `Bytes`, found `Vec<u8>`
   |
   = note: expected struct `bytes::Bytes`
              found struct `Vec<u8>`
help: call `Into::into` on this expression to convert `Vec<u8>` into `bytes::Bytes`
   |
76 |                                         data: body_data.into(),
   |                                                        +++++++

error[E0308]: mismatched types
   --> packages/http3/src/protocols/response_converter.rs:103:35
    |
103 | ...                   data: vec![],
    |                             ^^^^^^ expected `Bytes`, found `Vec<_>`
    |
    = note: expected struct `bytes::Bytes`
               found struct `Vec<_>`
    = note: this error originates in the macro `vec` (in Nightly builds, run with -Z macro-backtrace for more info)
help: call `Into::into` on this expression to convert `Vec<_>` into `bytes::Bytes`
    |
103 |                             data: vec![].into(),
    |                                         +++++++

error[E0308]: mismatched types
   --> packages/http3/src/protocols/response_converter.rs:114:35
    |
114 | ...                   data: vec![],
    |                             ^^^^^^ expected `Bytes`, found `Vec<_>`
    |
    = note: expected struct `bytes::Bytes`
               found struct `Vec<_>`
    = note: this error originates in the macro `vec` (in Nightly builds, run with -Z macro-backtrace for more info)
help: call `Into::into` on this expression to convert `Vec<_>` into `bytes::Bytes`
    |
114 |                             data: vec![].into(),
    |                                         +++++++

error[E0308]: mismatched types
   --> packages/http3/src/protocols/response_converter.rs:125:35
    |
125 | ...                   data: error_msg.into_bytes(),
    |                             ^^^^^^^^^^^^^^^^^^^^^^ expected `Bytes`, found `Vec<u8>`
    |
    = note: expected struct `bytes::Bytes`
               found struct `Vec<u8>`
help: call `Into::into` on this expression to convert `Vec<u8>` into `bytes::Bytes`
    |
125 |                             data: error_msg.into_bytes().into(),
    |                                                         +++++++

error[E0308]: arguments to this function are incorrect
   --> packages/http3/src/protocols/response_converter.rs:144:5
    |
144 |       HttpResponse::new(
    |       ^^^^^^^^^^^^^^^^^
145 |           status,
    |           ------ unexpected argument #1 of type `AtomicU16`
146 |           headers,
    |           -------
    |           |
    |  _________unexpected argument #2 of type `http::HeaderMap`
    | |
147 | |         body_stream,
    | |         ----------- unexpected argument #3 of type `fluent_ai_async::AsyncStream<HttpBodyChunk, _>`
148 | |         trailers_stream,
    | |_______________________- three arguments of type `fluent_ai_async::AsyncStream<HttpBodyChunk>`, `fluent_ai_async::AsyncStream<HttpHeader, 64>`, and `http::Version` are missing
    |
note: associated function defined here
   --> packages/http3/src/http/response.rs:167:12
    |
167 |     pub fn new(
    |            ^^^
168 |         headers_stream: AsyncStream<HttpHeader, 256>,
169 |         body_stream: AsyncStream<HttpBodyChunk, 1024>,
    |         ---------------------------------------------
170 |         trailers_stream: AsyncStream<HttpHeader, 64>,
    |         --------------------------------------------
171 |         version: Version,
    |         ----------------
help: did you mean
    |
144 ~     HttpResponse::new(
145 +         trailers_stream,
146 +         /* fluent_ai_async::AsyncStream<HttpBodyChunk> */,
147 +         /* fluent_ai_async::AsyncStream<HttpHeader, 64> */,
148 +         /* http::Version */,
149 +         stream_id,
150 +     )
    |

error[E0599]: no function or associated item named `default` found for struct `Connector` in the current scope
   --> packages/http3/src/protocols/strategy.rs:109:44
    |
109 |             let mut connector = Connector::default();
    |                                            ^^^^^^^ function or associated item not found in `Connector`
    |
   ::: packages/http3/src/connect/types/connector.rs:10:1
    |
 10 | pub struct Connector {
    | -------------------- function or associated item `default` not found for this struct
    |
    = help: items from traits can only be used if the trait is implemented and in scope
    = note: the following traits define an item `default`, perhaps you need to implement one of them:
            candidate #1: `std::default::Default`
            candidate #2: `tinyvec::Array`

error[E0599]: no method named `process_http2_request` found for reference `&HttpProtocolStrategy` in the current scope
   --> packages/http3/src/protocols/strategy.rs:152:42
    |
152 |                 let http_response = self.process_http2_request(&h2_connection, &request)?;
    |                                          ^^^^^^^^^^^^^^^^^^^^^ method not found in `&HttpProtocolStrategy`

error[E0599]: no method named `process_http3_request` found for reference `&HttpProtocolStrategy` in the current scope
   --> packages/http3/src/protocols/strategy.rs:157:42
    |
157 |                 let http_response = self.process_http3_request(&h3_connection, &request)?;
    |                                          ^^^^^^^^^^^^^^^^^^^^^ method not found in `&HttpProtocolStrategy`

error[E0308]: mismatched types
   --> packages/http3/src/protocols/strategy.rs:185:41
    |
185 |                     quiche_config: Some(convert_h3_config_to_quiche(h3_config).ok()),
    |                                    ---- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `Config`, found `Option<Config>`
    |                                    |
    |                                    arguments to this enum variant are incorrect
    |
    = note: expected struct `quiche::Config`
                 found enum `std::option::Option<quiche::Config>`
help: the type constructed contains `std::option::Option<quiche::Config>` due to the type of the argument passed
   --> packages/http3/src/protocols/strategy.rs:185:36
    |
185 |                     quiche_config: Some(convert_h3_config_to_quiche(h3_config).ok()),
    |                                    ^^^^^-------------------------------------------^
    |                                         |
    |                                         this argument influences the type of `Some`
note: tuple variant defined here
   --> /Users/davidmaple/.rustup/toolchains/nightly-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/option.rs:601:5
    |
601 |     Some(#[stable(feature = "rust1", since = "1.0.0")] T),
    |     ^^^^
help: consider using `Option::expect` to unwrap the `std::option::Option<quiche::Config>` value, panicking if the value is an `Option::None`
    |
185 |                     quiche_config: Some(convert_h3_config_to_quiche(h3_config).ok().expect("REASON")),
    |                                                                                    +++++++++++++++++

error[E0308]: mismatched types
   --> packages/http3/src/protocols/strategy.rs:197:41
    |
197 |                     quiche_config: Some(convert_quiche_config_to_quiche(quiche_config).ok()),
    |                                    ---- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `Config`, found `Option<Config>`
    |                                    |
    |                                    arguments to this enum variant are incorrect
    |
    = note: expected struct `quiche::Config`
                 found enum `std::option::Option<quiche::Config>`
help: the type constructed contains `std::option::Option<quiche::Config>` due to the type of the argument passed
   --> packages/http3/src/protocols/strategy.rs:197:36
    |
197 |                     quiche_config: Some(convert_quiche_config_to_quiche(quiche_config).ok()),
    |                                    ^^^^^---------------------------------------------------^
    |                                         |
    |                                         this argument influences the type of `Some`
note: tuple variant defined here
   --> /Users/davidmaple/.rustup/toolchains/nightly-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/option.rs:601:5
    |
601 |     Some(#[stable(feature = "rust1", since = "1.0.0")] T),
    |     ^^^^
help: consider using `Option::expect` to unwrap the `std::option::Option<quiche::Config>` value, panicking if the value is an `Option::None`
    |
197 |                     quiche_config: Some(convert_quiche_config_to_quiche(quiche_config).ok().expect("REASON")),
    |                                                                                            +++++++++++++++++

error[E0308]: mismatched types
   --> packages/http3/src/protocols/strategy.rs:306:21
    |
302 |                 Ok(crate::http::response::HttpResponse::from_http2_response(
    |                    -------------------------------------------------------- arguments to this function are incorrect
...
306 |                     self.create_real_trailers_stream(), // Real trailers
    |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `AsyncStream<HttpHeader, 64>`, found `AsyncStream<HeaderMap>`
    |
    = note: expected struct `fluent_ai_async::AsyncStream<HttpHeader, 64>`
               found struct `fluent_ai_async::AsyncStream<http::HeaderMap, 1024>`
note: associated function defined here
   --> packages/http3/src/http/response.rs:270:12
    |
270 |     pub fn from_http2_response(
    |            ^^^^^^^^^^^^^^^^^^^
...
274 |         trailers_stream: AsyncStream<HttpHeader, 64>,
    |         --------------------------------------------

error[E0277]: the trait bound `http::HeaderMap: fluent_ai_async::prelude::MessageChunk` is not satisfied
   --> packages/http3/src/protocols/strategy.rs:434:9
    |
434 | /         AsyncStream::with_channel(move |sender| {
435 | |             // Real implementation would poll trailers from h2::RecvStream
436 | |             // Most HTTP/2 responses don't have trailers, so emit empty HeaderMap
437 | |             emit!(sender, http::HeaderMap::new());
438 | |         })
    | |__________^ the trait `fluent_ai_async::prelude::MessageChunk` is not implemented for `http::HeaderMap`
    |
note: there are multiple different versions of crate `sugars_builders` in the dependency graph
   --> /Users/davidmaple/.cargo/git/checkouts/cyrup-sugars-291ac2b5c478a1ed/150c82d/packages/builders/src/chunk_handler.rs:8:1
    |
  8 | pub trait MessageChunk: Sized {
    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    | |
    | this is the required trait
    | this is the found trait
    |
   ::: packages/http3/src/builder/execution.rs:4:5
    |
  4 | use fluent_ai_async::{AsyncStream, prelude::MessageChunk};
    |     --------------- one version of crate `sugars_builders` used here, as a dependency of crate `cyrup_sugars`
    |
   ::: /Users/davidmaple/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/http-1.3.1/src/header/map.rs:45:1
    |
 45 | pub struct HeaderMap<T = HeaderValue> {
    | ------------------------------------- this type doesn't implement the required trait
    = help: you can use `cargo tree` to explore your dependency tree
note: required by a bound in `fluent_ai_async::stream::<impl fluent_ai_async::AsyncStream<T, CAP>>::with_channel`
   --> /Volumes/samsung_t9/fluent-ai/packages/async-stream/src/stream/mod.rs:20:8
    |
 20 |     T: MessageChunk + Send + Default + 'static,
    |        ^^^^^^^^^^^^ required by this bound in `fluent_ai_async::stream::<impl AsyncStream<T, CAP>>::with_channel`
...
 27 |     pub fn with_channel<F>(producer: F) -> Self
    |            ------------ required by a bound in this associated function

error[E0277]: the trait bound `http::HeaderMap: fluent_ai_async::prelude::MessageChunk` is not satisfied
   --> packages/http3/src/protocols/strategy.rs:437:13
    |
437 |             emit!(sender, http::HeaderMap::new());
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `fluent_ai_async::prelude::MessageChunk` is not implemented for `http::HeaderMap`
    |
note: there are multiple different versions of crate `sugars_builders` in the dependency graph
   --> /Users/davidmaple/.cargo/git/checkouts/cyrup-sugars-291ac2b5c478a1ed/150c82d/packages/builders/src/chunk_handler.rs:8:1
    |
  8 | pub trait MessageChunk: Sized {
    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    | |
    | this is the required trait
    | this is the found trait
    |
   ::: packages/http3/src/builder/execution.rs:4:5
    |
  4 | use fluent_ai_async::{AsyncStream, prelude::MessageChunk};
    |     --------------- one version of crate `sugars_builders` used here, as a dependency of crate `cyrup_sugars`
    |
   ::: /Users/davidmaple/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/http-1.3.1/src/header/map.rs:45:1
    |
 45 | pub struct HeaderMap<T = HeaderValue> {
    | ------------------------------------- this type doesn't implement the required trait
    = help: you can use `cargo tree` to explore your dependency tree
note: required by a bound in `AsyncStreamSender::<T, CAP>::send`
   --> /Volumes/samsung_t9/fluent-ai/packages/async-stream/src/stream/sender.rs:19:8
    |
 19 |     T: MessageChunk + Send + Default + 'static,
    |        ^^^^^^^^^^^^ required by this bound in `AsyncStreamSender::<T, CAP>::send`
...
 26 |     pub fn send(&self, value: T) -> Result<(), T> {
    |            ---- required by a bound in this associated function
    = note: this error originates in the macro `emit` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0308]: mismatched types
   --> packages/http3/src/protocols/strategy.rs:466:37
    |
466 | ...                   data,
    |                       ^^^^ expected `Bytes`, found `Vec<u8>`
    |
    = note: expected struct `bytes::Bytes`
               found struct `Vec<u8>`
help: call `Into::into` on this expression to convert `Vec<u8>` into `bytes::Bytes`
    |
466 |                                     data: data.into(),
    |                                     +++++     +++++++

error[E0308]: mismatched types
   --> packages/http3/src/protocols/strategy.rs:481:37
    |
481 | ...                   data,
    |                       ^^^^ expected `Bytes`, found `Vec<u8>`
    |
    = note: expected struct `bytes::Bytes`
               found struct `Vec<u8>`
help: call `Into::into` on this expression to convert `Vec<u8>` into `bytes::Bytes`
    |
481 |                                     data: data.into(),
    |                                     +++++     +++++++

error[E0277]: `&fluent_ai_async::AsyncStream<http::response::HttpChunk>` is not an iterator
   --> packages/http3/src/protocols/strategy.rs:560:22
    |
560 |         for chunk in chunk_stream {
    |                      ^^^^^^^^^^^^ `&fluent_ai_async::AsyncStream<http::response::HttpChunk>` is not an iterator
    |
    = help: the trait `Iterator` is not implemented for `&fluent_ai_async::AsyncStream<http::response::HttpChunk>`
    = help: the trait `IntoIterator` is implemented for `fluent_ai_async::AsyncStream<T, CAP>`
    = note: required for `&fluent_ai_async::AsyncStream<http::response::HttpChunk>` to implement `IntoIterator`

error[E0560]: struct `HttpBodyChunk` has no field named `encoding`
   --> packages/http3/src/protocols/strategy.rs:623:25
    |
623 |                         encoding: None,
    |                         ^^^^^^^^ `HttpBodyChunk` does not have this field
    |
    = note: available fields are: `is_final`

error[E0560]: struct `HttpBodyChunk` has no field named `content_type`
   --> packages/http3/src/protocols/strategy.rs:624:25
    |
624 |                         content_type: None,
    |                         ^^^^^^^^^^^^ `HttpBodyChunk` does not have this field
    |
    = note: available fields are: `is_final`

error[E0609]: no field `enable_0rtt` on type `&QuicheConfig`
    --> packages/http3/src/protocols/strategy.rs:1023:22
     |
1023 |     if quiche_config.enable_0rtt {
     |                      ^^^^^^^^^^^ unknown field
     |
     = note: available fields are: `max_idle_timeout`, `initial_max_data`, `initial_max_stream_data_bidi_local`, `initial_max_stream_data_bidi_remote`, `initial_max_stream_data_uni` ... and 8 others

error[E0277]: `ConnectionManager` doesn't implement `std::fmt::Debug`
  --> packages/http3/src/protocols/transport.rs:31:5
   |
29 | #[derive(Debug)]
   |          ----- in this derive macro expansion
30 | pub struct TransportManager {
31 |     connection_manager: ConnectionManager,
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `std::fmt::Debug` is not implemented for `ConnectionManager`
   |
   = note: add `#[derive(Debug)]` to `ConnectionManager` or manually `impl std::fmt::Debug for ConnectionManager`

error[E0277]: `quiche::Config` doesn't implement `std::fmt::Debug`
  --> packages/http3/src/protocols/transport.rs:43:5
   |
37 | #[derive(Debug, Clone)]
   |          ----- in this derive macro expansion
...
43 |     pub quiche_config: Option<Config>,
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `std::fmt::Debug` is not implemented for `quiche::Config`
   |
   = help: the trait `std::fmt::Debug` is implemented for `std::option::Option<T>`

error[E0277]: the trait bound `quiche::Config: Clone` is not satisfied
  --> packages/http3/src/protocols/transport.rs:43:5
   |
37 | #[derive(Debug, Clone)]
   |                 ----- in this derive macro expansion
...
43 |     pub quiche_config: Option<Config>,
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `Clone` is not implemented for `quiche::Config`
   |
   = note: required for `std::option::Option<quiche::Config>` to implement `Clone`

warning: use of deprecated associated function `protocols::connection::Connection::new_h3`: Use new_h3_with_addr for real network connections
   --> packages/http3/src/protocols/transport.rs:108:42
    |
108 |             let connection = Connection::new_h3(true);
    |                                          ^^^^^^

error[E0277]: `protocols::connection::Connection` doesn't implement `std::fmt::Debug`
   --> packages/http3/src/protocols/transport.rs:163:5
    |
159 | #[derive(Debug)]
    |          ----- in this derive macro expansion
...
163 |     pub connection: Connection,
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `std::fmt::Debug` is not implemented for `protocols::connection::Connection`
    |
    = note: add `#[derive(Debug)]` to `protocols::connection::Connection` or manually `impl std::fmt::Debug for protocols::connection::Connection`

warning: use of deprecated associated function `protocols::connection::Connection::new_h2`: Use new_h2_with_addr for real network connections
   --> packages/http3/src/protocols/transport.rs:300:50
    |
300 |                 TransportType::H2 => Connection::new_h2(true),
    |                                                  ^^^^^^

warning: use of deprecated associated function `protocols::connection::Connection::new_h3`: Use new_h3_with_addr for real network connections
   --> packages/http3/src/protocols/transport.rs:301:50
    |
301 |                 TransportType::H3 => Connection::new_h3(true),
    |                                                  ^^^^^^

warning: use of deprecated associated function `protocols::connection::Connection::new_h3`: Use new_h3_with_addr for real network connections
   --> packages/http3/src/protocols/transport.rs:302:52
    |
302 |                 TransportType::Auto => Connection::new_h3(true), // Default to H3
    |                                                    ^^^^^^

error[E0277]: the trait bound `TransportConnection: std::default::Default` is not satisfied
   --> packages/http3/src/protocols/transport.rs:298:9
    |
298 | /         AsyncStream::with_channel(move |sender| {
299 | |             let connection = match transport_type {
300 | |                 TransportType::H2 => Connection::new_h2(true),
301 | |                 TransportType::H3 => Connection::new_h3(true),
...   |
313 | |             emit!(sender, transport_conn);
314 | |         })
    | |__________^ the trait `std::default::Default` is not implemented for `TransportConnection`
    |
note: required by a bound in `fluent_ai_async::stream::<impl fluent_ai_async::AsyncStream<T, CAP>>::with_channel`
   --> /Volumes/samsung_t9/fluent-ai/packages/async-stream/src/stream/mod.rs:20:30
    |
 20 |     T: MessageChunk + Send + Default + 'static,
    |                              ^^^^^^^ required by this bound in `fluent_ai_async::stream::<impl AsyncStream<T, CAP>>::with_channel`
...
 27 |     pub fn with_channel<F>(producer: F) -> Self
    |            ------------ required by a bound in this associated function

error[E0277]: the trait bound `TransportConnection: std::default::Default` is not satisfied
   --> packages/http3/src/protocols/transport.rs:313:13
    |
313 |             emit!(sender, transport_conn);
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `std::default::Default` is not implemented for `TransportConnection`
    |
note: required by a bound in `AsyncStreamSender::<T, CAP>::send`
   --> /Volumes/samsung_t9/fluent-ai/packages/async-stream/src/stream/sender.rs:19:30
    |
 19 |     T: MessageChunk + Send + Default + 'static,
    |                              ^^^^^^^ required by this bound in `AsyncStreamSender::<T, CAP>::send`
...
 26 |     pub fn send(&self, value: T) -> Result<(), T> {
    |            ---- required by a bound in this associated function
    = note: this error originates in the macro `emit` (in Nightly builds, run with -Z macro-backtrace for more info)

warning: use of deprecated associated function `protocols::connection::Connection::new_h2`: Use new_h2_with_addr for real network connections
   --> packages/http3/src/protocols/transport.rs:323:42
    |
323 |             let connection = Connection::new_h2(true);
    |                                          ^^^^^^

error[E0277]: the trait bound `TransportConnection: std::default::Default` is not satisfied
   --> packages/http3/src/protocols/transport.rs:322:9
    |
322 | /         AsyncStream::with_channel(move |sender| {
323 | |             let connection = Connection::new_h2(true);
324 | |             let config = TransportConfig {
325 | |                 transport_type: TransportType::H2,
...   |
337 | |             emit!(sender, transport_conn);
338 | |         })
    | |__________^ the trait `std::default::Default` is not implemented for `TransportConnection`
    |
note: required by a bound in `fluent_ai_async::stream::<impl fluent_ai_async::AsyncStream<T, CAP>>::with_channel`
   --> /Volumes/samsung_t9/fluent-ai/packages/async-stream/src/stream/mod.rs:20:30
    |
 20 |     T: MessageChunk + Send + Default + 'static,
    |                              ^^^^^^^ required by this bound in `fluent_ai_async::stream::<impl AsyncStream<T, CAP>>::with_channel`
...
 27 |     pub fn with_channel<F>(producer: F) -> Self
    |            ------------ required by a bound in this associated function

error[E0277]: the trait bound `TransportConnection: std::default::Default` is not satisfied
   --> packages/http3/src/protocols/transport.rs:337:13
    |
337 |             emit!(sender, transport_conn);
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `std::default::Default` is not implemented for `TransportConnection`
    |
note: required by a bound in `AsyncStreamSender::<T, CAP>::send`
   --> /Volumes/samsung_t9/fluent-ai/packages/async-stream/src/stream/sender.rs:19:30
    |
 19 |     T: MessageChunk + Send + Default + 'static,
    |                              ^^^^^^^ required by this bound in `AsyncStreamSender::<T, CAP>::send`
...
 26 |     pub fn send(&self, value: T) -> Result<(), T> {
    |            ---- required by a bound in this associated function
    = note: this error originates in the macro `emit` (in Nightly builds, run with -Z macro-backtrace for more info)

warning: use of deprecated associated function `protocols::connection::Connection::new_h3`: Use new_h3_with_addr for real network connections
   --> packages/http3/src/protocols/transport.rs:347:42
    |
347 |             let connection = Connection::new_h3(true);
    |                                          ^^^^^^

error[E0277]: the trait bound `TransportConnection: std::default::Default` is not satisfied
   --> packages/http3/src/protocols/transport.rs:346:9
    |
346 | /         AsyncStream::with_channel(move |sender| {
347 | |             let connection = Connection::new_h3(true);
348 | |             let mut config = TransportConfig {
349 | |                 transport_type: TransportType::H3,
...   |
362 | |             emit!(sender, transport_conn);
363 | |         })
    | |__________^ the trait `std::default::Default` is not implemented for `TransportConnection`
    |
note: required by a bound in `fluent_ai_async::stream::<impl fluent_ai_async::AsyncStream<T, CAP>>::with_channel`
   --> /Volumes/samsung_t9/fluent-ai/packages/async-stream/src/stream/mod.rs:20:30
    |
 20 |     T: MessageChunk + Send + Default + 'static,
    |                              ^^^^^^^ required by this bound in `fluent_ai_async::stream::<impl AsyncStream<T, CAP>>::with_channel`
...
 27 |     pub fn with_channel<F>(producer: F) -> Self
    |            ------------ required by a bound in this associated function

error[E0277]: the trait bound `TransportConnection: std::default::Default` is not satisfied
   --> packages/http3/src/protocols/transport.rs:362:13
    |
362 |             emit!(sender, transport_conn);
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `std::default::Default` is not implemented for `TransportConnection`
    |
note: required by a bound in `AsyncStreamSender::<T, CAP>::send`
   --> /Volumes/samsung_t9/fluent-ai/packages/async-stream/src/stream/sender.rs:19:30
    |
 19 |     T: MessageChunk + Send + Default + 'static,
    |                              ^^^^^^^ required by this bound in `AsyncStreamSender::<T, CAP>::send`
...
 26 |     pub fn send(&self, value: T) -> Result<(), T> {
    |            ---- required by a bound in this associated function
    = note: this error originates in the macro `emit` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0599]: no variant or associated item named `bad_chunk` found for enum `H2Frame` in the current scope
  --> packages/http3/src/protocols/wire.rs:41:34
   |
41 |                         H2Frame::bad_chunk(format!(
   |                                  ^^^^^^^^^ variant or associated item not found in `H2Frame`
   |
  ::: packages/http3/src/protocols/frames.rs:11:1
   |
11 | pub enum H2Frame {
   | ---------------- variant or associated item `bad_chunk` not found for this enum
   |
   = help: items from traits can only be used if the trait is implemented and in scope
   = note: the following traits define an item `bad_chunk`, perhaps you need to implement one of them:
           candidate #1: `fluent_ai_async::prelude::MessageChunk`
           candidate #2: `sugars_builders::MessageChunk`

error[E0308]: mismatched types
  --> packages/http3/src/protocols/wire.rs:57:29
   |
57 | ...                   stream_id,
   |                       ^^^^^^^^^ expected `u64`, found `u32`
   |
help: you can convert a `u32` to a `u64`
   |
57 |                             stream_id: stream_id.into(),
   |                             ++++++++++          +++++++

error[E0308]: mismatched types
  --> packages/http3/src/protocols/wire.rs:66:29
   |
66 | ...                   stream_id,
   |                       ^^^^^^^^^ expected `u64`, found `u32`
   |
help: you can convert a `u32` to a `u64`
   |
66 |                             stream_id: stream_id.into(),
   |                             ++++++++++          +++++++

error[E0308]: mismatched types
  --> packages/http3/src/protocols/wire.rs:67:29
   |
67 | ...                   headers,
   |                       ^^^^^^^ expected `Vec<(String, String)>`, found `HashMap<String, String>`
   |
   = note: expected struct `Vec<(std::string::String, std::string::String)>`
              found struct `HashMap<std::string::String, std::string::String>`

error[E0308]: mismatched types
  --> packages/http3/src/protocols/wire.rs:84:33
   |
84 | ...                   stream_id,
   |                       ^^^^^^^^^ expected `u64`, found `u32`
   |
help: you can convert a `u32` to a `u64`
   |
84 |                                 stream_id: stream_id.into(),
   |                                 ++++++++++          +++++++

error[E0308]: mismatched types
  --> packages/http3/src/protocols/wire.rs:85:33
   |
85 | ...                   dependency,
   |                       ^^^^^^^^^^ expected `u64`, found `u32`
   |
help: you can convert a `u32` to a `u64`
   |
85 |                                 dependency: dependency.into(),
   |                                 +++++++++++           +++++++

error[E0599]: no variant or associated item named `bad_chunk` found for enum `H2Frame` in the current scope
  --> packages/http3/src/protocols/wire.rs:90:38
   |
90 | ...                   H2Frame::bad_chunk("Invalid PRIORITY frame".to_string())
   |                                ^^^^^^^^^ variant or associated item not found in `H2Frame`
   |
  ::: packages/http3/src/protocols/frames.rs:11:1
   |
11 | pub enum H2Frame {
   | ---------------- variant or associated item `bad_chunk` not found for this enum
   |
   = help: items from traits can only be used if the trait is implemented and in scope
   = note: the following traits define an item `bad_chunk`, perhaps you need to implement one of them:
           candidate #1: `fluent_ai_async::prelude::MessageChunk`
           candidate #2: `sugars_builders::MessageChunk`

error[E0308]: mismatched types
   --> packages/http3/src/protocols/wire.rs:100:33
    |
100 | ...                   stream_id,
    |                       ^^^^^^^^^ expected `u64`, found `u32`
    |
help: you can convert a `u32` to a `u64`
    |
100 |                                 stream_id: stream_id.into(),
    |                                 ++++++++++          +++++++

error[E0599]: no variant or associated item named `bad_chunk` found for enum `H2Frame` in the current scope
   --> packages/http3/src/protocols/wire.rs:104:38
    |
104 | ...                   H2Frame::bad_chunk("Invalid RST_STREAM frame".to_string())
    |                                ^^^^^^^^^ variant or associated item not found in `H2Frame`
    |
   ::: packages/http3/src/protocols/frames.rs:11:1
    |
 11 | pub enum H2Frame {
    | ---------------- variant or associated item `bad_chunk` not found for this enum
    |
    = help: items from traits can only be used if the trait is implemented and in scope
    = note: the following traits define an item `bad_chunk`, perhaps you need to implement one of them:
            candidate #1: `fluent_ai_async::prelude::MessageChunk`
            candidate #2: `sugars_builders::MessageChunk`

error[E0308]: mismatched types
   --> packages/http3/src/protocols/wire.rs:110:45
    |
110 |                         H2Frame::Settings { settings }
    |                                             ^^^^^^^^ expected `Vec<(u16, u32)>`, found `HashMap<u16, u32>`
    |
    = note: expected struct `Vec<(u16, u32)>`
               found struct `HashMap<u16, u32>`

error[E0599]: no variant or associated item named `bad_chunk` found for enum `H2Frame` in the current scope
   --> packages/http3/src/protocols/wire.rs:119:38
    |
119 | ...                   H2Frame::bad_chunk("Invalid PING frame".to_string())
    |                                ^^^^^^^^^ variant or associated item not found in `H2Frame`
    |
   ::: packages/http3/src/protocols/frames.rs:11:1
    |
 11 | pub enum H2Frame {
    | ---------------- variant or associated item `bad_chunk` not found for this enum
    |
    = help: items from traits can only be used if the trait is implemented and in scope
    = note: the following traits define an item `bad_chunk`, perhaps you need to implement one of them:
            candidate #1: `fluent_ai_async::prelude::MessageChunk`
            candidate #2: `sugars_builders::MessageChunk`

error[E0308]: mismatched types
   --> packages/http3/src/protocols/wire.rs:136:33
    |
136 | ...                   last_stream_id,
    |                       ^^^^^^^^^^^^^^ expected `u64`, found `u32`
    |
help: you can convert a `u32` to a `u64`
    |
136 |                                 last_stream_id: last_stream_id.into(),
    |                                 +++++++++++++++               +++++++

error[E0599]: no variant or associated item named `bad_chunk` found for enum `H2Frame` in the current scope
   --> packages/http3/src/protocols/wire.rs:141:38
    |
141 | ...                   H2Frame::bad_chunk("Invalid GOAWAY frame".to_string())
    |                                ^^^^^^^^^ variant or associated item not found in `H2Frame`
    |
   ::: packages/http3/src/protocols/frames.rs:11:1
    |
 11 | pub enum H2Frame {
    | ---------------- variant or associated item `bad_chunk` not found for this enum
    |
    = help: items from traits can only be used if the trait is implemented and in scope
    = note: the following traits define an item `bad_chunk`, perhaps you need to implement one of them:
            candidate #1: `fluent_ai_async::prelude::MessageChunk`
            candidate #2: `sugars_builders::MessageChunk`

error[E0308]: mismatched types
   --> packages/http3/src/protocols/wire.rs:154:33
    |
154 | ...                   stream_id,
    |                       ^^^^^^^^^ expected `u64`, found `u32`
    |
help: you can convert a `u32` to a `u64`
    |
154 |                                 stream_id: stream_id.into(),
    |                                 ++++++++++          +++++++

error[E0599]: no variant or associated item named `bad_chunk` found for enum `H2Frame` in the current scope
   --> packages/http3/src/protocols/wire.rs:158:38
    |
158 | ...                   H2Frame::bad_chunk("Invalid WINDOW_UPDATE frame".to_string())
    |                                ^^^^^^^^^ variant or associated item not found in `H2Frame`
    |
   ::: packages/http3/src/protocols/frames.rs:11:1
    |
 11 | pub enum H2Frame {
    | ---------------- variant or associated item `bad_chunk` not found for this enum
    |
    = help: items from traits can only be used if the trait is implemented and in scope
    = note: the following traits define an item `bad_chunk`, perhaps you need to implement one of them:
            candidate #1: `fluent_ai_async::prelude::MessageChunk`
            candidate #2: `sugars_builders::MessageChunk`

error[E0599]: no variant or associated item named `bad_chunk` found for enum `H2Frame` in the current scope
   --> packages/http3/src/protocols/wire.rs:163:34
    |
163 |                         H2Frame::bad_chunk(format!("Unknown frame type: {}", frame_type))
    |                                  ^^^^^^^^^ variant or associated item not found in `H2Frame`
    |
   ::: packages/http3/src/protocols/frames.rs:11:1
    |
 11 | pub enum H2Frame {
    | ---------------- variant or associated item `bad_chunk` not found for this enum
    |
    = help: items from traits can only be used if the trait is implemented and in scope
    = note: the following traits define an item `bad_chunk`, perhaps you need to implement one of them:
            candidate #1: `fluent_ai_async::prelude::MessageChunk`
            candidate #2: `sugars_builders::MessageChunk`

error[E0308]: mismatched types
   --> packages/http3/src/protocols/wire.rs:199:70
    |
199 |                     let header_block = Self::serialize_hpack_headers(&headers);
    |                                        ----------------------------- ^^^^^^^^ expected `&HashMap<String, String>`, found `&Vec<(String, String)>`
    |                                        |
    |                                        arguments to this function are incorrect
    |
    = note: expected reference `&HashMap<std::string::String, std::string::String>`
               found reference `&Vec<(std::string::String, std::string::String)>`
note: associated function defined here
   --> packages/http3/src/protocols/wire.rs:266:8
    |
266 |     fn serialize_hpack_headers(headers: &HashMap<String, String>) -> Vec<u8> {
    |        ^^^^^^^^^^^^^^^^^^^^^^^ ---------------------------------

error[E0308]: mismatched types
   --> packages/http3/src/protocols/wire.rs:218:60
    |
218 |                     let payload = Self::serialize_settings(&settings);
    |                                   ------------------------ ^^^^^^^^^ expected `&HashMap<u16, u32>`, found `&Vec<(u16, u32)>`
    |                                   |
    |                                   arguments to this function are incorrect
    |
    = note: expected reference `&HashMap<u16, u32>`
               found reference `&Vec<(u16, u32)>`
note: associated function defined here
   --> packages/http3/src/protocols/wire.rs:298:8
    |
298 |     fn serialize_settings(settings: &HashMap<u16, u32>) -> Vec<u8> {
    |        ^^^^^^^^^^^^^^^^^^ ----------------------------

error[E0599]: no variant or associated item named `bad_chunk` found for enum `H3Frame` in the current scope
   --> packages/http3/src/protocols/wire.rs:325:38
    |
325 | ...                   H3Frame::bad_chunk(format!(
    |                                ^^^^^^^^^ variant or associated item not found in `H3Frame`
    |
   ::: packages/http3/src/protocols/frames.rs:62:1
    |
 62 | pub enum H3Frame {
    | ---------------- variant or associated item `bad_chunk` not found for this enum
    |
    = help: items from traits can only be used if the trait is implemented and in scope
    = note: the following traits define an item `bad_chunk`, perhaps you need to implement one of them:
            candidate #1: `fluent_ai_async::prelude::MessageChunk`
            candidate #2: `sugars_builders::MessageChunk`

error[E0599]: no variant or associated item named `bad_chunk` found for enum `H3Frame` in the current scope
   --> packages/http3/src/protocols/wire.rs:341:38
    |
341 | ...                   H3Frame::bad_chunk("Invalid frame length varint".to_string())
    |                                ^^^^^^^^^ variant or associated item not found in `H3Frame`
    |
   ::: packages/http3/src/protocols/frames.rs:62:1
    |
 62 | pub enum H3Frame {
    | ---------------- variant or associated item `bad_chunk` not found for this enum
    |
    = help: items from traits can only be used if the trait is implemented and in scope
    = note: the following traits define an item `bad_chunk`, perhaps you need to implement one of them:
            candidate #1: `fluent_ai_async::prelude::MessageChunk`
            candidate #2: `sugars_builders::MessageChunk`

error[E0308]: mismatched types
   --> packages/http3/src/protocols/wire.rs:348:29
    |
348 |                 if offset + frame_len > data_len {
    |                             ^^^^^^^^^ expected `usize`, found `u64`

error[E0277]: cannot add `u64` to `usize`
   --> packages/http3/src/protocols/wire.rs:348:27
    |
348 |                 if offset + frame_len > data_len {
    |                           ^ no implementation for `usize + u64`
    |
    = help: the trait `Add<u64>` is not implemented for `usize`
    = help: the following other types implement trait `Add<Rhs>`:
              `&usize` implements `Add<&BigInt>`
              `&usize` implements `Add<&BigUint>`
              `&usize` implements `Add<BigInt>`
              `&usize` implements `Add<BigUint>`
              `&usize` implements `Add<usize>`
              `&usize` implements `Add`
              `usize` implements `Add<&BigInt>`
              `usize` implements `Add<&BigUint>`
            and 5 others

error[E0599]: no variant or associated item named `bad_chunk` found for enum `H3Frame` in the current scope
   --> packages/http3/src/protocols/wire.rs:351:34
    |
351 |                         H3Frame::bad_chunk("Incomplete frame data".to_string())
    |                                  ^^^^^^^^^ variant or associated item not found in `H3Frame`
    |
   ::: packages/http3/src/protocols/frames.rs:62:1
    |
 62 | pub enum H3Frame {
    | ---------------- variant or associated item `bad_chunk` not found for this enum
    |
    = help: items from traits can only be used if the trait is implemented and in scope
    = note: the following traits define an item `bad_chunk`, perhaps you need to implement one of them:
            candidate #1: `fluent_ai_async::prelude::MessageChunk`
            candidate #2: `sugars_builders::MessageChunk`

error[E0308]: mismatched types
   --> packages/http3/src/protocols/wire.rs:356:54
    |
356 |                 let payload = &data[offset..offset + frame_len];
    |                                                      ^^^^^^^^^ expected `usize`, found `u64`

error[E0277]: cannot add `u64` to `usize`
   --> packages/http3/src/protocols/wire.rs:356:52
    |
356 |                 let payload = &data[offset..offset + frame_len];
    |                                                    ^ no implementation for `usize + u64`
    |
    = help: the trait `Add<u64>` is not implemented for `usize`
    = help: the following other types implement trait `Add<Rhs>`:
              `&usize` implements `Add<&BigInt>`
              `&usize` implements `Add<&BigUint>`
              `&usize` implements `Add<BigInt>`
              `&usize` implements `Add<BigUint>`
              `&usize` implements `Add<usize>`
              `&usize` implements `Add`
              `usize` implements `Add<&BigInt>`
              `usize` implements `Add<&BigUint>`
            and 5 others

error[E0308]: mismatched types
   --> packages/http3/src/protocols/wire.rs:357:27
    |
357 |                 offset += frame_len;
    |                           ^^^^^^^^^ expected `usize`, found `u64`

error[E0277]: cannot add-assign `u64` to `usize`
   --> packages/http3/src/protocols/wire.rs:357:24
    |
357 |                 offset += frame_len;
    |                        ^^ no implementation for `usize += u64`
    |
    = help: the trait `AddAssign<u64>` is not implemented for `usize`
    = help: the following other types implement trait `AddAssign<Rhs>`:
              `usize` implements `AddAssign<&usize>`
              `usize` implements `AddAssign<zerocopy::byteorder::Usize<O>>`
              `usize` implements `AddAssign`

error[E0599]: no variant or associated item named `bad_chunk` found for enum `H3Frame` in the current scope
   --> packages/http3/src/protocols/wire.rs:381:38
    |
381 | ...                   H3Frame::bad_chunk("Invalid CANCEL_PUSH frame".to_string())
    |                                ^^^^^^^^^ variant or associated item not found in `H3Frame`
    |
   ::: packages/http3/src/protocols/frames.rs:62:1
    |
 62 | pub enum H3Frame {
    | ---------------- variant or associated item `bad_chunk` not found for this enum
    |
    = help: items from traits can only be used if the trait is implemented and in scope
    = note: the following traits define an item `bad_chunk`, perhaps you need to implement one of them:
            candidate #1: `fluent_ai_async::prelude::MessageChunk`
            candidate #2: `sugars_builders::MessageChunk`

error[E0308]: mismatched types
   --> packages/http3/src/protocols/wire.rs:387:45
    |
387 |                         H3Frame::Settings { settings }
    |                                             ^^^^^^^^ expected `Vec<(u64, u64)>`, found `HashMap<u64, u64>`
    |
    = note: expected struct `Vec<(u64, u64)>`
               found struct `HashMap<u64, u64>`

error[E0559]: variant `H3Frame::PushPromise` has no field named `header_block`
   --> packages/http3/src/protocols/wire.rs:395:33
    |
395 | ...                   header_block,
    |                       ^^^^^^^^^^^^ `H3Frame::PushPromise` does not have this field
    |
    = note: available fields are: `headers`

error[E0599]: no variant or associated item named `bad_chunk` found for enum `H3Frame` in the current scope
   --> packages/http3/src/protocols/wire.rs:398:38
    |
398 | ...                   H3Frame::bad_chunk("Invalid PUSH_PROMISE frame".to_string())
    |                                ^^^^^^^^^ variant or associated item not found in `H3Frame`
    |
   ::: packages/http3/src/protocols/frames.rs:62:1
    |
 62 | pub enum H3Frame {
    | ---------------- variant or associated item `bad_chunk` not found for this enum
    |
    = help: items from traits can only be used if the trait is implemented and in scope
    = note: the following traits define an item `bad_chunk`, perhaps you need to implement one of them:
            candidate #1: `fluent_ai_async::prelude::MessageChunk`
            candidate #2: `sugars_builders::MessageChunk`

error[E0599]: no variant or associated item named `bad_chunk` found for enum `H3Frame` in the current scope
   --> packages/http3/src/protocols/wire.rs:406:38
    |
406 | ...                   H3Frame::bad_chunk("Invalid GOAWAY frame".to_string())
    |                                ^^^^^^^^^ variant or associated item not found in `H3Frame`
    |
   ::: packages/http3/src/protocols/frames.rs:62:1
    |
 62 | pub enum H3Frame {
    | ---------------- variant or associated item `bad_chunk` not found for this enum
    |
    = help: items from traits can only be used if the trait is implemented and in scope
    = note: the following traits define an item `bad_chunk`, perhaps you need to implement one of them:
            candidate #1: `fluent_ai_async::prelude::MessageChunk`
            candidate #2: `sugars_builders::MessageChunk`

error[E0599]: no variant or associated item named `bad_chunk` found for enum `H3Frame` in the current scope
   --> packages/http3/src/protocols/wire.rs:414:38
    |
414 | ...                   H3Frame::bad_chunk("Invalid MAX_PUSH_ID frame".to_string())
    |                                ^^^^^^^^^ variant or associated item not found in `H3Frame`
    |
   ::: packages/http3/src/protocols/frames.rs:62:1
    |
 62 | pub enum H3Frame {
    | ---------------- variant or associated item `bad_chunk` not found for this enum
    |
    = help: items from traits can only be used if the trait is implemented and in scope
    = note: the following traits define an item `bad_chunk`, perhaps you need to implement one of them:
            candidate #1: `fluent_ai_async::prelude::MessageChunk`
            candidate #2: `sugars_builders::MessageChunk`

error[E0027]: pattern does not mention field `stream_id`
   --> packages/http3/src/protocols/wire.rs:435:17
    |
435 |                 H3Frame::Data { data } => {
    |                 ^^^^^^^^^^^^^^^^^^^^^^ missing field `stream_id`
    |
help: include the missing field in the pattern
    |
435 |                 H3Frame::Data { data, stream_id } => {
    |                                     +++++++++++
help: if you don't care about this missing field, you can explicitly ignore it
    |
435 |                 H3Frame::Data { data, stream_id: _ } => {
    |                                     ++++++++++++++
help: or always ignore missing fields here
    |
435 |                 H3Frame::Data { data, .. } => {
    |                                     ++++

error[E0599]: no function or associated item named `serialize_headers` found for struct `H3FrameParser` in the current scope
   --> packages/http3/src/protocols/wire.rs:442:45
    |
309 | pub struct H3FrameParser;
    | ------------------------ function or associated item `serialize_headers` not found for this struct
...
442 |                     let header_data = Self::serialize_headers(&headers);
    |                                             ^^^^^^^^^^^^^^^^^ function or associated item not found in `H3FrameParser`

error[E0308]: mismatched types
   --> packages/http3/src/protocols/wire.rs:447:63
    |
447 |                     let payload = Self::serialize_h3_settings(&settings);
    |                                   --------------------------- ^^^^^^^^^ expected `&HashMap<u64, u64>`, found `&Vec<(u64, u64)>`
    |                                   |
    |                                   arguments to this function are incorrect
    |
    = note: expected reference `&HashMap<u64, u64>`
               found reference `&Vec<(u64, u64)>`
note: associated function defined here
   --> packages/http3/src/protocols/wire.rs:561:8
    |
561 |     fn serialize_h3_settings(settings: &HashMap<u64, u64>) -> Vec<u8> {
    |        ^^^^^^^^^^^^^^^^^^^^^ ----------------------------

error[E0599]: no function or associated item named `default` found for struct `Extra` in the current scope
  --> packages/http3/src/proxy/matcher/public_interface.rs:21:27
   |
21 |             extra: Extra::default(),
   |                           ^^^^^^^ function or associated item not found in `Extra`
   |
  ::: packages/http3/src/proxy/core/types.rs:60:1
   |
60 | pub struct Extra {
   | ---------------- function or associated item `default` not found for this struct
   |
   = help: items from traits can only be used if the trait is implemented and in scope
   = note: the following traits define an item `default`, perhaps you need to implement one of them:
           candidate #1: `std::default::Default`
           candidate #2: `tinyvec::Array`

error[E0599]: no function or associated item named `default` found for struct `Extra` in the current scope
  --> packages/http3/src/proxy/matcher/public_interface.rs:31:27
   |
31 |             extra: Extra::default(),
   |                           ^^^^^^^ function or associated item not found in `Extra`
   |
  ::: packages/http3/src/proxy/core/types.rs:60:1
   |
60 | pub struct Extra {
   | ---------------- function or associated item `default` not found for this struct
   |
   = help: items from traits can only be used if the trait is implemented and in scope
   = note: the following traits define an item `default`, perhaps you need to implement one of them:
           candidate #1: `std::default::Default`
           candidate #2: `tinyvec::Array`

error[E0277]: `dyn Fn(&Url) -> Option<Result<Url, Box<...>>> + Send + Sync` doesn't implement `std::fmt::Debug`
   --> packages/http3/src/proxy/url_handling.rs:231:5
    |
229 |   #[derive(Clone, Debug)]
    |                   ----- in this derive macro expansion
230 |   pub struct Custom {
231 | /     pub(crate) func: Arc<
232 | |         dyn Fn(&Url) -> Option<std::result::Result<Url, Box<dyn std::error::Error + Send + Sync>>>
233 | |             + Send
234 | |             + Sync
235 | |             + 'static,
236 | |     >,
    | |_____^ the trait `std::fmt::Debug` is not implemented for `dyn Fn(&Url) -> Option<Result<Url, Box<...>>> + Send + Sync`
    |
    = note: the full name for the type has been written to '/Volumes/samsung_t9/fluent-ai/target/debug/deps/fluent_ai_http3-5d1a04d8fa2a31a3.long-type-10031554994556122569.txt'
    = note: consider using `--verbose` to print the full type name to the console

error[E0308]: mismatched types
  --> packages/http3/src/proxy/mod.rs:22:5
   |
18 | pub fn http<U>(proxy_url: U) -> std::result::Result<Proxy, Box<dyn std::error::Error + Send + Sync>>
   |                                 -------------------------------------------------------------------- expected `std::result::Result<Proxy, Box<(dyn StdError + std::marker::Send + Sync + 'static)>>` because of return type
...
22 |     Proxy::http(proxy_url.into())
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `Result<Proxy, Box<...>>`, found `Result<Proxy, Error>`
   |
   = note: expected enum `std::result::Result<_, Box<(dyn StdError + std::marker::Send + Sync + 'static)>>`
              found enum `std::result::Result<_, error::types::Error>`
help: use `?` to coerce and return an appropriate `Err`, and wrap the resulting value in `Ok` so the expression remains of type `Result`
   |
22 |     Ok(Proxy::http(proxy_url.into())?)
   |     +++                             ++

error[E0308]: mismatched types
  --> packages/http3/src/proxy/mod.rs:32:5
   |
28 | ) -> std::result::Result<Proxy, Box<dyn std::error::Error + Send + Sync>>
   |      -------------------------------------------------------------------- expected `std::result::Result<Proxy, Box<(dyn StdError + std::marker::Send + Sync + 'static)>>` because of return type
...
32 |     Proxy::https(proxy_url.into())
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `Result<Proxy, Box<...>>`, found `Result<Proxy, Error>`
   |
   = note: expected enum `std::result::Result<_, Box<(dyn StdError + std::marker::Send + Sync + 'static)>>`
              found enum `std::result::Result<_, error::types::Error>`
help: use `?` to coerce and return an appropriate `Err`, and wrap the resulting value in `Ok` so the expression remains of type `Result`
   |
32 |     Ok(Proxy::https(proxy_url.into())?)
   |     +++                              ++

error[E0308]: mismatched types
  --> packages/http3/src/proxy/mod.rs:40:5
   |
36 | pub fn all<U>(proxy_url: U) -> std::result::Result<Proxy, Box<dyn std::error::Error + Send + Sync>>
   |                                -------------------------------------------------------------------- expected `std::result::Result<Proxy, Box<(dyn StdError + std::marker::Send + Sync + 'static)>>` because of return type
...
40 |     Proxy::all(proxy_url.into())
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `Result<Proxy, Box<...>>`, found `Result<Proxy, Error>`
   |
   = note: expected enum `std::result::Result<_, Box<(dyn StdError + std::marker::Send + Sync + 'static)>>`
              found enum `std::result::Result<_, error::types::Error>`
help: use `?` to coerce and return an appropriate `Err`, and wrap the resulting value in `Ok` so the expression remains of type `Result`
   |
40 |     Ok(Proxy::all(proxy_url.into())?)
   |     +++                            ++

error[E0223]: ambiguous associated type
   --> packages/http3/src/retry/policy.rs:130:13
    |
130 |             HttpError::NetworkError { .. } => true,
    |             ^^^^^^^^^^^^^^^^^^^^^^^
    |
help: if there were a trait named `Example` with associated type `NetworkError` implemented for `error::types::Error`, you could use the fully-qualified path
    |
130 -             HttpError::NetworkError { .. } => true,
130 +             <error::types::Error as Example>::NetworkError { .. } => true,
    |

error[E0223]: ambiguous associated type
   --> packages/http3/src/retry/policy.rs:131:13
    |
131 |             HttpError::Timeout { .. } => true,
    |             ^^^^^^^^^^^^^^^^^^
    |
help: if there were a trait named `Example` with associated type `Timeout` implemented for `error::types::Error`, you could use the fully-qualified path
    |
131 -             HttpError::Timeout { .. } => true,
131 +             <error::types::Error as Example>::Timeout { .. } => true,
    |

error[E0223]: ambiguous associated type
   --> packages/http3/src/retry/policy.rs:132:13
    |
132 |             HttpError::HttpStatus { status, .. } => {
    |             ^^^^^^^^^^^^^^^^^^^^^
    |
help: if there were a trait named `Example` with associated type `HttpStatus` implemented for `error::types::Error`, you could use the fully-qualified path
    |
132 -             HttpError::HttpStatus { status, .. } => {
132 +             <error::types::Error as Example>::HttpStatus { status, .. } => {
    |

error[E0223]: ambiguous associated type
   --> packages/http3/src/retry/policy.rs:136:13
    |
136 |             HttpError::TlsError { .. } => false, // TLS errors usually not transient
    |             ^^^^^^^^^^^^^^^^^^^
    |
help: if there were a trait named `Example` with associated type `TlsError` implemented for `error::types::Error`, you could use the fully-qualified path
    |
136 -             HttpError::TlsError { .. } => false, // TLS errors usually not transient
136 +             <error::types::Error as Example>::TlsError { .. } => false, // TLS errors usually not transient
    |

error[E0223]: ambiguous associated type
   --> packages/http3/src/retry/policy.rs:137:13
    |
137 |             HttpError::InvalidUrl { .. } => false, // Client errors not retryable
    |             ^^^^^^^^^^^^^^^^^^^^^
    |
help: if there were a trait named `Example` with associated type `InvalidUrl` implemented for `error::types::Error`, you could use the fully-qualified path
    |
137 -             HttpError::InvalidUrl { .. } => false, // Client errors not retryable
137 +             <error::types::Error as Example>::InvalidUrl { .. } => false, // Client errors not retryable
    |

error[E0223]: ambiguous associated type
   --> packages/http3/src/retry/policy.rs:138:13
    |
138 |             HttpError::SerializationError { .. } => false,
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    |
help: if there were a trait named `Example` with associated type `SerializationError` implemented for `error::types::Error`, you could use the fully-qualified path
    |
138 -             HttpError::SerializationError { .. } => false,
138 +             <error::types::Error as Example>::SerializationError { .. } => false,
    |

error[E0223]: ambiguous associated type
   --> packages/http3/src/retry/policy.rs:139:13
    |
139 |             HttpError::InvalidResponse { .. } => false,
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^
    |
help: if there were a trait named `Example` with associated type `InvalidResponse` implemented for `error::types::Error`, you could use the fully-qualified path
    |
139 -             HttpError::InvalidResponse { .. } => false,
139 +             <error::types::Error as Example>::InvalidResponse { .. } => false,
    |

error[E0223]: ambiguous associated type
   --> packages/http3/src/retry/policy.rs:140:13
    |
140 |             HttpError::ClientError { .. } => false,
    |             ^^^^^^^^^^^^^^^^^^^^^^
    |
help: if there were a trait named `Example` with associated type `ClientError` implemented for `error::types::Error`, you could use the fully-qualified path
    |
140 -             HttpError::ClientError { .. } => false,
140 +             <error::types::Error as Example>::ClientError { .. } => false,
    |

error[E0223]: ambiguous associated type
   --> packages/http3/src/retry/policy.rs:141:13
    |
141 |             HttpError::DeserializationError { .. } => false,
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    |
help: if there were a trait named `Example` with associated type `DeserializationError` implemented for `error::types::Error`, you could use the fully-qualified path
    |
141 -             HttpError::DeserializationError { .. } => false,
141 +             <error::types::Error as Example>::DeserializationError { .. } => false,
    |

error[E0223]: ambiguous associated type
   --> packages/http3/src/retry/policy.rs:142:13
    |
142 |             HttpError::UrlParseError { .. } => false,
    |             ^^^^^^^^^^^^^^^^^^^^^^^^
    |
help: if there were a trait named `Example` with associated type `UrlParseError` implemented for `error::types::Error`, you could use the fully-qualified path
    |
142 -             HttpError::UrlParseError { .. } => false,
142 +             <error::types::Error as Example>::UrlParseError { .. } => false,
    |

error[E0223]: ambiguous associated type
   --> packages/http3/src/retry/policy.rs:143:13
    |
143 |             HttpError::DownloadInterrupted { .. } => true,
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    |
help: if there were a trait named `Example` with associated type `DownloadInterrupted` implemented for `error::types::Error`, you could use the fully-qualified path
    |
143 -             HttpError::DownloadInterrupted { .. } => true,
143 +             <error::types::Error as Example>::DownloadInterrupted { .. } => true,
    |

error[E0223]: ambiguous associated type
   --> packages/http3/src/retry/policy.rs:144:13
    |
144 |             HttpError::InvalidContentLength { .. } => false,
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    |
help: if there were a trait named `Example` with associated type `InvalidContentLength` implemented for `error::types::Error`, you could use the fully-qualified path
    |
144 -             HttpError::InvalidContentLength { .. } => false,
144 +             <error::types::Error as Example>::InvalidContentLength { .. } => false,
    |

error[E0223]: ambiguous associated type
   --> packages/http3/src/retry/policy.rs:145:13
    |
145 |             HttpError::ChunkProcessingError { .. } => false,
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    |
help: if there were a trait named `Example` with associated type `ChunkProcessingError` implemented for `error::types::Error`, you could use the fully-qualified path
    |
145 -             HttpError::ChunkProcessingError { .. } => false,
145 +             <error::types::Error as Example>::ChunkProcessingError { .. } => false,
    |

error[E0599]: no method named `to_der` found for struct `RdnSequence` in the current scope
   --> packages/http3/src/tls/certificate/parser.rs:419:52
    |
419 |     let subject_der = cert.tbs_certificate.subject.to_der()
    |                                                    ^^^^^^ method not found in `RdnSequence`
    |
   ::: /Users/davidmaple/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/der-0.7.10/src/encode.rs:62:8
    |
 62 |     fn to_der(&self) -> Result<Vec<u8>> {
    |        ------ the method is available for `RdnSequence` here
    |
    = help: items from traits can only be used if the trait is in scope
help: trait `Encode` which provides `to_der` is implemented but not in scope; perhaps you want to import it
    |
  3 + use der::Encode;
    |

error[E0599]: no method named `to_der` found for struct `spki::SubjectPublicKeyInfo<Params, Key>` in the current scope
   --> packages/http3/src/tls/certificate/parser.rs:422:71
    |
422 |     let public_key_der = cert.tbs_certificate.subject_public_key_info.to_der()
    |                                                                       ^^^^^^
    |
   ::: /Users/davidmaple/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/der-0.7.10/src/encode.rs:62:8
    |
 62 |     fn to_der(&self) -> Result<Vec<u8>> {
    |        ------ the method is available for `spki::SubjectPublicKeyInfo<der::Any, der::asn1::BitString>` here
    |
    = help: items from traits can only be used if the trait is in scope
help: there is a method `to_pem` with a similar name, but with different arguments
   --> /Users/davidmaple/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/der-0.7.10/src/encode.rs:107:5
    |
107 |     fn to_pem(&self, line_ending: LineEnding) -> Result<String>;
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: trait `Encode` which provides `to_der` is implemented but not in scope; perhaps you want to import it
    |
  3 + use der::Encode;
    |

error[E0308]: mismatched types
   --> packages/http3/src/tls/certificate/parser.rs:466:33
    |
466 |     } else if *algorithm_oid == ID_EC_PUBLIC_KEY {
    |               --------------    ^^^^^^^^^^^^^^^^ expected `ObjectIdentifier`, found `ObjectIdentifier<39>`
    |               |
    |               expected because this is `spki::ObjectIdentifier`
    |
note: two different versions of crate `const_oid` are being used; two types coming from two different versions of the same crate are different types even if they look the same
   --> /Users/davidmaple/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/const-oid-0.10.1/src/lib.rs:66:1
    |
 66 | pub struct ObjectIdentifier<const MAX_SIZE: usize = DEFAULT_MAX_SIZE> {
    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ this is the found type `const_oid::ObjectIdentifier`
    |
   ::: /Users/davidmaple/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/const-oid-0.9.6/src/lib.rs:81:1
    |
 81 | pub struct ObjectIdentifier {
    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^ this is the expected type `spki::ObjectIdentifier`
    |
   ::: packages/http3/src/tls/certificate/parser.rs:6:5
    |
  6 | use x509_cert::{der::Decode, Certificate as X509CertCert};
    |     --------- one version of crate `const_oid` used here, as a dependency of crate `der`
  7 | use const_oid::db::rfc3279::ID_DSA;
    |     --------- one version of crate `const_oid` used here, as a direct dependency of the current crate
    = help: you can use `cargo tree` to explore your dependency tree

error[E0308]: arguments to this function are incorrect
   --> packages/http3/src/tls/certificate/parser.rs:480:20
    |
480 |     let key_size = extract_key_size_from_algorithm_and_key(
    |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
481 |         algorithm,
482 |         &cert.tbs_certificate.subject_public_key_info.subject_public_key
    |         ---------------------------------------------------------------- expected `&BitStringRef<'_>`, found `&BitString`
    |
note: expected `&AlgorithmIdentifier<AnyRef<'_>>`, found `&AlgorithmIdentifier<Any>`
   --> packages/http3/src/tls/certificate/parser.rs:481:9
    |
481 |         algorithm,
    |         ^^^^^^^^^
    = note: expected reference `&spki::AlgorithmIdentifier<AnyRef<'_>>`
               found reference `&spki::AlgorithmIdentifier<der::Any>`
    = note: expected reference `&BitStringRef<'_>`
               found reference `&der::asn1::BitString`
note: function defined here
   --> packages/http3/src/tls/certificate/parser.rs:489:4
    |
489 | fn extract_key_size_from_algorithm_and_key(
    |    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
490 |     algorithm: &AlgorithmIdentifier<AnyRef>,
    |     ---------------------------------------
491 |     public_key: &der::asn1::BitStringRef,
    |     ------------------------------------

error[E0599]: no method named `peek_header` found for mutable reference `&mut SliceReader<'_>` in the current scope
   --> packages/http3/src/tls/certificate/parser.rs:521:25
    |
521 |     let header = reader.peek_header().ok()?;
    |                         ^^^^^^^^^^^ method not found in `&mut SliceReader<'_>`
    |
    = help: items from traits can only be used if the trait is in scope
help: trait `Reader` which provides `peek_header` is implemented but not in scope; perhaps you want to import it
    |
  3 + use der::Reader;
    |

error[E0599]: no method named `read_slice` found for mutable reference `&mut SliceReader<'_>` in the current scope
   --> packages/http3/src/tls/certificate/parser.rs:525:12
    |
525 |     reader.read_slice(der::Length::try_from(total_len).ok()?).ok()?;
    |            ^^^^^^^^^^
    |
    = help: items from traits can only be used if the trait is in scope
help: trait `Reader` which provides `read_slice` is implemented but not in scope; perhaps you want to import it
    |
  3 + use der::Reader;
    |
help: there is a method `read_vec` with a similar name
    |
525 -     reader.read_slice(der::Length::try_from(total_len).ok()?).ok()?;
525 +     reader.read_vec(der::Length::try_from(total_len).ok()?).ok()?;
    |

error[E0599]: no method named `peek_header` found for struct `SliceReader<'a>` in the current scope
   --> packages/http3/src/tls/certificate/parser.rs:536:34
    |
536 |     let sequence_header = reader.peek_header().ok()?;
    |                                  ^^^^^^^^^^^ method not found in `SliceReader<'_>`
    |
   ::: /Users/davidmaple/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/der-0.7.10/src/reader.rs:30:8
    |
 30 |     fn peek_header(&self) -> Result<Header>;
    |        ----------- the method is available for `SliceReader<'_>` here
    |
    = help: items from traits can only be used if the trait is in scope
help: trait `Reader` which provides `peek_header` is implemented but not in scope; perhaps you want to import it
    |
  3 + use der::Reader;
    |

error[E0599]: no method named `read_slice` found for struct `SliceReader<'a>` in the current scope
   --> packages/http3/src/tls/certificate/parser.rs:540:12
    |
540 |     reader.read_slice(Length::try_from(sequence_header.encoded_len() as usize).ok()?).ok()?;
    |            ^^^^^^^^^^
    |
   ::: /Users/davidmaple/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/der-0.7.10/src/reader.rs:42:8
    |
 42 |     fn read_slice(&mut self, len: Length) -> Result<&'r [u8]>;
    |        ---------- the method is available for `SliceReader<'_>` here
    |
    = help: items from traits can only be used if the trait is in scope
help: trait `Reader` which provides `read_slice` is implemented but not in scope; perhaps you want to import it
    |
  3 + use der::Reader;
    |
help: there is a method `read_vec` with a similar name
    |
540 -     reader.read_slice(Length::try_from(sequence_header.encoded_len() as usize).ok()?).ok()?;
540 +     reader.read_vec(Length::try_from(sequence_header.encoded_len() as usize).ok()?).ok()?;
    |

error[E0599]: no method named `peek_header` found for struct `SliceReader<'a>` in the current scope
   --> packages/http3/src/tls/certificate/parser.rs:542:33
    |
542 |     let modulus_header = reader.peek_header().ok()?;
    |                                 ^^^^^^^^^^^ method not found in `SliceReader<'_>`
    |
   ::: /Users/davidmaple/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/der-0.7.10/src/reader.rs:30:8
    |
 30 |     fn peek_header(&self) -> Result<Header>;
    |        ----------- the method is available for `SliceReader<'_>` here
    |
    = help: items from traits can only be used if the trait is in scope
help: trait `Reader` which provides `peek_header` is implemented but not in scope; perhaps you want to import it
    |
  3 + use der::Reader;
    |

error[E0599]: no method named `read_slice` found for struct `SliceReader<'a>` in the current scope
   --> packages/http3/src/tls/certificate/parser.rs:546:12
    |
546 |     reader.read_slice(Length::try_from(modulus_header.encoded_len() as usize).ok()?).ok()?;
    |            ^^^^^^^^^^
    |
   ::: /Users/davidmaple/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/der-0.7.10/src/reader.rs:42:8
    |
 42 |     fn read_slice(&mut self, len: Length) -> Result<&'r [u8]>;
    |        ---------- the method is available for `SliceReader<'_>` here
    |
    = help: items from traits can only be used if the trait is in scope
help: trait `Reader` which provides `read_slice` is implemented but not in scope; perhaps you want to import it
    |
  3 + use der::Reader;
    |
help: there is a method `read_vec` with a similar name
    |
546 -     reader.read_slice(Length::try_from(modulus_header.encoded_len() as usize).ok()?).ok()?;
546 +     reader.read_vec(Length::try_from(modulus_header.encoded_len() as usize).ok()?).ok()?;
    |

error[E0599]: no method named `read_slice` found for struct `SliceReader<'a>` in the current scope
   --> packages/http3/src/tls/certificate/parser.rs:548:32
    |
548 |     let modulus_bytes = reader.read_slice(modulus_header.length).ok()?;
    |                                ^^^^^^^^^^
    |
   ::: /Users/davidmaple/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/der-0.7.10/src/reader.rs:42:8
    |
 42 |     fn read_slice(&mut self, len: Length) -> Result<&'r [u8]>;
    |        ---------- the method is available for `SliceReader<'_>` here
    |
    = help: items from traits can only be used if the trait is in scope
help: trait `Reader` which provides `read_slice` is implemented but not in scope; perhaps you want to import it
    |
  3 + use der::Reader;
    |
help: there is a method `read_vec` with a similar name
    |
548 -     let modulus_bytes = reader.read_slice(modulus_header.length).ok()?;
548 +     let modulus_bytes = reader.read_vec(modulus_header.length).ok()?;
    |

error[E0599]: no method named `as_bytes` found for reference `&AnyRef<'_>` in the current scope
   --> packages/http3/src/tls/certificate/parser.rs:555:28
    |
555 |     let bytes = parameters.as_bytes().ok()?;
    |                            ^^^^^^^^ method not found in `&AnyRef<'_>`

error[E0599]: no method named `peek_header` found for struct `SliceReader<'a>` in the current scope
   --> packages/http3/src/tls/certificate/parser.rs:558:34
    |
558 |     let sequence_header = reader.peek_header().ok()?;
    |                                  ^^^^^^^^^^^ method not found in `SliceReader<'_>`
    |
   ::: /Users/davidmaple/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/der-0.7.10/src/reader.rs:30:8
    |
 30 |     fn peek_header(&self) -> Result<Header>;
    |        ----------- the method is available for `SliceReader<'_>` here
    |
    = help: items from traits can only be used if the trait is in scope
help: trait `Reader` which provides `peek_header` is implemented but not in scope; perhaps you want to import it
    |
  3 + use der::Reader;
    |

error[E0599]: no method named `read_slice` found for struct `SliceReader<'a>` in the current scope
   --> packages/http3/src/tls/certificate/parser.rs:562:12
    |
562 |     reader.read_slice(der::Length::try_from(sequence_header.encoded_len() as usize).ok()?).ok()?;
    |            ^^^^^^^^^^
    |
   ::: /Users/davidmaple/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/der-0.7.10/src/reader.rs:42:8
    |
 42 |     fn read_slice(&mut self, len: Length) -> Result<&'r [u8]>;
    |        ---------- the method is available for `SliceReader<'_>` here
    |
    = help: items from traits can only be used if the trait is in scope
help: trait `Reader` which provides `read_slice` is implemented but not in scope; perhaps you want to import it
    |
  3 + use der::Reader;
    |
help: there is a method `read_vec` with a similar name
    |
562 -     reader.read_slice(der::Length::try_from(sequence_header.encoded_len() as usize).ok()?).ok()?;
562 +     reader.read_vec(der::Length::try_from(sequence_header.encoded_len() as usize).ok()?).ok()?;
    |

error[E0599]: no method named `peek_header` found for struct `SliceReader<'a>` in the current scope
   --> packages/http3/src/tls/certificate/parser.rs:564:27
    |
564 |     let p_header = reader.peek_header().ok()?;
    |                           ^^^^^^^^^^^ method not found in `SliceReader<'_>`
    |
   ::: /Users/davidmaple/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/der-0.7.10/src/reader.rs:30:8
    |
 30 |     fn peek_header(&self) -> Result<Header>;
    |        ----------- the method is available for `SliceReader<'_>` here
    |
    = help: items from traits can only be used if the trait is in scope
help: trait `Reader` which provides `peek_header` is implemented but not in scope; perhaps you want to import it
    |
  3 + use der::Reader;
    |

error[E0599]: no method named `read_slice` found for struct `SliceReader<'a>` in the current scope
   --> packages/http3/src/tls/certificate/parser.rs:568:12
    |
568 |     reader.read_slice(der::Length::try_from(p_header.encoded_len() as usize).ok()?).ok()?;
    |            ^^^^^^^^^^
    |
   ::: /Users/davidmaple/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/der-0.7.10/src/reader.rs:42:8
    |
 42 |     fn read_slice(&mut self, len: Length) -> Result<&'r [u8]>;
    |        ---------- the method is available for `SliceReader<'_>` here
    |
    = help: items from traits can only be used if the trait is in scope
help: trait `Reader` which provides `read_slice` is implemented but not in scope; perhaps you want to import it
    |
  3 + use der::Reader;
    |
help: there is a method `read_vec` with a similar name
    |
568 -     reader.read_slice(der::Length::try_from(p_header.encoded_len() as usize).ok()?).ok()?;
568 +     reader.read_vec(der::Length::try_from(p_header.encoded_len() as usize).ok()?).ok()?;
    |

error[E0599]: no method named `read_slice` found for struct `SliceReader<'a>` in the current scope
   --> packages/http3/src/tls/certificate/parser.rs:570:26
    |
570 |     let p_bytes = reader.read_slice(p_header.length).ok()?;
    |                          ^^^^^^^^^^
    |
   ::: /Users/davidmaple/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/der-0.7.10/src/reader.rs:42:8
    |
 42 |     fn read_slice(&mut self, len: Length) -> Result<&'r [u8]>;
    |        ---------- the method is available for `SliceReader<'_>` here
    |
    = help: items from traits can only be used if the trait is in scope
help: trait `Reader` which provides `read_slice` is implemented but not in scope; perhaps you want to import it
    |
  3 + use der::Reader;
    |
help: there is a method `read_vec` with a similar name
    |
570 -     let p_bytes = reader.read_slice(p_header.length).ok()?;
570 +     let p_bytes = reader.read_vec(p_header.length).ok()?;
    |

error[E0599]: no method named `as_bytes` found for reference `&AnyRef<'_>` in the current scope
   --> packages/http3/src/tls/certificate/parser.rs:577:28
    |
577 |     let bytes = parameters.as_bytes().ok()?;
    |                            ^^^^^^^^ method not found in `&AnyRef<'_>`

error[E0599]: no method named `peek_header` found for struct `SliceReader<'a>` in the current scope
   --> packages/http3/src/tls/certificate/parser.rs:580:25
    |
580 |     let header = reader.peek_header().ok()?;
    |                         ^^^^^^^^^^^ method not found in `SliceReader<'_>`
    |
   ::: /Users/davidmaple/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/der-0.7.10/src/reader.rs:30:8
    |
 30 |     fn peek_header(&self) -> Result<Header>;
    |        ----------- the method is available for `SliceReader<'_>` here
    |
    = help: items from traits can only be used if the trait is in scope
help: trait `Reader` which provides `peek_header` is implemented but not in scope; perhaps you want to import it
    |
  3 + use der::Reader;
    |

error[E0599]: no method named `read_slice` found for struct `SliceReader<'a>` in the current scope
   --> packages/http3/src/tls/certificate/parser.rs:583:20
    |
583 |             reader.read_slice(Length::try_from(header.encoded_len() as usize).ok()?).ok()?;
    |                    ^^^^^^^^^^
    |
   ::: /Users/davidmaple/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/der-0.7.10/src/reader.rs:42:8
    |
 42 |     fn read_slice(&mut self, len: Length) -> Result<&'r [u8]>;
    |        ---------- the method is available for `SliceReader<'_>` here
    |
    = help: items from traits can only be used if the trait is in scope
help: trait `Reader` which provides `read_slice` is implemented but not in scope; perhaps you want to import it
    |
  3 + use der::Reader;
    |
help: there is a method `read_vec` with a similar name
    |
583 -             reader.read_slice(Length::try_from(header.encoded_len() as usize).ok()?).ok()?;
583 +             reader.read_vec(Length::try_from(header.encoded_len() as usize).ok()?).ok()?;
    |

error[E0599]: no function or associated item named `decode_without_tag` found for struct `oid::ObjectIdentifier` in the current scope
   --> packages/http3/src/tls/certificate/parser.rs:584:65
    |
584 |             let curve_oid: ObjectIdentifier = ObjectIdentifier::decode_without_tag(&mut reader).ok()?;
    |                                                                 ^^^^^^^^^^^^^^^^^^ function or associated item not found in `oid::ObjectIdentifier`

error[E0599]: no method named `read_slice` found for struct `SliceReader<'a>` in the current scope
   --> packages/http3/src/tls/certificate/parser.rs:604:20
    |
604 |             reader.read_slice(Length::try_from(header.encoded_len() as usize).ok()?).ok()?;
    |                    ^^^^^^^^^^
    |
   ::: /Users/davidmaple/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/der-0.7.10/src/reader.rs:42:8
    |
 42 |     fn read_slice(&mut self, len: Length) -> Result<&'r [u8]>;
    |        ---------- the method is available for `SliceReader<'_>` here
    |
    = help: items from traits can only be used if the trait is in scope
help: trait `Reader` which provides `read_slice` is implemented but not in scope; perhaps you want to import it
    |
  3 + use der::Reader;
    |
help: there is a method `read_vec` with a similar name
    |
604 -             reader.read_slice(Length::try_from(header.encoded_len() as usize).ok()?).ok()?;
604 +             reader.read_vec(Length::try_from(header.encoded_len() as usize).ok()?).ok()?;
    |

error[E0599]: no method named `peek_header` found for struct `SliceReader<'a>` in the current scope
   --> packages/http3/src/tls/certificate/parser.rs:614:39
    |
614 |             let order_header = reader.peek_header().ok()?;
    |                                       ^^^^^^^^^^^ method not found in `SliceReader<'_>`
    |
   ::: /Users/davidmaple/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/der-0.7.10/src/reader.rs:30:8
    |
 30 |     fn peek_header(&self) -> Result<Header>;
    |        ----------- the method is available for `SliceReader<'_>` here
    |
    = help: items from traits can only be used if the trait is in scope
help: trait `Reader` which provides `peek_header` is implemented but not in scope; perhaps you want to import it
    |
  3 + use der::Reader;
    |

error[E0599]: no method named `read_slice` found for struct `SliceReader<'a>` in the current scope
   --> packages/http3/src/tls/certificate/parser.rs:618:20
    |
618 |             reader.read_slice(Length::try_from(order_header.encoded_len() as usize).ok()?).ok()?;
    |                    ^^^^^^^^^^
    |
   ::: /Users/davidmaple/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/der-0.7.10/src/reader.rs:42:8
    |
 42 |     fn read_slice(&mut self, len: Length) -> Result<&'r [u8]>;
    |        ---------- the method is available for `SliceReader<'_>` here
    |
    = help: items from traits can only be used if the trait is in scope
help: trait `Reader` which provides `read_slice` is implemented but not in scope; perhaps you want to import it
    |
  3 + use der::Reader;
    |
help: there is a method `read_vec` with a similar name
    |
618 -             reader.read_slice(Length::try_from(order_header.encoded_len() as usize).ok()?).ok()?;
618 +             reader.read_vec(Length::try_from(order_header.encoded_len() as usize).ok()?).ok()?;
    |

error[E0599]: no method named `read_slice` found for struct `SliceReader<'a>` in the current scope
   --> packages/http3/src/tls/certificate/parser.rs:619:38
    |
619 |             let order_bytes = reader.read_slice(order_header.length).ok()?;
    |                                      ^^^^^^^^^^
    |
   ::: /Users/davidmaple/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/der-0.7.10/src/reader.rs:42:8
    |
 42 |     fn read_slice(&mut self, len: Length) -> Result<&'r [u8]>;
    |        ---------- the method is available for `SliceReader<'_>` here
    |
    = help: items from traits can only be used if the trait is in scope
help: trait `Reader` which provides `read_slice` is implemented but not in scope; perhaps you want to import it
    |
  3 + use der::Reader;
    |
help: there is a method `read_vec` with a similar name
    |
619 -             let order_bytes = reader.read_slice(order_header.length).ok()?;
619 +             let order_bytes = reader.read_vec(order_header.length).ok()?;
    |

error[E0599]: no function or associated item named `from_der` found for struct `CertificateInner<P>` in the current scope
  --> packages/http3/src/tls/certificate/validation.rs:92:29
   |
92 |     let cert = Certificate::from_der(der_data).map_err(|e| {
   |                             ^^^^^^^^ function or associated item not found in `CertificateInner`
   |
   = help: items from traits can only be used if the trait is in scope
help: trait `Decode` which provides `from_der` is implemented but not in scope; perhaps you want to import it
   |
 3 + use der::Decode;
   |
help: there is an associated function `from` with a similar name
   |
92 -     let cert = Certificate::from_der(der_data).map_err(|e| {
92 +     let cert = Certificate::from(der_data).map_err(|e| {
   |

error[E0061]: this function takes 0 arguments but 1 argument was supplied
  --> packages/http3/src/tls/crl_cache.rs:50:27
   |
50 |         let http_client = crate::HttpClient::new(crate::HttpConfig::default());
   |                           ^^^^^^^^^^^^^^^^^^^^^^ ---------------------------- unexpected argument of type `config::core::types::HttpConfig`
   |
note: associated function defined here
  --> packages/http3/src/client/core.rs:65:12
   |
65 |     pub fn new() -> Self {
   |            ^^^
help: remove the extra argument
   |
50 -         let http_client = crate::HttpClient::new(crate::HttpConfig::default());
50 +         let http_client = crate::HttpClient::new();
   |

error[E0277]: the trait bound `CrlStatus: std::default::Default` is not satisfied
  --> packages/http3/src/tls/crl_cache.rs:68:9
   |
68 | /         AsyncStream::with_channel(move |sender| {
69 | |             spawn_task(move || {
70 | |                 match cache.check_against_crl_sync(&serial_number, &crl_url) {
71 | |                     Ok(is_revoked) => {
...  |
82 | |             });
83 | |         })
   | |__________^ the trait `std::default::Default` is not implemented for `CrlStatus`
   |
note: required by a bound in `fluent_ai_async::stream::<impl fluent_ai_async::AsyncStream<T, CAP>>::with_channel`
  --> /Volumes/samsung_t9/fluent-ai/packages/async-stream/src/stream/mod.rs:20:30
   |
20 |     T: MessageChunk + Send + Default + 'static,
   |                              ^^^^^^^ required by this bound in `fluent_ai_async::stream::<impl AsyncStream<T, CAP>>::with_channel`
...
27 |     pub fn with_channel<F>(producer: F) -> Self
   |            ------------ required by a bound in this associated function

error[E0277]: the trait bound `CrlStatus: std::default::Default` is not satisfied
  --> packages/http3/src/tls/crl_cache.rs:73:29
   |
73 | ...                   emit!(sender, CrlStatus::Revoked);
   |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `std::default::Default` is not implemented for `CrlStatus`
   |
note: required by a bound in `AsyncStreamSender::<T, CAP>::send`
  --> /Volumes/samsung_t9/fluent-ai/packages/async-stream/src/stream/sender.rs:19:30
   |
19 |     T: MessageChunk + Send + Default + 'static,
   |                              ^^^^^^^ required by this bound in `AsyncStreamSender::<T, CAP>::send`
...
26 |     pub fn send(&self, value: T) -> Result<(), T> {
   |            ---- required by a bound in this associated function
   = note: this error originates in the macro `emit` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0599]: the method `send` exists for struct `AsyncStreamSender<CrlStatus, _>`, but its trait bounds were not satisfied
   --> packages/http3/src/tls/crl_cache.rs:75:29
    |
 18 | pub enum CrlStatus {
    | ------------------ doesn't satisfy `CrlStatus: std::default::Default`
...
 75 |                             emit!(sender, CrlStatus::Valid);
    |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ method cannot be called on `AsyncStreamSender<CrlStatus, _>` due to unsatisfied trait bounds
    |
    = note: the following trait bounds were not satisfied:
            `CrlStatus: std::default::Default`
note: the trait `std::default::Default` must be implemented
   --> /Users/davidmaple/.rustup/toolchains/nightly-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/default.rs:108:1
    |
108 | pub trait Default: Sized {
    | ^^^^^^^^^^^^^^^^^^^^^^^^
    = note: this error originates in the macro `emit` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0599]: the method `send` exists for struct `AsyncStreamSender<CrlStatus, _>`, but its trait bounds were not satisfied
   --> packages/http3/src/tls/crl_cache.rs:79:25
    |
 18 | pub enum CrlStatus {
    | ------------------ doesn't satisfy `CrlStatus: std::default::Default`
...
 79 |                         emit!(sender, CrlStatus::Unknown);
    |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ method cannot be called on `AsyncStreamSender<CrlStatus, _>` due to unsatisfied trait bounds
    |
    = note: the following trait bounds were not satisfied:
            `CrlStatus: std::default::Default`
note: the trait `std::default::Default` must be implemented
   --> /Users/davidmaple/.rustup/toolchains/nightly-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/default.rs:108:1
    |
108 | pub trait Default: Sized {
    | ^^^^^^^^^^^^^^^^^^^^^^^^
    = note: this error originates in the macro `emit` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0599]: no method named `collect_one` found for struct `fluent_ai_async::AsyncStream<T, CAP>` in the current scope
   --> packages/http3/src/tls/crl_cache.rs:193:14
    |
191 |           let crl_bytes = crate::Http3::new()
    |  _________________________-
192 | |             .get(crl_url)
193 | |             .collect_one::<Vec<u8>>()
    | |_____________-^^^^^^^^^^^
    |
help: there is a method `collect` with a similar name
    |
193 -             .collect_one::<Vec<u8>>()
193 +             .collect::<Vec<u8>>()
    |

error[E0061]: this function takes 0 arguments but 1 argument was supplied
  --> packages/http3/src/tls/ocsp.rs:48:27
   |
48 |         let http_client = crate::HttpClient::new(crate::HttpConfig::default());
   |                           ^^^^^^^^^^^^^^^^^^^^^^ ---------------------------- unexpected argument of type `config::core::types::HttpConfig`
   |
note: associated function defined here
  --> packages/http3/src/client/core.rs:65:12
   |
65 |     pub fn new() -> Self {
   |            ^^^
help: remove the extra argument
   |
48 -         let http_client = crate::HttpClient::new(crate::HttpConfig::default());
48 +         let http_client = crate::HttpClient::new();
   |

error[E0277]: the trait bound `OcspStatus: fluent_ai_async::prelude::MessageChunk` is not satisfied
   --> packages/http3/src/tls/ocsp.rs:85:9
    |
 85 | /         AsyncStream::with_channel(move |sender| {
 86 | |             spawn_task(move || {
 87 | |                 let cache_key = Self::make_cache_key(&cert.serial_number);
...   |
113 | |             });
114 | |         })
    | |__________^ the trait `fluent_ai_async::prelude::MessageChunk` is not implemented for `OcspStatus`
    |
note: there are multiple different versions of crate `sugars_builders` in the dependency graph
   --> /Users/davidmaple/.cargo/git/checkouts/cyrup-sugars-291ac2b5c478a1ed/150c82d/packages/builders/src/chunk_handler.rs:8:1
    |
  8 | pub trait MessageChunk: Sized {
    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    | |
    | this is the required trait
    | this is the found trait
    |
   ::: packages/http3/src/builder/execution.rs:4:5
    |
  4 | use fluent_ai_async::{AsyncStream, prelude::MessageChunk};
    |     --------------- one version of crate `sugars_builders` used here, as a dependency of crate `cyrup_sugars`
    |
   ::: packages/http3/src/tls/ocsp.rs:23:1
    |
 23 | pub enum OcspStatus {
    | ------------------- this type doesn't implement the required trait
    = help: you can use `cargo tree` to explore your dependency tree
note: required by a bound in `fluent_ai_async::stream::<impl fluent_ai_async::AsyncStream<T, CAP>>::with_channel`
   --> /Volumes/samsung_t9/fluent-ai/packages/async-stream/src/stream/mod.rs:20:8
    |
 20 |     T: MessageChunk + Send + Default + 'static,
    |        ^^^^^^^^^^^^ required by this bound in `fluent_ai_async::stream::<impl AsyncStream<T, CAP>>::with_channel`
...
 27 |     pub fn with_channel<F>(producer: F) -> Self
    |            ------------ required by a bound in this associated function

error[E0277]: the trait bound `OcspStatus: std::default::Default` is not satisfied
   --> packages/http3/src/tls/ocsp.rs:85:9
    |
 85 | /         AsyncStream::with_channel(move |sender| {
 86 | |             spawn_task(move || {
 87 | |                 let cache_key = Self::make_cache_key(&cert.serial_number);
...   |
113 | |             });
114 | |         })
    | |__________^ the trait `std::default::Default` is not implemented for `OcspStatus`
    |
note: required by a bound in `fluent_ai_async::stream::<impl fluent_ai_async::AsyncStream<T, CAP>>::with_channel`
   --> /Volumes/samsung_t9/fluent-ai/packages/async-stream/src/stream/mod.rs:20:30
    |
 20 |     T: MessageChunk + Send + Default + 'static,
    |                              ^^^^^^^ required by this bound in `fluent_ai_async::stream::<impl AsyncStream<T, CAP>>::with_channel`
...
 27 |     pub fn with_channel<F>(producer: F) -> Self
    |            ------------ required by a bound in this associated function

error[E0277]: the trait bound `OcspStatus: fluent_ai_async::prelude::MessageChunk` is not satisfied
  --> packages/http3/src/tls/ocsp.rs:96:25
   |
96 |                         emit!(sender, cached.status);
   |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `fluent_ai_async::prelude::MessageChunk` is not implemented for `OcspStatus`
   |
note: there are multiple different versions of crate `sugars_builders` in the dependency graph
  --> /Users/davidmaple/.cargo/git/checkouts/cyrup-sugars-291ac2b5c478a1ed/150c82d/packages/builders/src/chunk_handler.rs:8:1
   |
 8 | pub trait MessageChunk: Sized {
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   | |
   | this is the required trait
   | this is the found trait
   |
  ::: packages/http3/src/builder/execution.rs:4:5
   |
 4 | use fluent_ai_async::{AsyncStream, prelude::MessageChunk};
   |     --------------- one version of crate `sugars_builders` used here, as a dependency of crate `cyrup_sugars`
   |
  ::: packages/http3/src/tls/ocsp.rs:23:1
   |
23 | pub enum OcspStatus {
   | ------------------- this type doesn't implement the required trait
   = help: you can use `cargo tree` to explore your dependency tree
note: required by a bound in `AsyncStreamSender::<T, CAP>::send`
  --> /Volumes/samsung_t9/fluent-ai/packages/async-stream/src/stream/sender.rs:19:8
   |
19 |     T: MessageChunk + Send + Default + 'static,
   |        ^^^^^^^^^^^^ required by this bound in `AsyncStreamSender::<T, CAP>::send`
...
26 |     pub fn send(&self, value: T) -> Result<(), T> {
   |            ---- required by a bound in this associated function
   = note: this error originates in the macro `emit` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0277]: the trait bound `OcspStatus: std::default::Default` is not satisfied
  --> packages/http3/src/tls/ocsp.rs:96:25
   |
96 |                         emit!(sender, cached.status);
   |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `std::default::Default` is not implemented for `OcspStatus`
   |
note: required by a bound in `AsyncStreamSender::<T, CAP>::send`
  --> /Volumes/samsung_t9/fluent-ai/packages/async-stream/src/stream/sender.rs:19:30
   |
19 |     T: MessageChunk + Send + Default + 'static,
   |                              ^^^^^^^ required by this bound in `AsyncStreamSender::<T, CAP>::send`
...
26 |     pub fn send(&self, value: T) -> Result<(), T> {
   |            ---- required by a bound in this associated function
   = note: this error originates in the macro `emit` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0599]: the method `send` exists for struct `AsyncStreamSender<OcspStatus, _>`, but its trait bounds were not satisfied
   --> packages/http3/src/tls/ocsp.rs:107:25
    |
 23 | pub enum OcspStatus {
    | ------------------- doesn't satisfy `OcspStatus: fluent_ai_async::prelude::MessageChunk` or `OcspStatus: std::default::Default`
...
107 |                         emit!(sender, status);
    |                         ^^^^^^^^^^^^^^^^^^^^^ method cannot be called on `AsyncStreamSender<OcspStatus, _>` due to unsatisfied trait bounds
    |
    = note: the following trait bounds were not satisfied:
            `OcspStatus: fluent_ai_async::prelude::MessageChunk`
            `OcspStatus: std::default::Default`
note: the traits `fluent_ai_async::prelude::MessageChunk` and `std::default::Default` must be implemented
   --> /Users/davidmaple/.rustup/toolchains/nightly-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/default.rs:108:1
    |
108 | pub trait Default: Sized {
    | ^^^^^^^^^^^^^^^^^^^^^^^^
    |
   ::: /Users/davidmaple/.cargo/git/checkouts/cyrup-sugars-291ac2b5c478a1ed/150c82d/packages/builders/src/chunk_handler.rs:8:1
    |
  8 | pub trait MessageChunk: Sized {
    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    = note: this error originates in the macro `emit` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0599]: the method `send` exists for struct `AsyncStreamSender<OcspStatus, _>`, but its trait bounds were not satisfied
   --> packages/http3/src/tls/ocsp.rs:110:25
    |
 23 | pub enum OcspStatus {
    | ------------------- doesn't satisfy `OcspStatus: fluent_ai_async::prelude::MessageChunk` or `OcspStatus: std::default::Default`
...
110 |                         emit!(sender, OcspStatus::Unknown);
    |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ method cannot be called on `AsyncStreamSender<OcspStatus, _>` due to unsatisfied trait bounds
    |
    = note: the following trait bounds were not satisfied:
            `OcspStatus: fluent_ai_async::prelude::MessageChunk`
            `OcspStatus: std::default::Default`
note: the traits `fluent_ai_async::prelude::MessageChunk` and `std::default::Default` must be implemented
   --> /Users/davidmaple/.rustup/toolchains/nightly-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/default.rs:108:1
    |
108 | pub trait Default: Sized {
    | ^^^^^^^^^^^^^^^^^^^^^^^^
    |
   ::: /Users/davidmaple/.cargo/git/checkouts/cyrup-sugars-291ac2b5c478a1ed/150c82d/packages/builders/src/chunk_handler.rs:8:1
    |
  8 | pub trait MessageChunk: Sized {
    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    = note: this error originates in the macro `emit` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0308]: mismatched types
   --> packages/http3/src/tls/ocsp.rs:219:19
    |
219 |             .body(ocsp_request)
    |              ---- ^^^^^^^^^^^^ expected `&_`, found `Vec<u8>`
    |              |
    |              arguments to this method are incorrect
    |
    = note: expected reference `&_`
                  found struct `Vec<u8>`
note: method defined here
   --> packages/http3/src/builder/body.rs:66:12
    |
 66 |     pub fn body<T: Serialize>(self, body: &T) -> Http3Builder<BodySet> {
    |            ^^^^                     --------
help: consider borrowing here
    |
219 |             .body(&ocsp_request)
    |                   +

error[E0599]: no method named `collect_one` found for struct `fluent_ai_async::AsyncStream<T, CAP>` in the current scope
   --> packages/http3/src/tls/ocsp.rs:221:14
    |
217 |           let response_bytes = crate::Http3::new()
    |  ______________________________-
218 | |             .header("Content-Type", "application/ocsp-request")
219 | |             .body(ocsp_request)
220 | |             .post(ocsp_url)
221 | |             .collect_one::<Vec<u8>>()
    | |_____________-^^^^^^^^^^^
    |
help: there is a method `collect` with a similar name
    |
221 -             .collect_one::<Vec<u8>>()
221 +             .collect::<Vec<u8>>()
    |

error[E0308]: mismatched types
  --> packages/http3/src/tls/tls_manager.rs:27:18
   |
27 |         subject: "Unknown".to_string(),
   |                  ^^^^^^^^^^^^^^^^^^^^^ expected `HashMap<String, String>`, found `String`
   |
   = note: expected struct `HashMap<std::string::String, std::string::String>`
              found struct `std::string::String`

error[E0063]: missing fields `is_ca`, `issuer`, `key_algorithm` and 6 other fields in initializer of `tls::types::ParsedCertificate`
  --> packages/http3/src/tls/tls_manager.rs:26:8
   |
26 |     Ok(TypesParsedCertificate {
   |        ^^^^^^^^^^^^^^^^^^^^^^ missing `is_ca`, `issuer`, `key_algorithm` and 6 other fields

error[E0599]: no variant or associated item named `Internal` found for enum `TlsError` in the current scope
   --> packages/http3/src/tls/tls_manager.rs:134:36
    |
134 |             .map_err(|_| TlsError::Internal("Failed to acquire CA lock".to_string()))?;
    |                                    ^^^^^^^^ variant or associated item not found in `TlsError`
    |
   ::: packages/http3/src/tls/errors.rs:5:1
    |
  5 | pub enum TlsError {
    | ----------------- variant or associated item `Internal` not found for this enum

error[E0225]: only auto traits can be used as additional traits in a trait object
   --> packages/http3/src/tls/tls_manager.rs:163:87
    |
163 |                         let error_conn = Box::new(std::io::empty()) as Box<dyn Read + Write + Unpin + Send + 'static>;
    |                                                                                ----   ^^^^^ additional non-auto trait
    |                                                                                |
    |                                                                                first non-auto trait
    |
    = help: consider creating a new trait with all of these as supertraits and using that trait here instead: `trait NewTrait: std::io::Read + std::io::Write {}`
    = note: auto-traits like `Send` and `Sync` are traits that have special properties; for more information on them, visit <https://doc.rust-lang.org/reference/special-types-and-traits.html#auto-traits>

error[E0225]: only auto traits can be used as additional traits in a trait object
   --> packages/http3/src/tls/tls_manager.rs:173:87
    |
173 |                         let error_conn = Box::new(std::io::empty()) as Box<dyn Read + Write + Unpin + Send + 'static>;
    |                                                                                ----   ^^^^^ additional non-auto trait
    |                                                                                |
    |                                                                                first non-auto trait
    |
    = help: consider creating a new trait with all of these as supertraits and using that trait here instead: `trait NewTrait: std::io::Read + std::io::Write {}`
    = note: auto-traits like `Send` and `Sync` are traits that have special properties; for more information on them, visit <https://doc.rust-lang.org/reference/special-types-and-traits.html#auto-traits>

error[E0225]: only auto traits can be used as additional traits in a trait object
   --> packages/http3/src/tls/tls_manager.rs:183:87
    |
183 |                         let error_conn = Box::new(std::io::empty()) as Box<dyn Read + Write + Unpin + Send + 'static>;
    |                                                                                ----   ^^^^^ additional non-auto trait
    |                                                                                |
    |                                                                                first non-auto trait
    |
    = help: consider creating a new trait with all of these as supertraits and using that trait here instead: `trait NewTrait: std::io::Read + std::io::Write {}`
    = note: auto-traits like `Send` and `Sync` are traits that have special properties; for more information on them, visit <https://doc.rust-lang.org/reference/special-types-and-traits.html#auto-traits>

error[E0225]: only auto traits can be used as additional traits in a trait object
   --> packages/http3/src/tls/tls_manager.rs:193:87
    |
193 |                         let error_conn = Box::new(std::io::empty()) as Box<dyn Read + Write + Unpin + Send + 'static>;
    |                                                                                ----   ^^^^^ additional non-auto trait
    |                                                                                |
    |                                                                                first non-auto trait
    |
    = help: consider creating a new trait with all of these as supertraits and using that trait here instead: `trait NewTrait: std::io::Read + std::io::Write {}`
    = note: auto-traits like `Send` and `Sync` are traits that have special properties; for more information on them, visit <https://doc.rust-lang.org/reference/special-types-and-traits.html#auto-traits>

error[E0225]: only auto traits can be used as additional traits in a trait object
   --> packages/http3/src/tls/tls_manager.rs:203:75
    |
203 |                 let boxed_stream = Box::new(tls_stream) as Box<dyn Read + Write + Unpin + Send + 'static>;
    |                                                                    ----   ^^^^^ additional non-auto trait
    |                                                                    |
    |                                                                    first non-auto trait
    |
    = help: consider creating a new trait with all of these as supertraits and using that trait here instead: `trait NewTrait: std::io::Read + std::io::Write {}`
    = note: auto-traits like `Send` and `Sync` are traits that have special properties; for more information on them, visit <https://doc.rust-lang.org/reference/special-types-and-traits.html#auto-traits>

error[E0308]: mismatched types
   --> packages/http3/src/tls/tls_manager.rs:217:17
    |
216 |             match rustls_native_certs::load_native_certs() {
    |                   ---------------------------------------- this expression has type `CertificateResult`
217 |                 Ok(certs) => {
    |                 ^^^^^^^^^ expected `CertificateResult`, found `Result<_, _>`
    |
    = note: expected struct `CertificateResult`
                 found enum `std::result::Result<_, _>`

error[E0308]: mismatched types
   --> packages/http3/src/tls/tls_manager.rs:225:17
    |
216 |             match rustls_native_certs::load_native_certs() {
    |                   ---------------------------------------- this expression has type `CertificateResult`
...
225 |                 Err(e) => {
    |                 ^^^^^^ expected `CertificateResult`, found `Result<_, _>`
    |
    = note: expected struct `CertificateResult`
                 found enum `std::result::Result<_, _>`

error[E0277]: `HashMap<std::string::String, std::string::String>` doesn't implement `std::fmt::Display`
   --> packages/http3/src/tls/tls_manager.rs:241:70
    |
241 |                 tracing::debug!("Added custom root certificate: {}", cert.subject);
    |                                                                 --   ^^^^^^^^^^^^ `HashMap<std::string::String, std::string::String>` cannot be formatted with the default formatter
    |                                                                 |
    |                                                                 required by this formatting parameter
    |
    = help: the trait `std::fmt::Display` is not implemented for `HashMap<std::string::String, std::string::String>`
    = note: in format strings you may be able to use `{:?}` (or {:#?} for pretty-print) instead
    = note: this error originates in the macro `$crate::__macro_support::format_args` which comes from the expansion of the macro `tracing::debug` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0599]: no variant or associated item named `Internal` found for enum `TlsError` in the current scope
   --> packages/http3/src/tls/tls_manager.rs:247:36
    |
247 |             .map_err(|_| TlsError::Internal("Failed to acquire CA lock".to_string()))?;
    |                                    ^^^^^^^^ variant or associated item not found in `TlsError`
    |
   ::: packages/http3/src/tls/errors.rs:5:1
    |
  5 | pub enum TlsError {
    | ----------------- variant or associated item `Internal` not found for this enum

error[E0616]: field `contents` of struct `pem::Pem` is private
   --> packages/http3/src/tls/tls_manager.rs:253:81
    |
253 |                     let cert = rustls::pki_types::CertificateDer::from(cert_der.contents);
    |                                                                                 ^^^^^^^^ private field
    |
help: a method `contents` also exists, call it with parentheses
    |
253 |                     let cert = rustls::pki_types::CertificateDer::from(cert_der.contents());
    |                                                                                         ++

error[E0599]: no method named `with_custom_certificate_verifier` found for struct `ConfigBuilder<Side, State>` in the current scope
   --> packages/http3/src/tls/tls_manager.rs:280:14
    |
279 |           let mut client_config = config_builder
    |  _________________________________-
280 | |             .with_custom_certificate_verifier(verifier)
    | |             -^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ method not found in `ConfigBuilder<ClientConfig, WantsClientCert>`
    | |_____________|
    |

error[E0599]: the method `next` exists for struct `fluent_ai_async::AsyncStream<OcspStatus>`, but its trait bounds were not satisfied
   --> packages/http3/src/tls/tls_manager.rs:364:50
    |
364 |                     if let Some(status) = stream.next() {
    |                                                  ^^^^ method cannot be called on `fluent_ai_async::AsyncStream<OcspStatus>` due to unsatisfied trait bounds
    |
   ::: packages/http3/src/tls/ocsp.rs:23:1
    |
 23 | pub enum OcspStatus {
    | ------------------- doesn't satisfy `OcspStatus: fluent_ai_async::prelude::MessageChunk` or `OcspStatus: std::default::Default`
    |
    = note: the following trait bounds were not satisfied:
            `OcspStatus: fluent_ai_async::prelude::MessageChunk`
            `OcspStatus: std::default::Default`
note: the traits `fluent_ai_async::prelude::MessageChunk` and `std::default::Default` must be implemented
   --> /Users/davidmaple/.rustup/toolchains/nightly-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/default.rs:108:1
    |
108 | pub trait Default: Sized {
    | ^^^^^^^^^^^^^^^^^^^^^^^^
    |
   ::: /Users/davidmaple/.cargo/git/checkouts/cyrup-sugars-291ac2b5c478a1ed/150c82d/packages/builders/src/chunk_handler.rs:8:1
    |
  8 | pub trait MessageChunk: Sized {
    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0308]: mismatched types
   --> packages/http3/src/tls/tls_manager.rs:373:17
    |
372 |             match ocsp_task.collect() {
    |                   ------------------- this expression has type `std::result::Result<OcspStatus, crossbeam::crossbeam_channel::RecvError>`
373 |                 OcspStatus::Revoked => {
    |                 ^^^^^^^^^^^^^^^^^^^ expected `Result<OcspStatus, RecvError>`, found `OcspStatus`
    |
   ::: packages/http3/src/tls/ocsp.rs:25:5
    |
 25 |     Revoked,
    |     ------- unit variant defined here
    |
    = note: expected enum `std::result::Result<OcspStatus, crossbeam::crossbeam_channel::RecvError>`
               found enum `OcspStatus`
help: try wrapping the pattern in `Ok`
    |
373 |                 Ok(OcspStatus::Revoked) => {
    |                 +++                   +

error[E0308]: mismatched types
   --> packages/http3/src/tls/tls_manager.rs:376:17
    |
372 |             match ocsp_task.collect() {
    |                   ------------------- this expression has type `std::result::Result<OcspStatus, crossbeam::crossbeam_channel::RecvError>`
...
376 |                 OcspStatus::Good => {
    |                 ^^^^^^^^^^^^^^^^ expected `Result<OcspStatus, RecvError>`, found `OcspStatus`
    |
   ::: packages/http3/src/tls/ocsp.rs:24:5
    |
 24 |     Good,
    |     ---- unit variant defined here
    |
    = note: expected enum `std::result::Result<OcspStatus, crossbeam::crossbeam_channel::RecvError>`
               found enum `OcspStatus`
help: try wrapping the pattern in `Ok`
    |
376 |                 Ok(OcspStatus::Good) => {
    |                 +++                +

error[E0308]: mismatched types
   --> packages/http3/src/tls/tls_manager.rs:379:17
    |
372 |             match ocsp_task.collect() {
    |                   ------------------- this expression has type `std::result::Result<OcspStatus, crossbeam::crossbeam_channel::RecvError>`
...
379 |                 OcspStatus::Unknown => {
    |                 ^^^^^^^^^^^^^^^^^^^ expected `Result<OcspStatus, RecvError>`, found `OcspStatus`
    |
   ::: packages/http3/src/tls/ocsp.rs:26:5
    |
 26 |     Unknown,
    |     ------- unit variant defined here
    |
    = note: expected enum `std::result::Result<OcspStatus, crossbeam::crossbeam_channel::RecvError>`
               found enum `OcspStatus`
help: try wrapping the pattern in `Ok`
    |
379 |                 Ok(OcspStatus::Unknown) => {
    |                 +++                   +

error[E0277]: `rustls::pki_types::ServerName<'_>` doesn't implement `std::fmt::Display`
   --> packages/http3/src/tls/tls_manager.rs:377:70
    |
377 |                     tracing::debug!("OCSP validation passed for {}", server_name);
    |                                                                 --   ^^^^^^^^^^^ `rustls::pki_types::ServerName<'_>` cannot be formatted with the default formatter
    |                                                                 |
    |                                                                 required by this formatting parameter
    |
    = help: the trait `std::fmt::Display` is not implemented for `rustls::pki_types::ServerName<'_>`
    = note: in format strings you may be able to use `{:?}` (or {:#?} for pretty-print) instead
    = note: required for `&rustls::pki_types::ServerName<'_>` to implement `std::fmt::Display`
    = note: this error originates in the macro `$crate::__macro_support::format_args` which comes from the expansion of the macro `tracing::debug` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0277]: `rustls::pki_types::ServerName<'_>` doesn't implement `std::fmt::Display`
   --> packages/http3/src/tls/tls_manager.rs:380:66
    |
380 |                     tracing::warn!("OCSP status unknown for {}", server_name);
    |                                                             --   ^^^^^^^^^^^ `rustls::pki_types::ServerName<'_>` cannot be formatted with the default formatter
    |                                                             |
    |                                                             required by this formatting parameter
    |
    = help: the trait `std::fmt::Display` is not implemented for `rustls::pki_types::ServerName<'_>`
    = note: in format strings you may be able to use `{:?}` (or {:#?} for pretty-print) instead
    = note: required for `&rustls::pki_types::ServerName<'_>` to implement `std::fmt::Display`
    = note: this error originates in the macro `$crate::__macro_support::format_args` which comes from the expansion of the macro `tracing::warn` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0599]: the method `next` exists for struct `fluent_ai_async::AsyncStream<CrlStatus>`, but its trait bounds were not satisfied
   --> packages/http3/src/tls/tls_manager.rs:395:50
    |
395 |                     if let Some(status) = stream.next() {
    |                                                  ^^^^ method cannot be called on `fluent_ai_async::AsyncStream<CrlStatus>` due to unsatisfied trait bounds
    |
   ::: packages/http3/src/tls/crl_cache.rs:18:1
    |
 18 | pub enum CrlStatus {
    | ------------------ doesn't satisfy `CrlStatus: std::default::Default`
    |
    = note: the following trait bounds were not satisfied:
            `CrlStatus: std::default::Default`
note: the trait `std::default::Default` must be implemented
   --> /Users/davidmaple/.rustup/toolchains/nightly-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/default.rs:108:1
    |
108 | pub trait Default: Sized {
    | ^^^^^^^^^^^^^^^^^^^^^^^^

error[E0308]: mismatched types
   --> packages/http3/src/tls/tls_manager.rs:404:17
    |
403 |             match crl_task.collect() {
    |                   ------------------ this expression has type `std::result::Result<CrlStatus, crossbeam::crossbeam_channel::RecvError>`
404 |                 CrlStatus::Revoked => {
    |                 ^^^^^^^^^^^^^^^^^^ expected `Result<CrlStatus, RecvError>`, found `CrlStatus`
    |
   ::: packages/http3/src/tls/crl_cache.rs:20:5
    |
 20 |     Revoked,
    |     ------- unit variant defined here
    |
    = note: expected enum `std::result::Result<CrlStatus, crossbeam::crossbeam_channel::RecvError>`
               found enum `CrlStatus`
help: try wrapping the pattern in `Ok`
    |
404 |                 Ok(CrlStatus::Revoked) => {
    |                 +++                  +

error[E0308]: mismatched types
   --> packages/http3/src/tls/tls_manager.rs:407:17
    |
403 |             match crl_task.collect() {
    |                   ------------------ this expression has type `std::result::Result<CrlStatus, crossbeam::crossbeam_channel::RecvError>`
...
407 |                 CrlStatus::Valid => {
    |                 ^^^^^^^^^^^^^^^^ expected `Result<CrlStatus, RecvError>`, found `CrlStatus`
    |
   ::: packages/http3/src/tls/crl_cache.rs:19:5
    |
 19 |     Valid,
    |     ----- unit variant defined here
    |
    = note: expected enum `std::result::Result<CrlStatus, crossbeam::crossbeam_channel::RecvError>`
               found enum `CrlStatus`
help: try wrapping the pattern in `Ok`
    |
407 |                 Ok(CrlStatus::Valid) => {
    |                 +++                +

error[E0308]: mismatched types
   --> packages/http3/src/tls/tls_manager.rs:410:17
    |
403 |             match crl_task.collect() {
    |                   ------------------ this expression has type `std::result::Result<CrlStatus, crossbeam::crossbeam_channel::RecvError>`
...
410 |                 CrlStatus::Unknown => {
    |                 ^^^^^^^^^^^^^^^^^^ expected `Result<CrlStatus, RecvError>`, found `CrlStatus`
    |
   ::: packages/http3/src/tls/crl_cache.rs:21:5
    |
 21 |     Unknown,
    |     ------- unit variant defined here
    |
    = note: expected enum `std::result::Result<CrlStatus, crossbeam::crossbeam_channel::RecvError>`
               found enum `CrlStatus`
help: try wrapping the pattern in `Ok`
    |
410 |                 Ok(CrlStatus::Unknown) => {
    |                 +++                  +

error[E0277]: `rustls::pki_types::ServerName<'_>` doesn't implement `std::fmt::Display`
   --> packages/http3/src/tls/tls_manager.rs:408:69
    |
408 |                     tracing::debug!("CRL validation passed for {}", server_name);
    |                                                                --   ^^^^^^^^^^^ `rustls::pki_types::ServerName<'_>` cannot be formatted with the default formatter
    |                                                                |
    |                                                                required by this formatting parameter
    |
    = help: the trait `std::fmt::Display` is not implemented for `rustls::pki_types::ServerName<'_>`
    = note: in format strings you may be able to use `{:?}` (or {:#?} for pretty-print) instead
    = note: required for `&rustls::pki_types::ServerName<'_>` to implement `std::fmt::Display`
    = note: this error originates in the macro `$crate::__macro_support::format_args` which comes from the expansion of the macro `tracing::debug` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0277]: `rustls::pki_types::ServerName<'_>` doesn't implement `std::fmt::Display`
   --> packages/http3/src/tls/tls_manager.rs:411:65
    |
411 |                     tracing::warn!("CRL status unknown for {}", server_name);
    |                                                            --   ^^^^^^^^^^^ `rustls::pki_types::ServerName<'_>` cannot be formatted with the default formatter
    |                                                            |
    |                                                            required by this formatting parameter
    |
    = help: the trait `std::fmt::Display` is not implemented for `rustls::pki_types::ServerName<'_>`
    = note: in format strings you may be able to use `{:?}` (or {:#?} for pretty-print) instead
    = note: required for `&rustls::pki_types::ServerName<'_>` to implement `std::fmt::Display`
    = note: this error originates in the macro `$crate::__macro_support::format_args` which comes from the expansion of the macro `tracing::warn` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0277]: `rustls::pki_types::ServerName<'_>` doesn't implement `std::fmt::Display`
   --> packages/http3/src/tls/tls_manager.rs:416:78
    |
416 |         tracing::info!("Enterprise certificate validation completed for {}", server_name);
    |                                                                         --   ^^^^^^^^^^^ `rustls::pki_types::ServerName<'_>` cannot be formatted with the default formatter
    |                                                                         |
    |                                                                         required by this formatting parameter
    |
    = help: the trait `std::fmt::Display` is not implemented for `rustls::pki_types::ServerName<'_>`
    = note: in format strings you may be able to use `{:?}` (or {:#?} for pretty-print) instead
    = note: required for `&rustls::pki_types::ServerName<'_>` to implement `std::fmt::Display`
    = note: this error originates in the macro `$crate::__macro_support::format_args` which comes from the expansion of the macro `tracing::info` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0599]: the method `join` exists for struct `Vec<&std::string::String>`, but its trait bounds were not satisfied
  --> packages/http3/src/tls/builder/responses.rs:66:14
   |
61 | /         self.issues
62 | |             .iter()
63 | |             .filter(|i| matches!(i.severity, IssueSeverity::Error))
64 | |             .map(|i| &i.message)
65 | |             .collect::<Vec<_>>()
66 | |             .join("; ")
   | |             -^^^^ method cannot be called on `Vec<&std::string::String>` due to unsatisfied trait bounds
   | |_____________|
   |
   |
   = note: the following trait bounds were not satisfied:
           `[&std::string::String]: std::slice::Join<_>`

error[E0599]: no method named `stats_snapshot` found for reference `&client::core::HttpClient` in the current scope
   --> packages/http3/src/lib.rs:140:30
    |
140 |     global_client().as_ref().stats_snapshot()
    |                              ^^^^^^^^^^^^^^ method not found in `&client::core::HttpClient`

error[E0599]: no function or associated item named `new_direct` found for struct `client::core::HttpClient` in the current scope
   --> packages/http3/src/lib.rs:212:49
    |
212 |     let new_client = crate::client::HttpClient::new_direct(config, stats);
    |                                                 ^^^^^^^^^^ function or associated item not found in `client::core::HttpClient`
    |
   ::: packages/http3/src/client/core.rs:44:1
    |
 44 | pub struct HttpClient {
    | --------------------- function or associated item `new_direct` not found for this struct
    |
note: if you're trying to build a new `client::core::HttpClient` consider using one of the following associated functions:
      client::configuration::<impl client::core::HttpClient>::with_config
      client::core::HttpClient::new
      client::core::HttpClient::ai_optimized
      client::core::HttpClient::streaming_optimized
      and 2 others
   --> packages/http3/src/client/configuration.rs:91:5
    |
 91 |     pub fn with_config(config: HttpConfig) -> Result<Self, HttpError> {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    |
   ::: packages/http3/src/client/core.rs:65:5
    |
 65 |     pub fn new() -> Self {
    |     ^^^^^^^^^^^^^^^^^^^^
...
 79 |     pub fn ai_optimized() -> Self {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
...
 93 |     pub fn streaming_optimized() -> Self {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `Engine`
 --> packages/http3/src/auth/builder.rs:5:14
  |
5 | use base64::{Engine as _, engine::general_purpose::STANDARD};
  |              ^^^^^^

warning: unused import: `prelude::MessageChunk`
 --> packages/http3/src/cache/cache_integration.rs:8:36
  |
8 | use fluent_ai_async::{AsyncStream, prelude::MessageChunk};
  |                                    ^^^^^^^^^^^^^^^^^^^^^

warning: variable does not need to be mutable
  --> packages/http3/src/builder/builder_core.rs:64:37
   |
64 | ...                   let mut request = HttpRequest::new(
   |                           ----^^^^^^^
   |                           |
   |                           help: remove this `mut`
   |
   = note: `#[warn(unused_mut)]` on by default

warning: variable does not need to be mutable
  --> packages/http3/src/builder/fluent.rs:87:17
   |
87 |             let mut total_size = None;
   |                 ----^^^^^^^^^^
   |                 |
   |                 help: remove this `mut`

warning: variable does not need to be mutable
  --> packages/http3/src/builder/fluent.rs:82:13
   |
82 |         let mut stream = self.stream;
   |             ----^^^^^^
   |             |
   |             help: remove this `mut`

warning: unused variable: `jsonpath_expr`
  --> packages/http3/src/builder/streaming.rs:92:84
   |
92 |     pub fn new(http_response_stream: AsyncStream<crate::prelude::HttpResponse, 1>, jsonpath_expr: String) -> Self {
   |                                                                                    ^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_jsonpath_expr`
   |
   = note: `#[warn(unused_variables)]` on by default

warning: unused variable: `window`
   --> packages/http3/src/builder/trait_impls.rs:121:50
    |
121 |     pub fn http3_stream_receive_window(mut self, window: u32) -> Self {
    |                                                  ^^^^^^ help: if this is intentional, prefix it with an underscore: `_window`

warning: variable does not need to be mutable
   --> packages/http3/src/builder/trait_impls.rs:121:40
    |
121 |     pub fn http3_stream_receive_window(mut self, window: u32) -> Self {
    |                                        ----^^^^
    |                                        |
    |                                        help: remove this `mut`

warning: unused variable: `window`
   --> packages/http3/src/builder/trait_impls.rs:128:48
    |
128 |     pub fn http3_conn_receive_window(mut self, window: u32) -> Self {
    |                                                ^^^^^^ help: if this is intentional, prefix it with an underscore: `_window`

warning: variable does not need to be mutable
   --> packages/http3/src/builder/trait_impls.rs:128:38
    |
128 |     pub fn http3_conn_receive_window(mut self, window: u32) -> Self {
    |                                      ----^^^^
    |                                      |
    |                                      help: remove this `mut`

warning: unused variable: `window`
   --> packages/http3/src/builder/trait_impls.rs:135:40
    |
135 |     pub fn http3_send_window(mut self, window: u32) -> Self {
    |                                        ^^^^^^ help: if this is intentional, prefix it with an underscore: `_window`

warning: variable does not need to be mutable
   --> packages/http3/src/builder/trait_impls.rs:135:30
    |
135 |     pub fn http3_send_window(mut self, window: u32) -> Self {
    |                              ----^^^^
    |                              |
    |                              help: remove this `mut`

warning: unused variable: `enable`
   --> packages/http3/src/builder/trait_impls.rs:142:43
    |
142 |     pub fn http3_congestion_bbr(mut self, enable: bool) -> Self {
    |                                           ^^^^^^ help: if this is intentional, prefix it with an underscore: `_enable`

warning: variable does not need to be mutable
   --> packages/http3/src/builder/trait_impls.rs:142:33
    |
142 |     pub fn http3_congestion_bbr(mut self, enable: bool) -> Self {
    |                                 ----^^^^
    |                                 |
    |                                 help: remove this `mut`

warning: unused variable: `size`
   --> packages/http3/src/builder/trait_impls.rs:149:51
    |
149 |     pub fn http3_max_field_section_size(mut self, size: u64) -> Self {
    |                                                   ^^^^ help: if this is intentional, prefix it with an underscore: `_size`

warning: variable does not need to be mutable
   --> packages/http3/src/builder/trait_impls.rs:149:41
    |
149 |     pub fn http3_max_field_section_size(mut self, size: u64) -> Self {
    |                                         ----^^^^
    |                                         |
    |                                         help: remove this `mut`

warning: unused variable: `enable`
   --> packages/http3/src/builder/trait_impls.rs:156:40
    |
156 |     pub fn http3_send_grease(mut self, enable: bool) -> Self {
    |                                        ^^^^^^ help: if this is intentional, prefix it with an underscore: `_enable`

warning: variable does not need to be mutable
   --> packages/http3/src/builder/trait_impls.rs:156:30
    |
156 |     pub fn http3_send_grease(mut self, enable: bool) -> Self {
    |                              ----^^^^
    |                              |
    |                              help: remove this `mut`

warning: unused variable: `enable`
   --> packages/http3/src/builder/trait_impls.rs:170:44
    |
170 |     pub fn http2_adaptive_window(mut self, enable: bool) -> Self {
    |                                            ^^^^^^ help: if this is intentional, prefix it with an underscore: `_enable`

warning: variable does not need to be mutable
   --> packages/http3/src/builder/trait_impls.rs:170:34
    |
170 |     pub fn http2_adaptive_window(mut self, enable: bool) -> Self {
    |                                  ----^^^^
    |                                  |
    |                                  help: remove this `mut`

warning: unused variable: `size`
   --> packages/http3/src/builder/trait_impls.rs:177:43
    |
177 |     pub fn http2_max_frame_size(mut self, size: u32) -> Self {
    |                                           ^^^^ help: if this is intentional, prefix it with an underscore: `_size`

warning: variable does not need to be mutable
   --> packages/http3/src/builder/trait_impls.rs:177:33
    |
177 |     pub fn http2_max_frame_size(mut self, size: u32) -> Self {
    |                                 ----^^^^
    |                                 |
    |                                 help: remove this `mut`

warning: unused variable: `version`
  --> packages/http3/src/cache/response_cache/operations.rs:54:13
   |
54 |         let version = entry.version;
   |             ^^^^^^^ help: if this is intentional, prefix it with an underscore: `_version`

warning: unused variable: `enable`
  --> packages/http3/src/client/configuration.rs:76:30
   |
76 |     pub fn deflate(mut self, enable: bool) -> Self {
   |                              ^^^^^^ help: if this is intentional, prefix it with an underscore: `_enable`

warning: variable does not need to be mutable
  --> packages/http3/src/client/configuration.rs:76:20
   |
76 |     pub fn deflate(mut self, enable: bool) -> Self {
   |                    ----^^^^
   |                    |
   |                    help: remove this `mut`

error[E0507]: cannot move out of `self.strategy` which is behind a shared reference
   --> packages/http3/src/client/core.rs:228:24
    |
228 |         let strategy = self.strategy;
    |                        ^^^^^^^^^^^^^ move occurs because `self.strategy` has type `HttpProtocolStrategy`, which does not implement the `Copy` trait
    |
help: consider borrowing here
    |
228 |         let strategy = &self.strategy;
    |                        +
help: consider cloning the value if the performance cost is acceptable
    |
228 |         let strategy = self.strategy.clone();
    |                                     ++++++++

warning: variable does not need to be mutable
  --> packages/http3/src/connect/service/interface.rs:19:21
   |
19 |                 let mut connection_stream =
   |                     ----^^^^^^^^^^^^^^^^^
   |                     |
   |                     help: remove this `mut`

warning: unused variable: `error`
  --> packages/http3/src/connect/types/tcp_impl.rs:31:18
   |
31 |     fn bad_chunk(error: String) -> Self {
   |                  ^^^^^ help: if this is intentional, prefix it with an underscore: `_error`

warning: unused variable: `hostname`
   --> packages/http3/src/http/resolver/core.rs:238:32
    |
238 |     fn check_rate_limit(&self, hostname: &str, query_type: &str) -> Result<(), String> {
    |                                ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_hostname`

warning: unused variable: `query_type`
   --> packages/http3/src/http/resolver/core.rs:238:48
    |
238 |     fn check_rate_limit(&self, hostname: &str, query_type: &str) -> Result<(), String> {
    |                                                ^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_query_type`

warning: unused variable: `error`
   --> packages/http3/src/http/response.rs:453:18
    |
453 |     fn bad_chunk(error: String) -> Self {
    |                  ^^^^^ help: if this is intentional, prefix it with an underscore: `_error`

warning: unused variable: `e`
 --> packages/http3/src/http/url.rs:8:46
  |
8 |     Url::parse(url_str).map(|_| ()).map_err(|e| {
  |                                              ^ help: if this is intentional, prefix it with an underscore: `_e`

warning: unused variable: `e`
  --> packages/http3/src/http/url.rs:22:48
   |
22 |     let mut url = Url::parse(url_str).map_err(|e| {
   |                                                ^ help: if this is intentional, prefix it with an underscore: `_e`

warning: unused variable: `e`
  --> packages/http3/src/http/url.rs:52:34
   |
52 |     Url::parse(url_str).map_err(|e| {
   |                                  ^ help: if this is intentional, prefix it with an underscore: `_e`

warning: unused variable: `e`
  --> packages/http3/src/http/url.rs:92:45
   |
92 |     let mut url = Url::parse(base).map_err(|e| {
   |                                             ^ help: if this is intentional, prefix it with an underscore: `_e`

warning: unused variable: `index`
  --> packages/http3/src/jsonpath/core_evaluator/filter_evaluation.rs:45:9
   |
45 |         index: usize,
   |         ^^^^^ help: if this is intentional, prefix it with an underscore: `_index`

warning: unused variable: `key`
  --> packages/http3/src/jsonpath/core_evaluator/filter_evaluation.rs:85:9
   |
85 |         key: &str,
   |         ^^^ help: if this is intentional, prefix it with an underscore: `_key`

warning: unused variable: `value`
  --> packages/http3/src/jsonpath/core_evaluator/recursive_descent.rs:88:9
   |
88 |         value: &Value,
   |         ^^^^^ help: if this is intentional, prefix it with an underscore: `_value`

warning: unused variable: `selectors`
  --> packages/http3/src/jsonpath/core_evaluator/recursive_descent.rs:89:9
   |
89 |         selectors: &[crate::jsonpath::ast::JsonSelector],
   |         ^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_selectors`

warning: unused variable: `from_end`
  --> packages/http3/src/jsonpath/core_evaluator/selector_application.rs:35:42
   |
35 |             JsonSelector::Index { index, from_end } => {
   |                                          ^^^^^^^^ help: try ignoring the field: `from_end: _`

warning: unused variable: `handle`
  --> packages/http3/src/jsonpath/core_evaluator/timeout_protection.rs:39:13
   |
39 |         let handle = thread::spawn(move || {
   |             ^^^^^^ help: if this is intentional, prefix it with an underscore: `_handle`

warning: unused variable: `array_length`
  --> packages/http3/src/jsonpath/deserializer/processor/array_selectors.rs:51:62
   |
51 | pub fn matches_slice(slice_expr: &str, current_index: usize, array_length: Option<usize>) -> bool {
   |                                                              ^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_array_length`

warning: unused variable: `array_index`
  --> packages/http3/src/jsonpath/deserializer/processor/path_evaluation.rs:27:5
   |
27 |     array_index: Option<usize>,
   |     ^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_array_index`

warning: irrefutable `if let` pattern
  --> packages/http3/src/jsonpath/error/conversions/std_conversions.rs:14:12
   |
14 |         if let line = error.line() {
   |            ^^^^^^^^^^^^^^^^^^^^^^^
   |
   = note: this pattern will always match, so the `if let` is useless
   = help: consider replacing the `if let` with a `let`
   = note: `#[warn(irrefutable_let_patterns)]` on by default

warning: unused variable: `offset`
  --> packages/http3/src/jsonpath/error/conversions/std_conversions.rs:15:17
   |
15 |             let offset = line.saturating_sub(1) * 80; // Rough estimate
   |                 ^^^^^^ help: if this is intentional, prefix it with an underscore: `_offset`

warning: unused variable: `selectors`
  --> packages/http3/src/jsonpath/filter/core.rs:32:5
   |
32 |     selectors: &[crate::jsonpath::ast::JsonSelector],
   |     ^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_selectors`

warning: unused variable: `filter_value`
  --> packages/http3/src/jsonpath/filter/properties.rs:56:9
   |
56 |     let filter_value = super::conversions::json_value_to_filter_value(current);
   |         ^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_filter_value`

warning: unused variable: `selectors`
  --> packages/http3/src/jsonpath/functions/function_evaluator/value/core.rs:46:5
   |
46 |     selectors: &[crate::jsonpath::parser::JsonSelector],
   |     ^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_selectors`

warning: unused variable: `body`
   --> packages/http3/src/jsonpath/stream_processor/core.rs:108:17
    |
108 |             for body in body_stream {
    |                 ^^^^ help: if this is intentional, prefix it with an underscore: `_body`

warning: variable does not need to be mutable
  --> packages/http3/src/jsonpath/tokenizer/characters.rs:16:5
   |
16 |     mut i: usize,
   |     ----^
   |     |
   |     help: remove this `mut`

warning: unused variable: `local_addr`
  --> packages/http3/src/protocols/connection.rs:50:29
   |
50 |     pub fn new_h2_with_addr(local_addr: std::net::SocketAddr, remote_addr: std::net::SocketAddr) -> Self {
   |                             ^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_local_addr`

warning: unused variable: `remote_addr`
  --> packages/http3/src/protocols/connection.rs:50:63
   |
50 |     pub fn new_h2_with_addr(local_addr: std::net::SocketAddr, remote_addr: std::net::SocketAddr) -> Self {
   |                                                               ^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_remote_addr`

warning: unused variable: `is_client`
  --> packages/http3/src/protocols/connection.rs:81:19
   |
81 |     pub fn new_h2(is_client: bool) -> Self {
   |                   ^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_is_client`

warning: unused variable: `is_client`
  --> packages/http3/src/protocols/connection.rs:91:19
   |
91 |     pub fn new_h3(is_client: bool) -> Self {
   |                   ^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_is_client`

warning: unused variable: `close_stream`
   --> packages/http3/src/protocols/connection.rs:274:21
    |
274 |                 let close_stream = connection.close();
    |                     ^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_close_stream`

warning: unused variable: `cursor`
   --> packages/http3/src/protocols/h3/connection.rs:129:37
    |
129 | ...                   let mut cursor = std::io::Cursor::new(&frame_buffer[..]);
    |                               ^^^^^^ help: if this is intentional, prefix it with an underscore: `_cursor`

warning: variable does not need to be mutable
   --> packages/http3/src/protocols/h3/connection.rs:129:33
    |
129 | ...                   let mut cursor = std::io::Cursor::new(&frame_buffer[..]);
    |                           ----^^^^^^
    |                           |
    |                           help: remove this `mut`

error[E0521]: borrowed data escapes outside of method
   --> packages/http3/src/protocols/h3/connection.rs:92:9
    |
 88 |       pub fn send_request(&self, request: &[u8], stream_id: u64) -> AsyncStream<HttpChunk, 1024> {
    |                                  -------  - let's call the lifetime of this reference `'1`
    |                                  |
    |                                  `request` is a reference that is only valid in the method body
...
 92 | /         AsyncStream::<HttpChunk, 1024>::with_channel(move |sender| {
 93 | |             let mut buffer = [0; 65535];
 94 | |             let backoff = Backoff::new();
...   |
213 | |         })
    | |          ^
    | |          |
    | |__________`request` escapes the method body here
    |            argument requires that `'1` must outlive `'static`

warning: unused variable: `local`
  --> packages/http3/src/protocols/quiche/chunks.rs:65:24
   |
65 |     pub fn established(local: std::net::SocketAddr, peer: std::net::SocketAddr) -> Self {
   |                        ^^^^^ help: if this is intentional, prefix it with an underscore: `_local`

warning: unused variable: `peer`
  --> packages/http3/src/protocols/quiche/chunks.rs:65:53
   |
65 |     pub fn established(local: std::net::SocketAddr, peer: std::net::SocketAddr) -> Self {
   |                                                     ^^^^ help: if this is intentional, prefix it with an underscore: `_peer`

warning: unused variable: `recv`
  --> packages/http3/src/protocols/quiche/chunks.rs:72:9
   |
72 |         recv: usize,
   |         ^^^^ help: if this is intentional, prefix it with an underscore: `_recv`

warning: unused variable: `sent`
  --> packages/http3/src/protocols/quiche/chunks.rs:73:9
   |
73 |         sent: usize,
   |         ^^^^ help: if this is intentional, prefix it with an underscore: `_sent`

warning: unused variable: `lost`
  --> packages/http3/src/protocols/quiche/chunks.rs:74:9
   |
74 |         lost: usize,
   |         ^^^^ help: if this is intentional, prefix it with an underscore: `_lost`

warning: unused variable: `rtt`
  --> packages/http3/src/protocols/quiche/chunks.rs:75:9
   |
75 |         rtt: std::time::Duration,
   |         ^^^ help: if this is intentional, prefix it with an underscore: `_rtt`

warning: unused variable: `cwnd`
  --> packages/http3/src/protocols/quiche/chunks.rs:76:9
   |
76 |         cwnd: usize,
   |         ^^^^ help: if this is intentional, prefix it with an underscore: `_cwnd`

warning: unused variable: `local`
   --> packages/http3/src/protocols/quiche/chunks.rs:130:9
    |
130 |         local: std::net::SocketAddr,
    |         ^^^^^ help: if this is intentional, prefix it with an underscore: `_local`

warning: unused variable: `peer`
   --> packages/http3/src/protocols/quiche/chunks.rs:131:9
    |
131 |         peer: std::net::SocketAddr,
    |         ^^^^ help: if this is intentional, prefix it with an underscore: `_peer`

warning: unused variable: `from`
   --> packages/http3/src/protocols/quiche/chunks.rs:144:9
    |
144 |         from: std::net::SocketAddr,
    |         ^^^^ help: if this is intentional, prefix it with an underscore: `_from`

warning: unused variable: `local`
   --> packages/http3/src/protocols/quiche/chunks.rs:145:9
    |
145 |         local: std::net::SocketAddr,
    |         ^^^^^ help: if this is intentional, prefix it with an underscore: `_local`

warning: unused variable: `bidirectional`
   --> packages/http3/src/protocols/quiche/chunks.rs:201:42
    |
201 |     pub fn stream_opened(stream_id: u64, bidirectional: bool) -> Self {
    |                                          ^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_bidirectional`

warning: unused variable: `data`
   --> packages/http3/src/protocols/quiche/chunks.rs:267:40
    |
267 |     pub fn stream_data(stream_id: u64, data: Vec<u8>, fin: bool) -> Self {
    |                                        ^^^^ help: if this is intentional, prefix it with an underscore: `_data`

warning: unused variable: `fin`
   --> packages/http3/src/protocols/quiche/chunks.rs:316:64
    |
316 |     pub fn bytes_written(stream_id: u64, bytes_written: usize, fin: bool) -> Self {
    |                                                                ^^^ help: if this is intentional, prefix it with an underscore: `_fin`

warning: unused variable: `conn_guard`
   --> packages/http3/src/protocols/quiche/h3_adapter.rs:133:25
    |
133 |                 let mut conn_guard = match conn.lock() {
    |                         ^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_conn_guard`

warning: variable does not need to be mutable
   --> packages/http3/src/protocols/quiche/h3_adapter.rs:133:21
    |
133 |                 let mut conn_guard = match conn.lock() {
    |                     ----^^^^^^^^^^
    |                     |
    |                     help: remove this `mut`

warning: unused variable: `readable_streams`
  --> packages/http3/src/protocols/quiche/streaming.rs:84:30
   |
84 |     pub fn streams_available(readable_streams: Vec<u64>, writable_streams: Vec<u64>) -> Self {
   |                              ^^^^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_readable_streams`

warning: unused variable: `writable_streams`
  --> packages/http3/src/protocols/quiche/streaming.rs:84:58
   |
84 |     pub fn streams_available(readable_streams: Vec<u64>, writable_streams: Vec<u64>) -> Self {
   |                                                          ^^^^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_writable_streams`

warning: unreachable pattern
   --> packages/http3/src/protocols/strategy.rs:545:21
    |
522 |                     crate::prelude::HttpChunk::Headers(_, _) => {
    |                     ---------------------------------------- matches all the relevant values
...
545 |                     crate::prelude::HttpChunk::Headers(_, _) => {
    |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ no value can reach this
    |
    = note: `#[warn(unreachable_patterns)]` on by default

warning: unused variable: `h3_stream`
   --> packages/http3/src/protocols/transport.rs:101:13
    |
101 |         let h3_stream = self.connection_manager.create_h3_connection(true);
    |             ^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_h3_stream`

warning: unused variable: `remote_addr`
  --> packages/http3/src/protocols/transport.rs:97:9
   |
97 |         remote_addr: SocketAddr,
   |         ^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_remote_addr`

warning: unused variable: `config`
  --> packages/http3/src/protocols/transport.rs:98:9
   |
98 |         config: TransportConfig,
   |         ^^^^^^ help: if this is intentional, prefix it with an underscore: `_config`

warning: variable `bytes_read` is assigned to, but never used
   --> packages/http3/src/protocols/wire.rs:473:21
    |
473 |             let mut bytes_read = 0;
    |                     ^^^^^^^^^^
    |
    = note: consider using `_bytes_read` instead

warning: unused variable: `custom`
  --> packages/http3/src/proxy/matcher/public_interface.rs:44:30
   |
44 |             Matcher_::Custom(custom) => {
   |                              ^^^^^^ help: if this is intentional, prefix it with an underscore: `_custom`

warning: unreachable pattern
   --> packages/http3/src/tls/certificate/parser.rs:495:9
    |
494 |         ID_RSA_ENCRYPTION => extract_rsa_key_size(public_key),
    |         ----------------- matches any value
495 |         ID_EC_PUBLIC_KEY => extract_ec_key_size(algorithm.parameters.as_ref()),
    |         ^^^^^^^^^^^^^^^^ no value can reach this

warning: unreachable pattern
   --> packages/http3/src/tls/certificate/parser.rs:496:9
    |
494 |         ID_RSA_ENCRYPTION => extract_rsa_key_size(public_key),
    |         ----------------- matches any value
495 |         ID_EC_PUBLIC_KEY => extract_ec_key_size(algorithm.parameters.as_ref()),
496 |         ID_DSA => extract_dh_like_key_size(algorithm.parameters.as_ref()),
    |         ^^^^^^ no value can reach this

warning: unreachable pattern
   --> packages/http3/src/tls/certificate/parser.rs:497:9
    |
494 |         ID_RSA_ENCRYPTION => extract_rsa_key_size(public_key),
    |         ----------------- matches any value
...
497 |         DH_PUBLIC_NUMBER => extract_dh_like_key_size(algorithm.parameters.as_ref()),
    |         ^^^^^^^^^^^^^^^^ no value can reach this

warning: unreachable pattern
   --> packages/http3/src/tls/certificate/parser.rs:498:9
    |
494 |         ID_RSA_ENCRYPTION => extract_rsa_key_size(public_key),
    |         ----------------- matches any value
...
498 |         ID_X25519 => Some(256),
    |         ^^^^^^^^^ no value can reach this

warning: unreachable pattern
   --> packages/http3/src/tls/certificate/parser.rs:499:9
    |
494 |         ID_RSA_ENCRYPTION => extract_rsa_key_size(public_key),
    |         ----------------- matches any value
...
499 |         ID_X448 => Some(448),
    |         ^^^^^^^ no value can reach this

warning: unreachable pattern
   --> packages/http3/src/tls/certificate/parser.rs:500:9
    |
494 |         ID_RSA_ENCRYPTION => extract_rsa_key_size(public_key),
    |         ----------------- matches any value
...
500 |         ID_ED25519 => Some(256),
    |         ^^^^^^^^^^ no value can reach this

warning: unreachable pattern
   --> packages/http3/src/tls/certificate/parser.rs:501:9
    |
494 |         ID_RSA_ENCRYPTION => extract_rsa_key_size(public_key),
    |         ----------------- matches any value
...
501 |         ID_ED448 => Some(448),
    |         ^^^^^^^^ no value can reach this

warning: unreachable pattern
   --> packages/http3/src/tls/certificate/parser.rs:502:9
    |
494 |         ID_RSA_ENCRYPTION => extract_rsa_key_size(public_key),
    |         ----------------- matches any value
...
502 |         _ => None
    |         ^ no value can reach this

warning: unused variable: `ID_RSA_ENCRYPTION`
   --> packages/http3/src/tls/certificate/parser.rs:494:9
    |
494 |         ID_RSA_ENCRYPTION => extract_rsa_key_size(public_key),
    |         ^^^^^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_ID_RSA_ENCRYPTION`

warning: unused variable: `ID_EC_PUBLIC_KEY`
   --> packages/http3/src/tls/certificate/parser.rs:495:9
    |
495 |         ID_EC_PUBLIC_KEY => extract_ec_key_size(algorithm.parameters.as_ref()),
    |         ^^^^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_ID_EC_PUBLIC_KEY`

warning: unused variable: `ID_DSA`
   --> packages/http3/src/tls/certificate/parser.rs:496:9
    |
496 |         ID_DSA => extract_dh_like_key_size(algorithm.parameters.as_ref()),
    |         ^^^^^^ help: if this is intentional, prefix it with an underscore: `_ID_DSA`

warning: unused variable: `DH_PUBLIC_NUMBER`
   --> packages/http3/src/tls/certificate/parser.rs:497:9
    |
497 |         DH_PUBLIC_NUMBER => extract_dh_like_key_size(algorithm.parameters.as_ref()),
    |         ^^^^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_DH_PUBLIC_NUMBER`

warning: unused variable: `ID_X25519`
   --> packages/http3/src/tls/certificate/parser.rs:498:9
    |
498 |         ID_X25519 => Some(256),
    |         ^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_ID_X25519`

warning: unused variable: `ID_X448`
   --> packages/http3/src/tls/certificate/parser.rs:499:9
    |
499 |         ID_X448 => Some(448),
    |         ^^^^^^^ help: if this is intentional, prefix it with an underscore: `_ID_X448`

warning: unused variable: `ID_ED25519`
   --> packages/http3/src/tls/certificate/parser.rs:500:9
    |
500 |         ID_ED25519 => Some(256),
    |         ^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_ID_ED25519`

warning: unused variable: `ID_ED448`
   --> packages/http3/src/tls/certificate/parser.rs:501:9
    |
501 |         ID_ED448 => Some(448),
    |         ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_ID_ED448`

Some errors have detailed explanations: E0027, E0061, E0063, E0069, E0119, E0223, E0225, E0277, E0308...
For more information about an error, try `rustc --explain E0027`.
warning: `fluent_ai_http3` (lib) generated 210 warnings
error: could not compile `fluent_ai_http3` (lib) due to 383 previous errors; 210 warnings emitted
