use anyhow::{Context, Result};
use std::fs;
use std::path::Path;
use termcolor::{info, success_check, colored_println};


pub mod providers;
pub mod codegen;

use providers::process_all_providers;

/// Main orchestrator for the modular build system
/// Coordinates all provider modules and generates the final output
pub fn generate_model_code() -> Result<()> {
    info!("Starting modular model code generation...");
    
    // Process all providers using strategy pattern with impl Trait
    let results = process_all_providers();
    
    // Check results and report status (continue even if some providers fail)
    let mut failed_providers = Vec::new();
    for result in &results {
        if result.success {
            success_check!("{}", result.status);
        } else {
            eprintln!("⚠️  Provider warning: {}", result.status);
            failed_providers.push(&result.status);
        }
    }
    
    let successful_count = results.iter().filter(|r| r.success).count();
    let total_count = results.len();
    
    // Ensure at least one provider succeeded (Anthropic should always work with static models)
    if successful_count == 0 {
        return Err(anyhow::anyhow!(
            "All {} providers failed. At least one provider (like Anthropic with static models) should succeed.", 
            total_count
        ));
    }
    
    // Report final status
    if failed_providers.is_empty() {
        success_check!("All {} providers processed successfully!", total_count);
    } else {
        colored_println!("✅ Build completed: {}/{} providers succeeded. {} providers failed (likely missing API keys).", 
                        successful_count, total_count, failed_providers.len());
    }
    
    // Write generated code file
    let output_path = Path::new("src/generated_models.rs");
    let final_code = format!(
        "// Generated code - DO NOT EDIT MANUALLY\n// This file is automatically generated by build.rs\n// Successfully processed {}/{} providers\n// Failed providers: {}\n\n// Provider implementations will be added here by each provider's process() method\n",
        successful_count, 
        total_count,
        if failed_providers.is_empty() { 
            "none".to_string() 
        } else { 
            failed_providers.iter().map(|s| s.as_str()).collect::<Vec<_>>().join(", ") 
        }
    );
    
    fs::write(output_path, final_code)
        .context("Failed to write generated_models.rs")?;
    
    success_check!("Successfully generated src/generated_models.rs");
    colored_println!("Model code generation completed successfully!");
    
    Ok(())
}

