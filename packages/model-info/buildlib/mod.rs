use anyhow::{Context, Result};
use std::fs;
use std::path::Path;
use termcolor::{info, success_check, colored_println};


pub mod providers;
pub mod codegen;
pub mod sources;

use providers::{all_providers, ProviderBuilder, ModelData};

/// Main orchestrator for the modular build system
/// Coordinates all provider modules and generates the final output
pub async fn generate_model_code() -> Result<()> {
    info!("Starting modular model code generation...");
    
    let mut all_enums = String::new();
    let mut all_impls = String::new();
    
    // Process each provider using strategy pattern
    for provider in all_providers() {
        let provider_name = provider.provider_name();
        info!("Processing {} provider...", provider_name);
        
        // Fetch models from provider API - REAL API ONLY, NO FALLBACKS
        let models = match fetch_provider_models(&provider).await {
            Ok(models) => models,
            Err(e) => {
                // Fail fast - ALL providers must use real APIs
                return Err(e).with_context(|| {
                    format!("Failed to fetch models from {} provider API. All providers must use real /v1/models endpoints.", provider_name)
                });
            }
        };
        
        if models.is_empty() {
            return Err(anyhow::anyhow!(
                "No models found for {} provider. Build cannot proceed without model data.",
                provider_name
            ));
        }
        
        // Generate code for this provider
        let (enum_code, impl_code) = provider.generate_code(&models)
            .with_context(|| format!("Failed to generate code for {} provider", provider_name))?;
        
        all_enums.push_str(&format!("\n{}\n", enum_code));
        all_impls.push_str(&format!("\n{}\n", impl_code));
        
        success_check!("Generated code for {} provider ({} models)", provider_name, models.len());
    }
    
    // Write the generated code to file
    let output_path = Path::new("src/generated_models.rs");
    let final_code = format!(
        "// Generated code - DO NOT EDIT MANUALLY\n// This file is automatically generated by build.rs\n\n{}\n{}",
        all_enums, all_impls
    );
    
    fs::write(output_path, final_code)
        .context("Failed to write generated_models.rs")?;
    
    success_check!("Successfully generated src/generated_models.rs");
    colored_println!("Model code generation completed successfully!");
    
    Ok(())
}

/// Fetch models from provider using strategy pattern - API or static data
/// All providers must provide model data through their implemented strategy
async fn fetch_provider_models(provider: &dyn ProviderBuilder) -> Result<Vec<providers::ModelData>> {
    let provider_name = provider.provider_name();
    
    // First try API endpoint if provider supports it
    let model_stream = provider.fetch_models();
    let api_models: Vec<ModelData> = model_stream.collect();
    if !api_models.is_empty() {
        info!("Fetched {} models from {} API", api_models.len(), provider_name);
        return Ok(api_models);
    }
    
    // If API didn't return data, try static models (only for providers that legitimately need them)
    if let Some(static_models) = provider.static_models() {
        if !static_models.is_empty() {
            info!("Using {} static models for {} provider", static_models.len(), provider_name);
            return Ok(static_models);
        }
    }
    
    // Provider has no model data available
    Err(anyhow::anyhow!(
        "Provider {} returned no model data from API or static sources",
        provider_name
    ))
}