use std::fs;
use std::path::Path;

use anyhow::{Context, Result};
use termcolor::{colored_println, info, success_check};

pub mod cache;
pub mod codegen;
pub mod providers;

/// Pure syn-based code generation using RUNTIME src/* providers
pub fn generate_model_code() -> Result<()> {
    info!("Starting syn code generation from src/* runtime providers...");

    // Use syn to generate code from the RUNTIME providers via buildlib providers
    // This calls the src/ ProviderBuilder implementations
    let results = providers::process_all_providers();

    // Check results and report status (continue even if some providers fail)
    let mut failed_providers = Vec::new();
    for result in &results {
        if result.success {
            success_check!("{}", result.status);
        } else {
            eprintln!("⚠️  Provider warning: {}", result.status);
            failed_providers.push(&result.status);
        }
    }

    let successful_count = results.iter().filter(|r| r.success).count();
    let total_count = results.len();

    // Ensure at least one provider succeeded (Anthropic should always work with static models)
    if successful_count == 0 {
        return Err(anyhow::anyhow!(
            "All {} providers failed. At least one provider (like Anthropic with static models) should succeed.",
            total_count
        ));
    }

    // Report final status
    if failed_providers.is_empty() {
        success_check!("All {} providers processed successfully!", total_count);
    } else {
        colored_println!(
            "✅ Build completed: {}/{} providers succeeded. {} providers failed (likely missing API keys).",
            successful_count,
            total_count,
            failed_providers.len()
        );
    }

    // Collect generated code from successful providers
    let mut all_enum_code = Vec::new();
    let mut all_impl_code = Vec::new();

    for result in &results {
        if result.success {
            if let Some((enum_code, impl_code)) = &result.generated_code {
                all_enum_code.push(enum_code.clone());
                all_impl_code.push(impl_code.clone());
            }
        }
    }

    // Write generated code file with actual implementations
    let output_path = Path::new("src/generated_models.rs");
    let final_code = format!(
        "// Generated code - DO NOT EDIT MANUALLY\n// This file is automatically generated by build.rs\n// Successfully processed {}/{} providers\n// Failed providers: {}\n\n#[allow(unused_imports)] // Future API - needed for serialization features\nuse serde::{{Serialize, Deserialize}};\n\n// Generated Provider Enums\n{}\n\n// Generated Provider Implementations\n{}\n",
        successful_count,
        total_count,
        if failed_providers.is_empty() {
            "none".to_string()
        } else {
            failed_providers
                .iter()
                .map(|s| s.as_str())
                .collect::<Vec<_>>()
                .join(", ")
        },
        all_enum_code.join("\n\n"),
        all_impl_code.join("\n\n")
    );

    fs::write(output_path, final_code).context("Failed to write generated_models.rs")?;

    success_check!("Successfully generated src/generated_models.rs");
    colored_println!("Model code generation completed successfully!");

    Ok(())
}
