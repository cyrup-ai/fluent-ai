use anyhow::{Context, Result};
use std::fs;
use std::path::Path;
use termcolor::{info, success_check, colored_println};


pub mod providers;
pub mod codegen;

use providers::{all_providers, ProviderBuilder, ModelData};

/// Main orchestrator for the modular build system
/// Coordinates all provider modules and generates the final output
pub async fn generate_model_code() -> Result<()> {
    info!("Starting modular model code generation...");
    
    let mut all_enums = String::new();
    let mut all_impls = String::new();
    
    // Process each provider using strategy pattern
    for provider in all_providers() {
        let provider_name = provider.provider_name();
        info!("Processing {} provider...", provider_name);
        
        // Fetch models from provider API - REAL API ONLY, NO FALLBACKS
        let models = match fetch_provider_models(&provider).await {
            Ok(models) => models,
            Err(e) => {
                // Fail fast - ALL providers must use real APIs
                return Err(e).with_context(|| {
                    format!("Failed to fetch models from {} provider API. All providers must use real /v1/models endpoints.", provider_name)
                });
            }
        };
        
        if models.is_empty() {
            return Err(anyhow::anyhow!(
                "No models found for {} provider. Build cannot proceed without model data.",
                provider_name
            ));
        }
        
        // Generate code for this provider
        let (enum_code, impl_code) = provider.generate_code(&models)
            .with_context(|| format!("Failed to generate code for {} provider", provider_name))?;
        
        all_enums.push_str(&format!("\n{}\n", enum_code));
        all_impls.push_str(&format!("\n{}\n", impl_code));
        
        success_check!("Generated code for {} provider ({} models)", provider_name, models.len());
    }
    
    // Write the generated code to file
    let output_path = Path::new("src/generated_models.rs");
    let final_code = format!(
        "// Generated code - DO NOT EDIT MANUALLY\n// This file is automatically generated by build.rs\n\n{}\n{}",
        all_enums, all_impls
    );
    
    fs::write(output_path, final_code)
        .context("Failed to write generated_models.rs")?;
    
    success_check!("Successfully generated src/generated_models.rs");
    colored_println!("Model code generation completed successfully!");
    
    Ok(())
}

/// Fetch models from provider with API-first, fallback-second strategy
/// Tries real API endpoints first, falls back to static models for build resilience
async fn fetch_provider_models(provider: &dyn ProviderBuilder) -> Result<Vec<providers::ModelData>> {
    let provider_name = provider.provider_name();
    
    // Special case: Anthropic has no public /v1/models API, use static only
    if provider_name == "anthropic" {
        if let Some(static_models) = provider.static_models() {
            if !static_models.is_empty() {
                info!("Using {} static models for {} provider (no public API)", static_models.len(), provider_name);
                return Ok(static_models);
            }
        }
        return Err(anyhow::anyhow!("Anthropic provider has no static model data"));
    }
    
    // Try API first for all other providers
    let model_stream = provider.fetch_models();
    let api_models: Vec<ModelData> = model_stream.collect();
    if !api_models.is_empty() {
        info!("Fetched {} models from {} API", api_models.len(), provider_name);
        return Ok(api_models);
    }
    
    // API failed or returned no data - try static fallback
    if let Some(static_models) = provider.static_models() {
        if !static_models.is_empty() {
            info!("API failed for {} provider, using {} static fallback models", provider_name, static_models.len());
            return Ok(static_models);
        }
    }
    
    // No API data and no fallback - build fails
    Err(anyhow::anyhow!(
        "Provider {} returned no data from API and has no static fallback models",
        provider_name
    ))
}